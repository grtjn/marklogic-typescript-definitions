<apidoc:module name="Geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" 
  xmlns:apidoc="http://marklogic.com/xdmp/apidoc"
  xmlns="http://www.w3.org/1999/xhtml" lib="geo"
>
<apidoc:summary category="Geospatial Supporting Functions" 
  bucket="XQuery Library Modules">
<p>The geospatial support functions provide utilities for geospatial queries
 using GML, KML, GeoRSS/Simple, MetaCarta and GeoJSON Geospatial markup. The
 functions in the "Geo" subcategory attempt to detect the type of markup and
 adapt accordingly. You can also use one of the markup-specific subcategories
 if you know the type of data you're working with and wish to skip the
 auto-detection of format.
</p><p>
 For more details, see 
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
 in the <em>Search Developer's Guide</em> and the following function
 subcategories:
</p>
<span class="xquery">
  <ul>
    <li><a href="/geo/geo">Geo</a></li>
    <li><a href="/geojson">GeoJSON</a></li>
    <li><a href="/georss">GeoRSS</a></li>
    <li><a href="/geogml">GML</a></li>
    <li><a href="/geokml">KML</a></li>
    <li><a href="/mcgm">MGCM</a></li>
  </ul>
</span>
<span class="javascript">
  <ul>
    <li><a href="/js/geo/geo">Geo</a></li>
    <li><a href="/js/geojson">GeoJSON</a></li>
    <li><a href="/js/georss">GeoRSS</a></li>
    <li><a href="/js/geogml">GML</a></li>
    <li><a href="/js/geokml">KML</a></li>
  </ul>
</span>
</apidoc:summary>

<apidoc:summary access="public" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
<p>The Geo module provides support for geospatial queries using GML, KML,
GeoRSS/Simple, Metacarta or GeoJSON Geospatial markup. 
</p>
<span class="xquery">
  <p>To use the Geo module as part of your own XQuery module, include the
   following line in your XQuery prolog:
  </p>
  <p><code>import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";</code></p>
</span>
<span class="javascript">
  <p>To use this module in your Server-Side JavaScript code, include a
   <code>require</code> statement similar to following line in your code:
  </p>
  <p><code>var geo = require('/MarkLogic/geospatial/geospatial');</code></p>
</span>
<p>The library namespace prefix <code>geo</code> is <em>not</em> predefined
  in the server.
</p>
</apidoc:summary>

<apidoc:function name="point" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Create a <span class="xquery">cts:point</span><span class="javascript">cts.point</span>
  value from a node representing a point in one of
  the supported markup vocabularies, such as KML or GML.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="point" type="node()">
    A node representing a point.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:point </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";

geo:point(<gml:Point><gml:pos>12.5 -127.24</gml:pos></gml:Point>)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');
geo.point(
  {type: 'Point', coordinates: [100.0,0.0]}
);
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="box" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Create a <span class="xquery">cts:box</span><span class="javascript">cts.box</span>
  value from a node representing a box in one of the
  supported markup vocabularies, such as KML, GML, or GeoJSON.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="box" type="node()">
    A node representing a box.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:box </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace kml= "http://earth.google.com/kml/2.0";

geo:box(
   <kml:LatLongBox>
     <kml:north>30</kml:north>
     <kml:south>12.5</kml:south>
     <kml:east>-122.24</kml:east>
     <kml:west>-127.24</kml:west>
   </kml:LatLongBox>)
  ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

geo.box(
  { type: 'Feature',
    bbox: [-180.0, -90.0, 180.0, 90.0],
    geometry: {
      type: 'Polygon',
      coordinates: [[
        [-180.0, 10.0], [20.0, 90.0], [180.0, -5.0], [-30.0, -90.0]
      ]]
  }}
)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="circle" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Create a <span class="xquery">cts:circle</span><span class="javascript">cts.box</span>
  value from a radius and a node representing a point
  in one of the supported markup vocabularies, such as KML, GML, or GeoJSON.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="radius" type="xs:double">
    The radius of the circle, in miles.
    </apidoc:param>
    <apidoc:param name="center" type="node()">
    A node representing the point at the center of the circle.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:circle </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:circle(47, <Dot Latitude="12.5" Longitude="-127.24"/>)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

geo.circle(1, {type: 'Point', coordinates: [100.0,0.0]});
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="linestring" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Create a <span class="xquery">cts:linestring</span><span class="javascript">cts.linestring</span>
  value from a node representing a linestring in 
  one of the supported markup vocabularies, such as GML or KML.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="linestring" type="node()">
    A node representing a linesting.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:linestring </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:linestring(
   <kml:LineString id="ID">
     <kml:coordinates>-110.45,45.256  -109.48,46.46  -109.86,43.84</kml:coordinates>
   </kml:LineString>)
  ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

geo.linestring(
  { type: 'LineString', coordinates: [ [100.0, 0.0], [101.0, 1.0] ] }
);
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="polygon" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Create a <span class="xquery">cts:polygon</span><span class="javascript">cts.polygon</span>
  value from a sequence of point nodes
  in one of the supported markup vocabularies, such as KML or GML.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="polygon-or-points" type="node()+">
    A sequence of nodes, each representing a vertex (point) of the polygon, or a polygon node. 
    A polygon from one of the supported markup vocabularies represents the exterior polygon for those vocabularies that include both exterior and interior polygons in their representation.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:polygon </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:polygon(( <Dot Latitude="12.5" Longitude="-127.24"/>,
              <Dot Latitude="15.25" Longitude="-127.8"/>,
              <Dot Latitude="13.45" Longitude="-126.1"/>,
              <Dot Latitude="12.5" Longitude="-127.24"/>
           ))
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Create a cts.polygon from a set of GeoJSON points
const geo = require('/MarkLogic/geospatial/geospatial');

geo.polygon([
  {type: 'Point', coordinates: [100.0,0.0]},
  {type: 'Point', coordinates: [101.0,0.0]},
  {type: 'Point', coordinates: [101.0,1.0]},
  {type: 'Point', coordinates: [100.0,1.0]},
  {type: 'Point', coordinates: [100.0,0.0]}
]);
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="interior-polygon" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
   Create a sequence of <span class="xquery">cts:polygon</span><span class="javascript">cts.polygon</span>
   values from a polygon node
   in one of the supported markup vocabularies, such as KML or GML. These 
   polygons represent the interior polygons, if any.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="polygon" type="node()">
    A node representing a polygon.      
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:polygon* </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
    at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace georss= "http://www.georss.org/georss";

(: Returns empty; no interior polygon in this format :)
geo:interior-polygon( 
  <georss:polygon>
    12.5,-127.24 15.25,-127.8 13.45,-126.1 12.5,-127.24
  </georss:polygon>
) 
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

geo.interiorPolygon(
  { type: 'Polygon', 
    coordinates: [
      [[100.0,0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
      [[100.2,0.2], [100.8, 0.2], [100.8, 1.8], [100.2, 1.8], [100.2, 0.2]]
  ] }
);
  ]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="complex-polygon" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
   Create a <span class="xquery">cts:complex-polygon</span><span class="javascript">cts.complexPolygon</span>
   value from a node representing a complex 
   polygon in one of the supported markup vocabularies, such as KML, GML,
   or GeoJSON. The complex polygon represents the combination of the exterior
   polygon and interior polygons in their representation.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="complex-polygon" type="node()">
    A node representing a complex polygon. 
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:complex-polygon </apidoc:return>
  <apidoc:usage>
    If you know the geospatial data format (GML, KML, etc.), it is more 
    efficient to use the equivalent format-specific function.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace kml= "http://earth.google.com/kml/2.0";

geo:complex-polygon(
  <kml:Polygon>
    <kml:outerBoundaryIs><kml:LinearRing><kml:coordinates>
    -127.24,12.5 -127.8,15.25 -126.1,13.45 -127.24,12.5
    </kml:coordinates></kml:LinearRing></kml:outerBoundaryIs>
    <kml:innerBoundaryIs><kml:LinearRing><kml:coordinates>
    -127,13 127,-14 126,-14 127,-13
    </kml:coordinates></kml:LinearRing></kml:innerBoundaryIs>
  </kml:Polygon>)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

geo.complexPolygon(
  { type: 'Polygon', 
    coordinates: [
      [[100.0,0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
      [[100.2,0.2], [100.8, 0.2], [100.8, 1.8], [100.2, 1.8], [100.2, 0.2]]
  ] }
);
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="geospatial-query" type="geo" lib="geo" subcategory="GEO"
    bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
   Returns a query matching points within given regions.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, linestrings or points. 
    Where multiple boxes, circles, polygons, lingstrings or points are specified, 
    the query matches if any box, circle, polygon, linestring or point matches.
    </apidoc:param>
    <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p>Options include:</p>
      <blockquote>
        <dl>
        <dt>"coordinate-system=<var>string</var>"</dt>
        <dd>Use the given coordinate system. Valid values are:
          <dl>
          <dt>wgs84</dt><dd>The WGS84 coordinate system.</dd>
          <dt>wgs84/double</dt><dd>The WGS84 coordinate system at double precision.</dd>
          <dt>etrs89</dt><dd>The ETRS89 coordinate system.</dd>
          <dt>etrs89/double</dt><dd>The ETRS89 coordinate system at double precision.</dd>
          <dt>raw</dt><dd>The raw (unmapped) coordinate system.</dd>
          <dt>raw/double</dt><dd>The raw coordinate system at double precision.</dd>
          </dl>
        </dd>
        <dt>"units=<em>value</em>"</dt>
        <dd>Measure distance and the radii of circles in the specified units.
         Allowed values: <code>miles</code> (default), <code>km</code>,
         <code>feet</code>, <code>meters</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the coordinate system at the given precision. Allowed values:
         <code>float</code> and <code>double</code>.</dd>
        <dt>"type=<em>value</em>"</dt>
        <dd>Specify the format of point coordinates, either (lat,long)
         or (long,lat). Latitude-first order is the default. Allowed values: 
         <code>point</code> (default) or <code>long-lat-point</code>.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes' and circles' boundaries are counted as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
    </apidoc:param>
    <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:query </apidoc:return>
<apidoc:usage>
<p>Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western 
longitudes take negative values.  Longitudes will be wrapped to the range 
(-180,+180) and latitudes will be clipped to the range (-90,+90).  
</p>
<p>If the northern boundary of a box is south of the southern boundary, no 
points will  match. However, longitudes wrap around the globe, so that if 
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p>Special handling occurs at the poles, as all longitudes exist at latitudes 
+90 and -90.
</p>
<p>The query constructed will examine points in all the supported geospatial
markup vocabularies.  If not all these vocabularies will be in use, it may
be more efficient to use the query constructors for just the vocabulary or 
vocabularies that are in actual use.
</p>
</apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
(: create a document with test data :)
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";

xdmp:document-insert("/points.xml",
<root xmlns:geo="http://marklogic.com/geospatial">
  <item><gml:Point><gml:pos>10.5 30.0</gml:pos></gml:Point></item>
  <item><georss:point>15.35 35.34</georss:point></item>
  <item><Dot Latitude="5.11" Longitude="40.55"/></item>
</root> );

xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
   at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";
declare namespace kml= "http://earth.google.com/kml/2.0";

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query(
    geo:box(
      <gml:Envelope>
        <gml:lowerCorner>10.0 35.0</gml:lowerCorner>
        <gml:upperCorner>20.0 40.0</gml:upperCorner>
      </gml:Envelope>)
  ))
(:
  returns the following node: 
  <item><georss:point>15.35 35.34</georss:point></item>
:)
,

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query(geo:box(
    <kml:LatLongBox>
      <kml:north>20.0</kml:north>
      <kml:south>10.0</kml:south>
      <kml:east>35.0</kml:east>
      <kml:west>40.0</kml:west>
    </kml:LatLongBox>
  )))
(:
  returns the following nodes (wrapping around the Earth):
  <item><gml:Point><gml:pos>10.5 30.0</gml:pos></gml:Point></item>
:)
,

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query(
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  <item><georss:point>15.35 35.34</georss:point></item>
:)
 
]]></pre></apidoc:example>
<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Assume you've previously inserted the following document into the database.
declareUpdate();
xdmp.documentInsert('example.json',
  { type: 'Feature',  
    geometry: {    
      type: 'Point',    
      coordinates: [125.6, 8.1]
     },
     properties: { name: 'Test' }
  });

// Then in a separate query, you can perform the following search
// to match this document.
const geo = require('/MarkLogic/geospatial/geospatial');
cts.search(
  geo.geospatialQuery(
    cts.box(1, 120, 35, 131), 
    ['coordinate-system=wgs84'], 
    2.0));

// Returns the contents of example.json
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="geospatial-query-from-elements" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions">
  <apidoc:summary>
  Returns a query matching points within given regions.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="regions" type="element()*">
    One or more geographic boxes, circles, polygons, linestring or points, represented
    by elements in one of the supported vocabularies.
    Where multiple boxes, circles, polygons, linestring or points are specified, 
    the query matches if any box, circle, polygon, linestring or point matches.
    </apidoc:param>
    <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p>Options include:</p>
      <blockquote>
        <dl>
        <dt>"coordinate-system=<var>string</var>"</dt>
          <dd>Use the given coordinate system. Valid values are:
            <dl>
             <dt>wgs84</dt><dd>The WGS84 coordinate system.</dd>
             <dt>wgs84/double</dt><dd>The WGS84 coordinate system, at double precision.</dd>
             <dt>raw</dt><dd>The raw (unmapped) coordinate system.</dd>
             <dt>raw/double</dt><dd>The raw (unmapped) coordinate system, at double precision.</dd>
            </dl>
          </dd>
        <!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes' and circles' boundaries are counted as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
    </apidoc:param>
    <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return> cts:query </apidoc:return>
<apidoc:usage>
<p>Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western 
longitudes take negative values.  Longitudes will be wrapped to the range 
(-180,+180) and latitudes will be clipped to the range (-90,+90).  
</p>
<p>If the northern boundary of a box is south of the southern boundary, no 
points will  match. However, longitudes wrap around the globe, so that if 
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p>Special handling occurs at the poles, as all longitudes exist at latitudes 
+90 and -90.
</p>
<p>The query constructed will examine points in all the supported geospatial
markup vocabularies.  If not all these vocabularies will be in use, it may
be more efficient to use the query constructors for just the vocabulary or 
vocabularies that are in actual use.
</p>
<p>This function will take into account interior polygons, if any, and properly
construct the query to account for them.
</p>
</apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
(: create a document with test data :)
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";

xdmp:document-insert("/points.xml",
<root xmlns:geo="http://marklogic.com/geospatial">
  <item><gml:Point><gml:pos>10.5 30.0</gml:pos></gml:Point></item>
  <item><georss:point>15.35 35.34</georss:point></item>
  <item><Dot Latitude="5.11" Longitude="40.55"/></item>
</root> );

xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
   at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";
declare namespace kml= "http://earth.google.com/kml/2.0";

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query-from-elements(
    <gml:Envelope>
      <gml:lowerCorner>10.0 35.0</gml:lowerCorner>
      <gml:upperCorner>20.0 40.0</gml:upperCorner>
    </gml:Envelope>
  ) )
(:
  returns the following node: 
  <item><georss:point>15.35 35.34</georss:point></item>
:)
,

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query-from-elements(
    <kml:LatLongBox>
      <kml:north>20.0</kml:north>
      <kml:south>10.0</kml:south>
      <kml:east>35.0</kml:east>
      <kml:west>40.0</kml:west>
    </kml:LatLongBox>
  ))
(:
  returns the following nodes (wrapping around the Earth):
  <item><georss:point>15.35 35.34</georss:point></item>
  <item><gml:Point><gml:pos>10.5 30.0</gml:pos></gml:Point></item>
:)
]]></pre></apidoc:example>
<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');
const gmlElem = 
  fn.head(xdmp.unquote(
    '<gml:Envelope xmlns:gml="http://www.opengis.net/gml">' +
       '<gml:lowerCorner>10.0 35.0</gml:lowerCorner>' +
       '<gml:upperCorner>20.0 40.0</gml:upperCorner>' +
    '</gml:Envelope>')).root;
geo.geospatialQueryFromElements(gmlElem); 
]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="geospatial-query-from-nodes" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" 
    category="Geospatial Supporting Functions">
  <apidoc:summary>
  Returns a query matching points within given regions.  
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="regions" type="node()*">
      One or more geographic boxes, circles, polygons, linestring or points, 
      represented by either XML elements or JSON object nodes in one of the 
      supported vocabularies. Where multiple boxes, circles, polygons, 
      linestring or points are specified, the query matches if any box, 
      circle, polygon, linestring or point matches.
    </apidoc:param>
    <apidoc:param name="options" type="xs:string*" optional="true">
      Options to this query. The default is ().
    <p>Options include:</p>
      <blockquote>
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes' and circles' boundaries are counted as matching.  
          This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes' and circles' boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
          matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
    </apidoc:param>
    <apidoc:param name="weight" type="xs:double?" optional="true">
      A weight for this query.  The default is 1.0.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>cts:query</apidoc:return>
  <apidoc:usage>
    This function simply redirects to 
    <a href="#geospatial-query-from-elements"><code>geospatial-query-from-elements</code></a> 
    (if the input region is an XML element) or to
    <a href="#geojson:geospatial-query-from-nodes"><code>geojson:geospatial-query-from-nodes</code></a> 
    (if the input region is a JSON object node). See the API docs of those 
    two functions for more details.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
(: create a document with test data :)
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";

xdmp:document-insert("/points.xml",
<root xmlns:geo="http://marklogic.com/geospatial">
  <item><gml:Point><gml:pos>10.5 30.0</gml:pos></gml:Point></item>
  <item><georss:point>15.35 35.34</georss:point></item>
  <item><Dot Latitude="5.11" Longitude="40.55"/></item>
</root> );

xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
   at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";
declare namespace kml= "http://earth.google.com/kml/2.0";

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query-from-nodes(
    <gml:Envelope>
      <gml:lowerCorner>10.0 35.0</gml:lowerCorner>
      <gml:upperCorner>20.0 40.0</gml:upperCorner>
    </gml:Envelope>
  ) )
(:
  returns the following node: 
  <item><georss:point>15.35 35.34</georss:point></item>
:)
,

cts:search(doc("/points.xml")//item, 
  geo:geospatial-query-from-nodes(
    <kml:LatLongBox>
      <kml:north>20.0</kml:north>
      <kml:south>10.0</kml:south>
      <kml:east>35.0</kml:east>
      <kml:west>40.0</kml:west>
    </kml:LatLongBox>
  ))
]]></pre></apidoc:example>
<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Assume you previously inserted a document into the database, as follows:
declareUpdate();
xdmp.documentInsert('example.json',
  { type: 'Feature',  
    geometry: {    
      type: 'Point',    
      coordinates: [125.6, 8.1]
     },
     properties: { name: 'Test' }
  });

// Then the following search matches the above document.
const geo = require('/MarkLogic/geospatial/geospatial');
cts.search(
  geo.geospatialQueryFromNodes(
    { "type": "Polygon",
      "coordinates": [
        [ [35, 1], [131, 1], [131, 120], [35, 120], [35, 1] ]
      ]
    }
));
]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="parse" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" 
	category="Geospatial Supporting Functions">
  <apidoc:summary>
    Convert nodes in one or more of the supported geospatial
    representations into 
    <span class="xquery"><code>cts:region</code></span><span class="javascript">cts.region</span> 
    values.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="data" type="node()*">
      Zero or more nodes containing geospatial data in one of the supported 
      formats, such as KML, GML, GeoRSS, or GeoJSON.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>cts:region*</apidoc:return>
  <apidoc:usage>
    This function examines each input node and delegates to the appropriate
    format-specific parsing function, such as 
    <code class="xquery">gml:parse-gml</code><code class="javascript">gml.parseGml</code> 
    or 
    <code class="xquery">geojson:parse-geojson</code><code class="javascript">geojson.parseGeojson</code>. 
    The input nodes need not all use the same representation.
    <p class="javascript">
      The returned <code>Sequence</code> contains <code>cts:region</code>
      values.
    </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2396147'>Converting To and From Common Geospatial Representations</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";

(: Construct a cts:polygon from GeoJSON data. :)
geo:parse((
  <gml:Point xmlns:gml="http://www.opengis.net/gml/3.2">
    <gml:pos>12.5 -127.24</gml:pos>
  </gml:Point>,
  xdmp:unquote('
    { "type": "Polygon", 
      "coordinates": [
        [[1.0, 5.0], [1.0, 8.0], [6.0, 8.0], [7.0, 5.0], [1.0, 5.0]]
    ]}
  ')/object-node()
))

==> A cts:point created from a GML node and a cts:polygon created 
    from a GeoJSON node, similar to the following:
    (cts:point("12.5,-127.24"), cts:polygon("5,1 8,1 8,6 5,7 5,1"))
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require('/MarkLogic/geospatial/geospatial');

const gmlNode =
  gml.point(xdmp.unquote(
    '<gml:Point xmlns:gml="http://www.opengis.net/gml">' +
      '<gml:pos>12.5 -127.24</gml:pos>' +
    '</gml:Point>')
    .next().value.root);
const geoJsonNode =
  { type: 'Polygon', 
    coordinates: [
      [[1.0, 5.0], [1.0, 8.0], [6.0, 8.0], [7.0, 5.0], [1.0, 5.0]]
  ] };
geo.parse([gmlNode, geoJsonNode])

==> A Sequence that contains a cts.point created from a GML node
    and a cts.polygon created from a GeoJSON node, similar to the following.
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="polygon-to-linestring" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" 
	category="Geospatial Supporting Functions">
  <apidoc:summary>
    Construct a linestring from the vertices of a polygon, or
    construct a sequence of linestrings from the outer and inner
    polygons of a complex polygon.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="region" type="cts:region">
      <span class="xquery">A cts:polygon or cts:complex-polygon from 
       which to generate a linestring or linestrings.</span>
      <span class="javascript">A cts.polygon or cts.complexPolygon from 
       which to generate a linestring or linestrings.</span>
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>cts:linestring*</apidoc:return>
  <apidoc:usage>
    <p>
      The vertex that closes the loop is excluded from the result linestring(s).
    </p><p>
      An error is thrown if any of the input values is not a polygon
      or complex polygon.
    </p><p class="javascript">
      The return <code>Sequence</code> contains cts.linestring values.
    </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:polygon-to-linestring(
  cts:polygon((
    cts:point(1,1),cts:point(2,2),
    cts:point(3,3),cts:point(1,1)
  ))
)

==> A cts:linestring similar to the following:
    cts:linestring("LINESTRING(1 1,2 2,3 3)")
  ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require("/MarkLogic/geospatial/geospatial");

geo.polygonToLinestring(
  cts.polygon([
    cts.point(1,1),cts.point(2,2),
    cts.point(3,3),cts.point(1,1)
  ])
)

// A Sequence containing a cts.linestring
  ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="linestring-reverse" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" 
	category="Geospatial Supporting Functions">
  <apidoc:summary>
    Construct a linestring with the vertices in reverse order.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="linestring" type="cts:linestring">
      The linestring to be reversed.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>cts:linestring</apidoc:return>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:linestring-reverse(
  cts:linestring(
    (cts:point(1,1), cts:point(2,2), cts:point(3,3))
  )
)

==> A cts:linestring similar to the following:
    cts:linestring("LINESTRING(3 3,2 2,1 1)")
  ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require("/MarkLogic/geospatial/geospatial");

geo.linestringReverse(
  cts.linestring([
    cts.point(1,1),cts.point(2,2),
    cts.point(3,3),cts.point(1,1)
  ])
)

// A cts.linestring equivalent to the following WKT:
//  LINESTRING(3 3,2 2,1 1)
  ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="linestring-concat" type="geo" lib="geo" 
	subcategory="GEO" bucket="XQuery Library Modules" 
	category="Geospatial Supporting Functions">
  <apidoc:summary>
    Construct a linestring by concatenating the vertices of the
    input linestrings, in order.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="linestrings" type="cts:linestring*">
      The linestrings to be concatenated.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>cts:linestring</apidoc:return>
  <apidoc:usage>
    If the last vertex of one input linestring is the first vertex of
    another linestring, that vertex is not duplicated.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/geospatial.xml%2386523'>Geospatial Search Applications</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
       at "/MarkLogic/geospatial/geospatial.xqy";

geo:linestring-concat((
  cts:linestring((cts:point(1,1),cts:point(2,2),cts:point(3,3))),
  cts:linestring((cts:point(3,3),cts:point(4,4),cts:point(5,5)))
))

==> A cts:linestring similar to the following:
    cts:linestring("LINESTRING(1 1,2 2,3 3,4 4,5 5)")
  ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const geo = require("/MarkLogic/geospatial/geospatial");

geo.linestringConcat([
  cts.linestring([cts.point(1,1),cts.point(2,2),cts.point(3,3)]),
  cts.linestring([cts.point(3,3),cts.point(4,4),cts.point(5,5)])
])

// A cts.linestring equivalent to the following WKT:
// LINESTRING(1 1,2 2,3 3,4 4,5 5)
  ]]></pre>
  </apidoc:example>
</apidoc:function>

</apidoc:module>
