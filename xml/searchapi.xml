<!-- Copyright 2002-2012 MarkLogic Corporation.  All Rights Reserved. -->
<apidoc:module name="SearchBoxModule" category="Search" lib="search"
  bucket="XQuery Library Modules"
  xmlns:apidoc="http://marklogic.com/xdmp/apidoc"
  xmlns="http://www.w3.org/1999/xhtml" class="xquery">
  <apidoc:summary category="Search">
    <p>The Search function module is installed as the following file:</p>
    <ul>
      <li>
        <code><em>install_dir</em>/Modules/MarkLogic/appservices/search/search.xqy</code>
      </li>
    </ul>
    <p>where <code>
        <em>install_dir</em>
      </code> is the directory in which MarkLogic Server is installed.</p>
      <p>To use the <code>search.xqy</code> module in your own XQuery modules, 
	      include the following line in your XQuery prolog:</p>
    <pre xml:space="preserve">
import module namespace search="http://marklogic.com/appservices/search"
                    at "/MarkLogic/appservices/search/search.xqy";</pre>
	    <p>The Search functions are used to create search high-level 
		    results, facets, snippets, and other search-related 
		    items.</p>
  </apidoc:summary>
  <apidoc:function name="check-options" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function verifies that options XML is 
		  properly structured. Used in debugging, normally not 
		  in production. Returns the empty sequence on success, 
		  otherwise it returns one or more error messages 
		  inside <code>&lt;report&gt;</code> elements.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="options" type="element(search:options)">
		    Options that define the search 
		    grammar and control the search. See the description for 
		    <a href="#search:search#search-options"><code>$options</code></a>
		    for the function <code>search:search</code>. 
      </apidoc:param>
      <apidoc:param name="strict" type="xs:boolean?" optional="true">If 
	      <code>true</code>, index settings are additionally 
	      verified. The default is <code>false</code>.
      </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(search:report)*</apidoc:return>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:check-options(
    <options xmlns="http://marklogic.com/appservices/search">
      <grammar>
        <joiner strength="10" apply="infix"
                element="cts:or-query">|</joiner>
        <joiner strength="20" apply="infix"
                element="cts:and-query">&amp;</joiner>
      </grammar>
    </options>)

=>

()
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="estimate" lib="search" category="Search"
          bucket="XQuery Library Modules">
	<apidoc:summary>
      This function quickly estimates the number of hits a query will return.
      The result is unfiltered and reflects the index resolution of the search.
	</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="cts-query" type="element()">
        A cts:query object or serialized cts:query.
	  </apidoc:param>
	  <apidoc:param name="options" type="element(search:options)?" optional="true">
        Search API query options with which to customize the search.
        For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2338093'>Appendix: Query Options Reference</a> in the <em>Search Developer's Guide</em>.
	  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:unsignedLong</apidoc:return>
    <apidoc:usage>
     This function is equivalent to calling 
     <a href="#xdmp:estimate">xdmp:estimate</a> in XQuery with a
     <code>cts:search</code> expression, or to calling
     <a href="#cts.estimate">cts.estimate</a> in Server-Side JavaScript, 
     except that this function enables you to include Search API
     query options in the search.
     For example, the following calls are equivalent:
<pre xml:space="preserve"><![CDATA[
(: XQuery :)
xdmp:estimate(cts:search(fn:doc(),cts:parse("merry")))
search:estimate(search:parse("merry"))

// JavaScript
cts.estimate(cts.wordQuery("merry");
cts.search(search.parse("merry"));
]]></pre>
    </apidoc:usage>
    <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:estimate(search:parse("merry"))

(: Returns an estimate of the number of fragments matching the
   word query produced by search:parse.
 :)
    ]]></pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:estimate(cts:word-query("merry"))

(: Returns an estimate of the number of fragments matching the word query. :)
    ]]></pre></apidoc:example>
  </apidoc:function>
  <apidoc:function name="get-default-options" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function returns the default options 
		  XML. Default options do not contain any constraints 
		  or anything else that requires specific index 
		  settings.</apidoc:summary>
    <apidoc:return>element(search:options)</apidoc:return>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:get-default-options()

=>

<options xmlns="http://marklogic.com/appservices/search">
  ...
</options>
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="parse" lib="search" category="Search"
          bucket="XQuery Library Modules">
    <apidoc:summary>This function parses query text according 
      to given options and returns the appropriate 
      <code>cts:query</code> XML.</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="qtext" type="xs:string+">The query 
        text to parse. This may be a sequence, to accommodate 
        more complex search UI. Multiple query texts will be 
        ANDed together.</apidoc:param>
      <apidoc:param name="options" type="element(search:options)?" 
        optional="true">Options to define the search 
        grammar and control the search. See the description for 
        <a href="#search:search#search-options">$options</a> 
        for the function <code>search:search</code>. 
      </apidoc:param>
      <apidoc:param name="output" optional="true" type="xs:string?">
        The format of the parsed query, one of
        <code>schema-element(cts:query)</code> (default), 
        <code>cts:query</code>, <code>search:query</code>, or
        <code>cts:annotated-query</code> (deprecated). See the Usage Notes 
        for details. 
      </apidoc:param>
    </apidoc:params>
    <apidoc:return>element()?</apidoc:return>
    <apidoc:usage>
     Use the <code>$output</code> parameter to specify one of the 
     following output formats. All the formats are suitable for use with
     <a href="#search:resolve">search:resolve</a>, but "cts:query" is
     most efficient if you do not need to transform or traverse the query. 
     Passing a cts:query object avoids an extra parsing step.
     <ul>
      <li><code>schema-element(cts:query)</code>: The XML serialization of
        a cts:query object. Use this form if you want a cts:query but
        need to transform or inspect the query tree, or if you need a
        serialized query. This is the default result type.
      </li>
      <li><code>cts:query</code>: A cts:query object that can be passed to
        functions such as <code>cts:search</code>, <code>cts:values</code>,
        <code>cts:value-tuples</code>, <code>xdmp:sql</code>, 
        <code>sem:sparql</code>, <code>op:when</code>, or their Server-Side
        JavaScript equivalents, without additional modification. This form
        is most efficient, but cannot be modified or traversed.
      </li>
      <li><code>search:query</code>: The XML serialization of a structured
        query that you can use with <code>search:resolve</code>. You can
        also use structured queries with the Node.js, Java, or 
        REST Client APIs, though the Java and Node.js APIs have query
        builder interfaces that usually make a raw query unnecessary.
      </li>
      <li><code>cts:annotated-query</code>: Equivalent to the output
        produced by <code>schema-element(cts:query)</code>, but with the
        addition of annotations. THIS FORM IS DEPRECATED and will be
        removed in a future release.
      </li>
     </ul>
    </apidoc:usage>
    <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

search:parse("tag:technology AND format:pdf",
   <options xmlns="http://marklogic.com/appservices/search">
     <constraint name="tag">
       <collection/>
     </constraint>
     <constraint name="format">
        <value>
          <element ns="http://purl.org/dc/elements/1.1/" name="tag"/>
        </value>
     </constraint>
   </options>
) 

==>

<cts:and-query xmlns:cts="http://marklogic.com/cts">
  <cts:collection-query>
    <cts:uri>technology</cts:uri>
  </cts:collection-query>
  <cts:element-value-query>
    <cts:element xmlns:_1="http://purl.org/dc/elements/1.1/">_1:tag</cts:element>
    <cts:text xml:lang="en">pdf</cts:text>
  </cts:element-value-query>
</cts:and-query>
]]></pre></apidoc:example>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

search:parse("hello tag:technology AND format:pdf",
   <options xmlns="http://marklogic.com/appservices/search">
     <constraint name="tag">
       <collection/>
     </constraint>
     <constraint name="format">
        <value>
          <element ns="http://purl.org/dc/elements/1.1/" name="tag"/>
        </value>
     </constraint>
   </options>, "search:query")

=> the following structured query:

<search:query xmlns:search="http://marklogic.com/appservices/search">
  <search:and-query>
    <search:term-query>
      <search:text>hello</search:text>
    </search:term-query>
    <search:and-query>
      <search:collection-constraint-query>
        <search:constraint-name>tag</search:constraint-name>
        <search:uri>technology</search:uri>
      </search:collection-constraint-query>
      <search:value-constraint-query>
        <search:constraint-name>format</search:constraint-name>
        <search:text>pdf</search:text>
      </search:value-constraint-query>
    </search:and-query>
  </search:and-query>
</search:query>
]]></pre></apidoc:example>
  </apidoc:function>
  <apidoc:function name="remove-constraint" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>NOTE: This function is deprecated. This function safely 
          removes a token from query text, 
		  ensuring that grammar elements (AND, OR, quotes, 
		  parentheses) are handled properly.</apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="qtext" type="xs:string">The full query 
		    text string.</apidoc:param>
	    <apidoc:param name="ptext" type="xs:string">A token to remove 
		    from full query text.</apidoc:param>
	    <apidoc:param name="options" type="element(search:options)?">
		    Options to define the search 
		    grammar and control the search. See the description for 
		    <a href="#search:search#search-options"><code>$options</code></a> 
		    for the function <code>search:search</code>. 
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string?</apidoc:return>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
   at "/MarkLogic/appservices/search/search.xqy";

let $options :=
 <options xmlns="http://marklogic.com/appservices/search">
   <constraint name="tag">
     <word>
      <element ns="http://widgets-r-us.com" name="tag"/>
     </word>
   </constraint>
   <constraint name="year">
     <value>
      <element ns="http://widgets-r-us.com" name="year"/>
     </value>
   </constraint>
 </options>
return
search:remove-constraint("tag:foo AND (year:2007 OR year:2008)",
   "year:2008", $options)

=>
"tag:foo AND year:2007"
]]>
</pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="resolve" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function is the same as 
		  <code>search:search</code>, except that it takes 
		  a parsed and annotated <code>cts:query</code> XML node or a 
      structured search <code>search:query</code> XML node as 
		  input.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="query" type="element()">
            A cts:query object, a serialized <code>cts:query</code>, or
		    a structured query (<code>search:query</code>). 
		    You can generate any of these forms of query using
		    <a href="#search:parse">search:parse</a>.
	    </apidoc:param> 
	    <apidoc:param name="options" type="element(search:options)?" 
		    optional="true">Options to define the search 
		    grammar and control the search. See the description for 
		    <a href="#search:search#search-options">$options</a>
		    for the function <code>search:search</code>. 
	    </apidoc:param>
	    <apidoc:param name="start" type="xs:unsignedLong?" 
		    optional="true">The index of the first hit to return. 
		    The default is 1.
	    </apidoc:param>
	    <apidoc:param name="page-length" type="xs:unsignedLong?" 
		    optional="true">The maximum number of hits to return. 
		    The default is 10. If the value is 0, no results 
		    are returned.
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(search:response)</apidoc:return>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:resolve(search:parse("Vannevar Bush"),
    <options xmlns="http://marklogic.com/appservices/search">
      <return-results>false</return-results>
      <return-facets>true</return-facets>
    </options>)

=>

<search:response total="1234" start="1" page-length="10" xmlns=""
        xmlns:search="http://marklogic.com/appservices/search">
  <search:facet name="date">
	  <search:facet-value value="today" count="1000">
		  Today</search:facet-value>
	  <search:facet-value value="yesterday" count="234">
		  Yesterday</search:facet-value>
	  <search:facet-value value="thismonth" count="1234">
		  This Month</search:facet-value>
  <search:/facet>
    ...
</search:response>
]]>
      </pre>
    </apidoc:example>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
(: structured query example, plain search for "hello" :)
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

let $struct-query :=
<query xmlns="http://marklogic.com/appservices/search">
 <term-query>
  <text>hello</text>
 </term-query>
</query>
return
search:resolve($struct-query)
=> returns the a search:response node that matches a query for "hello"      
      
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="resolve-nodes" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function performs the same search as 
		  <code>search:search</code>, but it takes 
		  a parsed and annotated <code>cts:query</code> XML node or a 
      structured search <code>search:query</code> XML node as 
		  input and returns the actual result nodes from the database.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="query" type="element()">Either a
		    serialized and annotated <code>cts:query</code>, or
		    a structured query (<code>search:query</code>). 
		    You can generate either form of query as the result of a 
		    call to 
		    <a href="#search:parse"><code>search:parse</code></a>.
	    </apidoc:param> 
	    <apidoc:param name="options" type="element(search:options)?" 
		    optional="true">Options to define the search 
		    grammar and control the search. See the description for 
		    <a href="#search:search#search-options"><code>$options</code></a> 
		    for the function <code>search:search</code>. 
	    </apidoc:param>
            <apidoc:param name="start" type="xs:unsignedLong?" 
		    optional="true">The index of the first hit to return. 
		    The default is 1.
            </apidoc:param> 
	    <apidoc:param name="page-length" type="xs:unsignedLong?" 
		    optional="true">The maximum number of hits to return. 
		    The default is 10. If the value is 0, no results are 
		    returned.
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:usage>
      When used in conjunction with the <code>extract-document-data</code>
      option, each returned node contains the data specified by the
      extraction, rather than the entire document or fragment.
      <p>To obtain a <code>search:response</code> instead of the matching
      nodes, use <code>search:resolve</code>.</p>
    </apidoc:usage>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:resolve-nodes(search:parse("Vannevar Bush"),
    <options xmlns="http://marklogic.com/appservices/search">
      <return-results>false</return-results>
      <return-facets>true</return-facets>
    </options>)

=>

... sequence of document nodes ...

]]>
      </pre>
    </apidoc:example>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
(: structured query example, plain search for "hello" :)
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

let $struct-query :=
<query xmlns="http://marklogic.com/appservices/search">
 <term-query>
  <text>hello</text>
 </term-query>
</query>
return
search:resolve-nodes($struct-query)
=> returns the nodes that match a query for "hello"      
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="search" lib="search" category="Search"
          bucket="XQuery Library Modules">
          <apidoc:summary>This function parses and invokes a query according to
                  specified options, returning up to $page-length result nodes
                  starting from $start.</apidoc:summary>
    <apidoc:params>
            <apidoc:param name="qtext" type="xs:string+">The query text to
                    parse. This may be a sequence,
                    to accommodate more complex search UI. Multiple query texts
                    are combined with an AND operator.</apidoc:param>
            <apidoc:param name="options" type="element(search:options)?"
                    optional="true">Options to define
        the search grammar and control the search.
	<p id="search-options"> The following is a list of the options that
        apply to document searches. The options node can contain other
        options, such as a <code>values</code> specification, but such
        options are not used in this context. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2338093'>Appendix: Query Options Reference</a> in the <em>Search Developer's Guide</em>.</p>
 <p>   
  <ul>
    <li>
     <code>additional-query</code> - Additional query(s) to apply to the 
     search. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2367369'>additional-query</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>concurrency-level</code> - The maximum number of threads to
     use when resolving facets. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2373850'>concurrency-level</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>constraint</code> - Limit the scope of a search and define facets.
     For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2358121'>constraint</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>debug</code> - Enable or disable inclusion of debugging
     data in the search results. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2368047'>debug</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>default-suggestion-source</code> - Define a source for generating
     suggestions for naked terms. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2335361'>default-suggestion-source</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>extract-document-data</code> - Select elements, attributes, and
     JSON properties to include in the search results. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2344222'>extract-document-data</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>extract-metadata</code>: This option is deprecated. Use
     <code>extract-document-data</code> instead. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2344222'>extract-document-data</a> in the <em>Search Developer's Guide</em>.
    </li><li>
     <code>forest</code> - Limit a search or lexicon query to specific 
     forests. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2397358'>forest</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>fragment-scope</code> - Control the global fragment scope 
     (properties or documents) over which to search. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2392359'>fragment-scope</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>grammar</code> - Define a custom search grammar. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2374329'>grammar</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>operator</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2341671'>operator</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>page-length</code> - The number of results to return in each
     page of results. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2375920'>page-length</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>quality-weight</code> - A document quality weight to use when
     computing scores. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2330469'>quality-weight</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>result-decorator</code> - Specify a function with which to 
     decorate each search results with additional information. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2319328'>result-decorator</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-constraints</code> - Whether or not to include the input
     constraint definitions in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2377238'>return-constraints</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-facets</code> - Whether or not to include facets in the
     search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2366556'>return-facets</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-metrics</code> - Whether or not to include query
     performance data in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2368566'>return-metrics</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-plan</code> - Whether or not to include a query plan
     in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2371285'>return-plan</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-qtext</code> - Whether or not to include the input
     query text in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2314940'>return-qtext</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-query</code> - Whether or not to include the final
     representation of the input query in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2360243'>return-query</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-results</code> - Whether or not to include search result
     details in the search response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2358163'>return-results</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-similar</code> - Whether or not to include a list of
     similar document for each search result in the response. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2350505'>return-similar</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>search-option</code> - Specify an advanced option to pass to
     the underlying cts query layer. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2377801'>search-option</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>searchable-expression</code> - An XPath expression that selects
     the documents to include in a search.  For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2360011'>searchable-expression</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>sort-order</code> - Define elements, attributes, fields, or
     JSON properties on which to order results. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2344212'>sort-order</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>suggestion-source</code> - Define a suggestion completion
     source for constraint-qualified search terms. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2312318'>suggestion-source</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>term</code> - Specify the handling of empty searches and
     search terms not associated with a constraint. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2331590'>term</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>transform-results</code> - Specify a function to use for
     generating snippets. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2350098'>transform-results</a> in the <em>Search Developer's Guide</em>
    </li>
  </ul>    
 </p>   
      </apidoc:param>
      <apidoc:param name="start" type="xs:unsignedLong?" optional="true">The 
	      index of the first hit to return. If 0, treated as 1. If 
	      greater than the number of results, no results will be
	      returned. The default is 1.
      </apidoc:param>
      <apidoc:param name="page-length" type="xs:unsignedLong?" 
	      optional="true">The maximum number of hits to return. 
	      The default is 10. If the value is 0, no results are returned.
       </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(search:response)</apidoc:return>

     <apidoc:usage>
	    <p>The output of <code>search:search</code> returns a 
		    <code>&lt;response&gt;</code> element, which in turn 
		    contains a <code>total</code> attribute. The value of the
		    <code>total</code> attribute is an estimate, based
		    on the index resolution of the query, and it is not 
		    filtered for accuracy. The accuracy of the index resolution
		    depends on the index configuration of the database, on the
		    query, and on the data being searched. 
	    </p>
    </apidoc:usage>

    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:search("Vannevar Bush",
    <options xmlns="http://marklogic.com/appservices/search">
      <return-results>false</return-results>
      <return-facets>true</return-facets>
    </options>)

=>

<search:response total="1234" start="1" page-length="10" xmlns=""
        xmlns:search="http://marklogic.com/appservices/search">
  <search:facet name="date">
	  <search:facet-value value="today" count="1000">
		  Today</search:facet-value>
	  <search:facet-value value="yesterday" count="234">
		  Yesterday</search:facet-value>
	  <search:facet-value value="thismonth" count="1234">
		  This Month</search:facet-value>
  <search:/facet>
    ...
</search:response>
]]>
    </pre>
    </apidoc:example>
    <apidoc:example><a id="prop-constraint"/>
      <pre xml:space="preserve"><![CDATA[
(: properties constraint example :)
xquery version "1.0-ml";
(: create a document with some properties to test with :)
xdmp:document-insert("/foo.xml", <foo>hello</foo>);
xdmp:document-set-properties("/foo.xml", <blah>boo</blah>);

(: do a properties constraint search :)
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

search:search("hello sample-property-constraint:boo",
<options xmlns="http://marklogic.com/appservices/search">
  <constraint name="sample-property-constraint">
    <properties />
  </constraint>
  <debug>true</debug>
</options>)

=>

<search:response total="1" start="1" page-length="10" xmlns=""
	xmlns:search="http://marklogic.com/appservices/search">
  <search:result index="1" uri="/foo.xml" 
		path="fn:doc(&quot;/foo.xml&quot;)" score="328" 
		confidence="0.807121" fitness="0.901397">
    <search:snippet>
	    <search:match path="fn:doc(&quot;/foo.xml&quot;)/foo">
		    <search:highlight>hello</search:highlight></search:match>
    </search:snippet>
  </search:result>
  <search:qtext>hello sample-property-constraint:boo</search:qtext>
  <search:report id="SEARCH-FLWOR">(cts:search(fn:collection(), 
	  cts:and-query((cts:word-query("hello", ("lang=en"), 1), 
	  cts:properties-query(cts:word-query("boo", ("lang=en"), 1))), 
	  ()), ("score-logtfidf"), 1))[1 to 10]
  </search:report>
  <search:metrics>
    <search:query-resolution-time>PT0.647S</search:query-resolution-time>
    <search:facet-resolution-time>PT0S</search:facet-resolution-time>
    <search:snippet-resolution-time>PT0.002S</search:snippet-resolution-time>
    <search:total-time>PT0.651S</search:total-time>
  </search:metrics>
</search:response>

]]>
    </pre>
    </apidoc:example>
  </apidoc:function>

  <apidoc:function name="snippet" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function extracts matching text from the
		  result node based on options, and returns the matches 
		  wrapped in a containing node, with highlights 
		  tagged.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="result" type="node()">A node from which 
		    to pull matching snippets from.
	    </apidoc:param>
	    <apidoc:param name="cts-query" type="schema-element(cts:query)">A
		    serialized and annotated <code>cts:query</code>, 
		    typically the result of a call to 
		    <a href="#search:parse"><code>search:parse</code></a>.
	    </apidoc:param>
	    <apidoc:param name="options" type="element(search:transform-results)?" 
		    optional="true">Options to define the search 
		    grammar and control the search. See description for 
		    <a href="#search:search#search-options"><code>$options</code></a> for 
		    the function <code>search:search</code>. Note that 
		    you cannot specify the <code>apply</code> attribute
		    on the <code>transform-results</code> option with
		    <code>search:snippet</code>; to use a different snippetting
		    function, use 
		    <a href="#search:search"><code>search:search</code></a> or 
		    <a href="#search:resolve"><code>search:resolve</code></a>
		    instead. 
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(search:snippet)</apidoc:return>
    <apidoc:see-also-list>
      <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/search-api.xml%2365347'>Built-In Snippetting</a> in the <em>Search Developer's Guide</em>
      </apidoc:see-also>
      <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/query-options.xml%2358295'>Modifying Your Snippet Results</a> in the <em>Search Developer's Guide</em>
      </apidoc:see-also>
    </apidoc:see-also-list>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:snippet(
 <html xmlns="http://www.w3.org/1999/xhtml">
     <head>
        <title>Page Title</title>
     </head>
     <body>
       <div>Query terms in this div will be ignored for snippeting.</div>
       <p>Text surrounding query terms is highlighted and truncated
               according to configuration.</p>
     </body>
     </html>,
      search:parse("term"),
      <transform-results apply="snippet"
      xmlns="http://marklogic.com/appservices/search">
          <per-match-tokens>30</per-match-tokens>
          <max-matches>4</max-matches>
          <max-snippet-chars>200</max-snippet-chars>
          <preferred-matches>
              <element name="p" ns="http://www.w3.org/1999/xhtml"/>
          </preferred-matches>
      </transform-results>)

=>

<search:snippet xmlns:search="http://marklogic.com/appservices/search">
  <search:match path="/*:html/*:body/*:p[1]">
      Text surrounding query
    <search:highlight>terms</search:highlight>
      is highlighted and truncated according to configuration.
  </search:match>
</search:snippet>
]]>
  </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="suggest" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>This function returns a sequence of suggested text 
		  strings that match a wildcarded search for the 
		  <code>$qtext</code> input, ready for use in a user 
		  interface.  Typically this is used for type-ahead 
		  applications to provide the user 
		  suggestions while entering terms in a search box.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="qtext" type="xs:string+">One or more strings 
		    of query text.  The first string in the list (or the
		    string corresponding to the position in the $focus 
		    parameter value) is used to find matching suggestions
		    by performing a lexicon match query.
		    The other strings (if any) are parsed as a 
		    <code>cts:query</code>, with the resulting queries 
		    combined with a <code>cts:and-query</code>, and the
		    resulting <code>cts:query</code> is passed as a 
		    constraining query to the lexicon match query, restricting 
		    the suggestions to fragments that match the 
		    <code>cts:query</code>.  Typically, each item in the
		    sequence corresponds to a single text entry box in a 
		    user interface.
	    </apidoc:param>
	    <apidoc:param name="options" type="element(search:options)?" 
		    optional="true">Options to define the search 
		    grammar and control the search. See description for 
		    <a href="#search:search#search-options"><code>$options</code></a>
		    for the function <code>search:search</code>.  In particular, 
		    the <code>default-suggestion-source</code> and 
		    <code>suggestion-source</code> options are specific to
		    <code>search:suggest</code>.
	    </apidoc:param>
	    <apidoc:param name="limit" type="xs:unsignedInt?" 
		    optional="true">The maximum number of
		    suggestions to return. The default is 10.
	    </apidoc:param>
	    <apidoc:param name="cursor-position" type="xs:unsignedInt?" 
		    optional="true">The position of the cursor, from point of 
		    origin, in the text box corresponding to the 
		    <code>$focus</code> parameter. This is used to determine 
		    on which part of the query text to perform a lexicon 
		    match.  The default is the string length of the 
		    <code>$focus</code> string (all of the string).
	    </apidoc:param>
	    <apidoc:param name="focus" type="xs:positiveInteger?" 
		    optional="true">If there are multiple
		    <code>$qtext</code> strings, the index of the string 
		    corresponding to the text box that has current 
		    "focus" in the user interface (and therefore containing 
		    a partial query text for completion). The
		    default is 1 (the first <code>$qtext</code> string.
	    </apidoc:param>
	    <apidoc:param name="query" type="element(search:query)*" optional="true">
          Zero or more structured queries with which to constrain the
          scope of the match for <code>qtext</code>. Default: No additional
          constraints on the suggestions.
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
	     <p>
		    On large databases, the performance of using a 
		    word lexicon for suggestions will probably be slower than
		    using a value lexicon.  This can be very application 
		    specific, and in some cases the performance might be good,
		    but in general, value lexicons (range constraints) will 
		    perform much better than word lexicons (word constraints)
		    with <code>search:suggest</code>. Therefore, MarkLogic 
		    recommends using value lexicons for suggestions, not word 
		    lexicons.  
	    </p>
	    <p>
		    The performance of <code>search:suggest</code> is highly
		    data-dependent.  The best performing suggestion sources 
		    are value lexicons (range indexes) that use the 
		    codepoint collation.  Performance is also impacted based on
		    the number of matches, and it can help to design the 
		    interaction between <code>search:suggest</code> and the UI
		    so that suggestions are given after a minimum of 3 
		    characters are entered (that is, the lexicon match calls 
		    will have at least 3 characters).  Again, this is quite 
		    data-dependent, so you should try it on a large data set
		    with your own data.
	    </p>
	    <p>
		    The output of <code>search:suggest</code> is a sequence of 
		    query text strings, not a sequence of words.  Each 
		    query text string can include quoted text, such as
		    phrases.  The output of  <code>search:suggest</code>
		    is appropriate to pass into the first argument of
		    <code>search:search</code>, including any quoted phrases. 
		    For example, if you have a suggestion that returns 
		    multi-word phrases
		    (for example, from range element index values), then
		    the suggestion will quote the phrase.
	    </p>
        <p>
          Use the <code>query</code> parameter to supply structured
          queries with which to constrain the returned results. Only
          suggestions that match these additional queries are returned.
          For more information about structured queries, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/structured-query.xml%2392329'>Searching Using Structured Queries</a> in the <em>Search Developer's Guide</em>.
        </p>
    </apidoc:usage>
        <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options := 
<search:options xmlns="http://marklogic.com/appservices/search">
 <default-suggestion-source>
   <range collation="http://marklogic.com/collation/" 
          type="xs:string" facet="true">
      <element ns="http://marklogic.com/xdmp/apidoc" 
               name="function"/>
      <attribute ns="" name="name"/>
   </range>
 </default-suggestion-source>
</search:options>
return
search:suggest("docu", $options)

=> a sequence of strings representing query text:

document-add-collections
document-add-permissions
document-add-properties
document-checkin
document-checkout
]]>
      </pre>
    </apidoc:example>

     <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options := 
<search:options xmlns="http://marklogic.com/appservices/search">
 <default-suggestion-source>
    <range collation="http://marklogic.com/collation/" 
          type="xs:string" facet="true">
      <element ns="" name="hello"/>
   </range>
 </default-suggestion-source>
</search:options>
return
search:suggest("a", $options)

=>  a sequence of strings representing query text:
"and that"
"and this"

]]>
      </pre>
    </apidoc:example>

    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:suggest(("ta","foo"),(),5)

=>  a sequence of strings representing query text:

tab
table
tadpole
tag

]]>
      </pre>
    </apidoc:example>

    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:suggest(("table","foo"),(),(),5,2)

=>  a sequence of strings representing query text:

food
fool
foolhardy
foolish
foolishness

]]>
      </pre>
    </apidoc:example>
        <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

(: 
given a document created with the following:

xdmp:document-insert("/test.xml",
<root>
  <my:my-element xmlns:my="my-namespace" shortname="fool"/>
  <my:my-element xmlns:my="my-namespace" shortname="food"/>
  <my:my-element xmlns:my="my-namespace" shortname="foolhardy"/>
  <my:my-element xmlns:my="my-namespace" shortname="foolish"/>
  <my:my-element xmlns:my="my-namespace" shortname="foolishness"/>
  <my:my-element xmlns:my="my-namespace" name="foody"/>
</root>)
:)
let $options := 
<options xmlns="http://marklogic.com/appservices/search">
 <constraint name="tag">
   <range collation="http://marklogic.com/collation/" 
          type="xs:string" facet="true">
      <element ns="my-namespace" 
               name="my-element"/>
      <attribute ns="" name="name"/>
   </range>
 </constraint>
 <suggestion-source ref="tag">
   <range collation="http://marklogic.com/collation/" 
          type="xs:string" facet="true">
      <element ns="my-namespace" 
               name="my-element"/>
      <attribute ns="" name="shortname"/>
   </range>
 </suggestion-source>
</options>
return	  
search:suggest("tag:foo", $options)

=>
suggestions to complete tag: from the range index on the 
"shortname" attribute (notice "foody" is not in the answer):

tag:food
tag:fool
tag:foolhardy
tag:foolish
tag:foolishness
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
  <apidoc:function name="unparse" lib="search" category="Search"
          bucket="XQuery Library Modules">
	  <apidoc:summary>NOTE: This function is deprecated. Turn a serialized,
        annotated <code>cts:query</code> (typically from 
		<code>search:parse</code>) back into query text according to 
        the specified rules.
	  </apidoc:summary>
    <apidoc:params>
	    <apidoc:param name="qtree" type="element()">A
		    serialized and annotated <code>cts:query</code>, 
		    typically the result of a call to 
		    <a href="#search:parse"><code>search:parse</code></a>.
	    </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string+</apidoc:return>
    <apidoc:usage>
      You can only use <code>search:unparse</code> on an annotated 
      <code>cts:query</code>. You can generate an annotated query by
      passing "cts:annotated-query" as the 3rd parameter of
      <code>search:parse</code>.
    </apidoc:usage>
    <apidoc:example>
      <pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:unparse(
    search:parse("tag:technology AND format:pdf",
      search:get-default-options(), "cts:annotated-query"))

=>

"tag:technology AND format:pdf"
]]>
      </pre>
    </apidoc:example>
  </apidoc:function>
<apidoc:function name="values" lib="search" category="Search" 
	  bucket="XQuery Library Modules">
  <apidoc:summary>This function returns lexicon values and co-occurrences,
    and allows you to calculate aggregates based on the lexicon values.
  </apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="spec-name" type="xs:string">
		  The name of a
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2380754'>values</a> in the <em>Search Developer's Guide</em> or
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2357759'>tuples</a> in the <em>Search Developer's Guide</em>
          specification in the supplied options node.
	  </apidoc:param>
	  <apidoc:param name="options" type="element(search:options)">
		  Options that define and control the query. The options must
		  include the $spec-name definitions supplied in the first parameter.
	      The following is a list of the options that affect lexicon queries; 
          the options node can contain other options, but they are not used.
          For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2338093'>Appendix: Query Options Reference</a> in the <em>Search Developer's Guide</em>.
  <p><ul>
    <li>
     <code>tuples</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2357759'>tuples</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>values</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2380754'>values</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>debug</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2368047'>debug</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>forest</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2397358'>forest</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>quality-weight</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2330469'>quality-weight</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-aggregates</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2372034'>return-aggregates</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-frequencies</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2320445'>return-frequencies</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-metrics</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2368566'>return-metrics</a> in the <em>Search Developer's Guide</em>
    </li><li>
     <code>return-values</code> - For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2369896'>return-values</a> in the <em>Search Developer's Guide</em>
    </li>
  </ul></p>    
	  </apidoc:param>
	  <apidoc:param name="query" type="element(search:query)?" 
		  optional="true"> 
		  A structured query to apply as a constraint when retrieving 
		  lexicon values.
	  </apidoc:param>
	  <apidoc:param name="limit" type="xs:unsignedLong?" 
		  optional="true">
		  The maximum number of values to return. The default is no 
		  limit.  
	  </apidoc:param>
	  <apidoc:param name="start" type="xs:anyAtomicType?"
		  optional="true">
		  A starting value in the lexicon.  If the <code>$start</code> is
          not present in the lexicon, the values
		  are returned starting with the next value in the range index
          after where <code>$start</code> would logically appear. If no
          <code>$start</code> value is supplied, values are returned
          beginning with the first value in the lexicon.
	  </apidoc:param>
      <apidoc:param name="page-start" type="xs:unsignedLong?" optional="true">
          The index of the first value to return from within the subset
          defined by <code>limit</code> and <code>start</code>. Default: 1.
      </apidoc:param>
      <apidoc:param name="page-length" type="xs:unsignedLong?" optional="true">
          The number of values to return within the subset of values
          defined by <code>limit</code> and <code>start</code>. Default:
          Return all values.
      </apidoc:param>
  </apidoc:params>
  <apidoc:return>element(search:values-response)</apidoc:return>
  <apidoc:usage>
    For details and more examples, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/search-api.xml%2360118'>Returning Lexicon Values With search:values</a> in the <em>Search Developer's Guide</em>.
  </apidoc:usage>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options := 
<options xmlns="http://marklogic.com/appservices/search">
  <values name="uri">
    <uri/>
    <aggregate apply="min"/>
  </values>
</options>
return
search:values("uri", $options)
=>
<values-response name="uri" type="xs:string" 
  xmlns="http://marklogic.com/appservices/search" 
  xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <distinct-value frequency="2">/date.xml</distinct-value>
  <distinct-value frequency="2">/gajanan.xml</distinct-value>
  <distinct-value frequency="2">/test/keys.json</distinct-value>
  <aggregate-result name="min">/date.xml</aggregate-result>
  <metrics>
    <values-resolution-time>PT0.000193S</values-resolution-time>
    <aggregate-resolution-time>PT0.000409S</aggregate-resolution-time>
    <total-time>PT0.001987S</total-time>
  </metrics>
</values-response>
    ]]></pre>
  </apidoc:example>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

(: 
   Requires URI lexicon and string range index on "hello". 
   This finds the values for "hello" for all documents that 
   have the element "hello".
:)
let $options := 
<options xmlns="http://marklogic.com/appservices/search">
  <tuples name="hello">
    <uri/>
    <range type="xs:string" collation="http://marklogic.com/collation/">
      <element ns="" name="hello"/>
    </range>
  </tuples>
</options>
let $values:= search:values("hello", $options)
return (
$values, 
fn:doc($values/search:tuple/search:distinct-value/fn:data()) )
=>
<values-response name="hello" 
  xmlns="http://marklogic.com/appservices/search" 
  xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <tuple frequency="1">
    <distinct-value xsi:type="xs:string" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      >/date.xml</distinct-value>
    <distinct-value xsi:type="xs:string" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      >2012-08-10-05:00</distinct-value>
  </tuple>
  <tuple frequency="1">
    <distinct-value xsi:type="xs:string" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      >/gajanan.xml</distinct-value>
    <distinct-value xsi:type="xs:string" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      >fooooooooo</distinct-value>
  </tuple>
  <metrics>
    <values-resolution-time>PT0.0006S</values-resolution-time>
    <aggregate-resolution-time>PT0.000014S</aggregate-resolution-time>
    <total-time>PT0.002337S</total-time>
  </metrics>
</values-response>
<?xml version="1.0" encoding="UTF-8"?>
<hello>2012-08-10-05:00</hello>
<?xml version="1.0" encoding="UTF-8"?>
<foo>bar</foo>
    ]]></pre>
  </apidoc:example>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options := 
<options xmlns="http://marklogic.com/appservices/search">
  <values name="animals">
    <range type="xs:string">
      <field name="animal-name" collation="http://marklogic.com/collation/" />
    </range>
  </values>
</options>
return
search:values("animals", $options, 
  search:parse("mammal OR marsupial", (), "search:query"), 
  10, "camel", 5, 3)

==> Assuming the value subset defined by the query (mammal OR marsupial),
    limit (10), and start ("buffalo") contains the values (camel, fox,
    hare, jaguar, kangaroo, lemur, moose, ocelot, panda, rhino), then
    adding a page-start of 5 and a page-length of 3, you get the following:

<values-response name="animals" type="xs:string" xmlns="http://marklogic.com/appservices/search" xmlns:xs="http://www.w3.org/2001/XMLSchema">
<distinct-value frequency="1">kangaroo</distinct-value>
<distinct-value frequency="1">lemur</distinct-value>
<distinct-value frequency="1">moose</distinct-value>
<metrics>
<values-resolution-time>PT0.000242S</values-resolution-time>
<total-time>PT0.00134S</total-time>
</metrics>
</values-response>
  ]]></pre></apidoc:example>
</apidoc:function>
  
</apidoc:module>
