<apidoc:module name="OpticModule" category="Optic" lib="op" 
 bucket="XQuery Library Modules" link="none" 
  xmlns:apidoc="http://marklogic.com/xdmp/apidoc" xmlns="http://www.w3.org/1999/xhtml">

  <apidoc:summary category="Optic" 
     bucket="XQuery Library Modules">
     <p>The optic library module is a fluent API that builds up a plan definition
	     for retrieving and processing rows.  The <code>result</code> method executes the plan.
     </p><p>
	     The plan operations fall into the following broad categories:
           </p>
           <ul>
	      <li>data access -- a plan can read a row set from a view, graph, lexicons, or literals.</li>

	      <li>row set modification -- a plan can filter rows with the <code>where</code> method, 
          sort rows with
	      <code>orderBy</code>, group rows with <code>groupBy</code>, project rows with 
          <code>select</code>, or page over rows with <code>limit</code>.</li>

	      <li>row set composition -- a plan can combine multiple row sets with the joinInner(),
	     <code>joinLeftOuter</code>, <code>union</code>, <code>intersect</code>,
          or <code>except</code> methods to yield a single row set.</li>

          <li>row result processing -- a plan perform document joins and apply map or reduce
          functions to the final row set.</li>
            </ul>
  <span class="xquery">
      <p> To use the optic.xqy module in your own XQuery modules, include the 
	      following line in your XQuery prolog:</p>
      <p><code>import module namespace op = "http://marklogic.com/xdmp/optic" 
		  at "/MarkLogic/optic.xqy";</code></p>
      <p>The library uses the <code>op:</code> namespace, which is 
	      not predefined in the server.</p>
  </span>
  <span class="javascript">
            <p>To use this module in your Server-Side JavaScript code, include a
                   <code>require</code> statement similar to following line in your code:
            </p><pre xml:space="preserve">
                   var op = require("/MarkLogic/optic");
               </pre>
	<p>The optic JavaScript module is installed as the following file:</p>
    <ul>
      <li><code><em>install_dir</em>/Modules/MarkLogic/optic.sjs</code></li>
    </ul>
    <p>where <code><em>install_dir</em></code> is the directory in which 
       MarkLogic Server is installed.</p>
  </span>
  </apidoc:summary>
 
 
 <apidoc:summary category="Optic" subcategory="AccessPlan Object"
     bucket="XQuery Library Modules">
    <p>
     The following prototype methods access data persisted in the row triple, 
     triple, and lexicon indexes as well as literal row sets constructed in the program.
     These prototype methods can be used in conjuction with the 
     <a href="/js/op/data-access-functions">Data Access Functions</a>.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Data Access Functions"
     bucket="XQuery Library Modules">
    <p>
     The following functions are used to access data persisted in the row triple, 
     triple, and lexicon indexes as well as literal row sets constructed in the program.
    </p>
 <p>For more information, see <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2366011'>Data Access Functions</a> in the <em>Application Developer's Guide</em></p>

  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Column and Parameter Functions"
     bucket="XQuery Library Modules">
    <p>
     The following functions are used in conjunction with the 
     <a href="/js/AccessPlan">AccessPlan Object</a> prototype methods
     to access data persisted in the row triple, triple, and lexicon indexes 
     as well as literal row sets constructed in the program.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="ModifyPlan Object"
     bucket="XQuery Library Modules">
    <p>
     The following prototype methods convert a row set into a different row set 
     (typically with fewer rows or columns).
     These prototype methods can be used in conjuction with the 
     <a href="/js/op/modifier-functions">Modifier Functions</a> and
     <a href="/js/op/composer-functions">Composer Functions</a>.
    </p>
  </apidoc:summary>


  <apidoc:summary category="Optic" subcategory="Function for Parsing an Exported Plan"
     bucket="XQuery Library Modules">
    <p>
     The following function is used to parse a plan exported by the
     <a href="/IteratePlan.prototype.export">prototype.export</a> method.
     It returns a plan of the class returned by the last imported method.
    </p>
  </apidoc:summary>


  <apidoc:summary category="Optic" subcategory="Functions for Building fromTriples Parameters"
     bucket="XQuery Library Modules">
    <p>
     The following functions are used to build parameters used by the 
     <a href="/op.fromTriples">op.fromTriples</a> function.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Functions for Building orderBy Parameters"
     bucket="XQuery Library Modules">
    <p>
     The following functions are used to build parameters used by the 
     <a href="/ModifyPlan.prototype.orderBy">prototype.orderBy</a> method.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Function for Building Join Parameters"
     bucket="XQuery Library Modules">
    <p>
     The following function is used to build parameters used by the 
     <a href="/ModifyPlan.prototype.joinInner">prototype.joinInner</a> and
     <a href="/ModifyPlan.prototype.joinLeftOuter">prototype.joinLeftOuter</a> methods.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters"
     bucket="XQuery Library Modules">
    <p>
     The following functions are aggregate functions for building parameters used by the 
     <a href="/ModifyPlan.prototype.groupBy">prototype.groupBy</a> method.
    </p>
  </apidoc:summary>



  <apidoc:summary category="Optic" subcategory="Node Constructor Functions"
     bucket="XQuery Library Modules">
    <p>
      The following are constructor functions to construct nodes that 
      can be used as column values in a row or passed to builtin functions. 
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="PreparePlan Object"
     bucket="XQuery Library Modules">
    <p>
     The following prototype methods are not operators for constructing the plan but, 
     instead, process the plan in some way.
     These prototype methods can be used in conjuction with the 
     <a href="/js/op/plan-processor-functions">Plan Processor Functions</a>.
    </p>
  </apidoc:summary>

 

  <apidoc:summary category="Optic" subcategory="IteratePlan Object"
     bucket="XQuery Library Modules">
    <p>
     The following prototype methods are used to execute the plan or export it for
     use by the <a href="/op.import">op.import</a> function.
    </p>
  </apidoc:summary>



  <apidoc:summary category="Optic" subcategory="Boolean Expression Functions"
     bucket="XQuery Library Modules">
    <p>
      The following functions are used to build boolean expressions.
    </p>
  </apidoc:summary>

  <apidoc:summary category="Optic" subcategory="Arithmetic Expression Functions"
     bucket="XQuery Library Modules">
    <p>
      The following functions are used to build arithmetic expressions.
    </p>
  </apidoc:summary>

 

  <apidoc:summary category="Optic" subcategory="Value Processing Functions"
     bucket="XQuery Library Modules">
    <p>
      The following functions are used to support builtin functions within a plan.  These
      include datatype constructors, datetime, duration, numeric, sequence, and string functions.
      Builtins that read documents or indexes, such as <a href="/fn.doc">fn.doc</a>, and that 
      change the server state in any way are deliberately excluded from this list for performance 
     reasons.
    </p><p>
      Each function namespace is a separate property on the object returned by requiring the 
      plan library. 
      For example, the <code>fn</code> property has an object with a lowerCase property for the 
      lowerCase function.
    </p>
   <ul>
     <li><a href="/cts.tokenize">cts.tokenize</a></li>
     <li><a href="/cts.stem">cts.stem</a></li>
     <li><a href="/fn.abs">fn.abs</a></li>
     <li><a href="/fn.adjustDateTimeToTimezone">fn.adjustDateTimeToTimezone</a></li>
     <li><a href="/fn.adjustDateToTimezone">fn.adjustDateToTimezone</a></li>
     <li><a href="/fn.adjustTimeToTimezone">fn.adjustTimeToTimezone</a></li>
     <li><a href="/fn.analyzeString">fn.analyzeString</a></li>
     <li><a href="/fn.boolean">fn.boolean</a></li>
     <li><a href="/fn.ceiling">fn.ceiling</a></li>
     <li><a href="/fn.codepointEqual">fn.codepointEqual</a></li>
     <li><a href="/fn.codepointsToString">fn.codepointsToString</a></li>
     <li><a href="/fn.compare">fn.compare</a></li>
     <li><a href="/fn.concat">fn.concat</a></li>
     <li><a href="/fn.currentDateTime">fn.currentDateTime</a></li>
     <li><a href="/fn.currentDate">fn.currentDate</a></li>
     <li><a href="/fn.currentTime">fn.currentTime</a></li>
     <li><a href="/fn.contains">fn.contains</a></li>
     <li><a href="/fn.dateTime">fn.dateTime</a></li>
     <li><a href="/fn.dayFromDate">fn.dayFromDate</a></li>
     <li><a href="/fn.dayFromDateTime">fn.dayFromDateTime</a></li>
     <li><a href="/fn.daysFromDuration">fn.daysFromDuration</a></li>
     <li><a href="/fn.distinctValues">fn.distinctValues</a></li>
     <li><a href="/fn.empty">fn.empty</a></li>
     <li><a href="/fn.encodeForUri">fn.encodeForUri</a></li>
     <li><a href="/fn.endsWith">fn.endsWith</a></li>
     <li><a href="/fn.escapeHtmlUri">fn.escapeHtmlUri</a></li>
     <li><a href="/fn.exists">fn.exists</a></li>
     <li><a href="/fn.false">fn.false</a></li>
     <li><a href="/fn.floor">fn.floor</a></li>
     <li><a href="/fn.formatDate">fn.formatDate</a></li>
     <li><a href="/fn.formatDateTime">fn.formatDateTime</a></li>
     <li><a href="/fn.formatNumber">fn.formatNumber</a></li>
     <li><a href="/fn.formatTime">fn.formatTime</a></li>
     <li><a href="/fn.head">fn.head</a></li>
     <li><a href="/fn.hoursFromDateTime">fn.hoursFromDateTime</a></li>
     <li><a href="/fn.hoursFromDuration">fn.hoursFromDuration</a></li>
     <li><a href="/fn.hoursFromTime">fn.hoursFromTime</a></li>
     <li><a href="/fn.indexOf">fn.indexOf</a></li>
     <li><a href="/fn.insertBefore">fn.insertBefore</a></li>
     <li><a href="/fn.iriToUri">fn.iriToUri</a></li>
     <li><a href="/fn.localNameFromQName">fn.localNameFromQName</a></li>
     <li><a href="/fn.lowerCase">fn.lowerCase</a></li>
     <li><a href="/fn.matches">fn.matches</a></li>
     <li><a href="/fn.max">fn.max</a></li>
     <li><a href="/fn.min">fn.min</a></li>
     <li><a href="/fn.minutesFromDateTime">fn.minutesFromDateTime</a></li>
     <li><a href="/fn.minutesFromDuration">fn.minutesFromDuration</a></li>
     <li><a href="/fn.minutesFromTime">fn.minutesFromTime</a></li>
     <li><a href="/fn.monthFromDate">fn.monthFromDate</a></li>
     <li><a href="/fn.monthFromDateTime">fn.monthFromDateTime</a></li>
     <li><a href="/fn.monthsFromDuration">fn.monthsFromDuration</a></li>
     <li><a href="/fn.namespaceUriFromQName">fn.namespaceUriFromQName</a></li>
     <li><a href="/fn.normalizeSpace">fn.normalizeSpace</a></li>
     <li><a href="/fn.normalizeUnicode">fn.normalizeUnicode</a></li>
     <li><a href="/fn.not">fn.not</a></li>
     <li><a href="/fn.number">fn.number</a></li>
     <li><a href="/fn.prefixFromQName">fn.prefixFromQName</a></li>
     <li><a href="/fn.QName">fn.QName</a></li>
     <li><a href="/fn.remove">fn.remove</a></li>
     <li><a href="/fn.replace">fn.replace</a></li>
     <li><a href="/fn.resolveUri">fn.resolveUri</a></li>
     <li><a href="/fn.reverse">fn.reverse</a></li>
     <li><a href="/fn.round">fn.round</a></li>
     <li><a href="/fn.roundHalfToEven">fn.roundHalfToEven</a></li>
     <li><a href="/fn.secondsFromDateTime">fn.secondsFromDateTime</a></li>
     <li><a href="/fn.secondsFromDuration">fn.secondsFromDuration</a></li>
     <li><a href="/fn.secondsFromTime">fn.secondsFromTime</a></li>
     <li><a href="/fn.startsWith">fn.startsWith</a></li>
     <li><a href="/fn.string">fn.string</a></li>
     <li><a href="/fn.stringJoin">fn.stringJoin</a></li>
     <li><a href="/fn.stringLength">fn.stringLength</a></li>
     <li><a href="/fn.stringToCodepoints">fn.stringToCodepoints</a></li>
     <li><a href="/fn.subsequence">fn.subsequence</a></li>
     <li><a href="/fn.substring">fn.substring</a></li>
     <li><a href="/fn.substringAfter">fn.substringAfter</a></li>
     <li><a href="/fn.substringBefore">fn.substringBefore</a></li>
     <li><a href="/fn.tail">fn.tail</a></li>
     <li><a href="/fn.timezoneFromDate">fn.timezoneFromDate</a></li>
     <li><a href="/fn.timezoneFromDateTime">fn.timezoneFromDateTime</a></li>
     <li><a href="/fn.timezoneFromTime">fn.timezoneFromTime</a></li>
     <li><a href="/fn.tokenize">fn.tokenize</a></li>
     <li><a href="/fn.translate">fn.translate</a></li>
     <li><a href="/fn.true">fn.true</a></li>
     <li><a href="/fn.unordered">fn.unordered</a></li>
     <li><a href="/fn.upperCase">fn.upperCase</a></li>
     <li><a href="/fn.yearFromDate">fn.yearFromDate</a></li>
     <li><a href="/fn.yearFromDateTime">fn.yearFromDateTime</a></li>
     <li><a href="/fn.yearsFromDuration">fn.yearsFromDuration</a></li>
     <li><a href="/json.arrayPop">json.arrayPop</a></li>
     <li><a href="/json.arrayPush">json.arrayPush</a></li>
     <li><a href="/json.arraySize">json.arraySize</a></li>
     <li><a href="/json.arrayValues">json.arrayValues</a></li>
     <li><a href="/json.objectDefine">json.objectDefine</a></li>
     <li><a href="/json.setItemAt">json.setItemAt</a></li>
     <li><a href="/json.subarray">json.subarray</a></li>
     <li><a href="/json.toArray">json.toArray</a></li>
     <li><a href="/map.contains">map.contains</a></li>
     <li><a href="/map.count">map.count</a></li>
     <li><a href="/map.delete">map.delete</a></li>
     <li><a href="/map.entry">map.entry</a></li>
     <li><a href="/map.get">map.get</a></li>
     <li><a href="/map.keys">map.keys</a></li>
     <li><a href="/map.new">map.new</a></li>
     <li><a href="/map.put">map.put</a></li>
     <li><a href="/math.acos">math.acos</a></li>
     <li><a href="/math.asin">math.asin</a></li>
     <li><a href="/math.atan">math.atan</a></li>
     <li><a href="/math.atan2">math.atan2</a></li>
     <li><a href="/math.ceil">math.ceil</a></li>
     <li><a href="/math.correlation">math.correlation</a></li>
     <li><a href="/math.cos">math.cos</a></li>
     <li><a href="/math.cosh">math.cosh</a></li>
     <li><a href="/math.cot">math.cot</a></li>
     <li><a href="/math.covariance">math.covariance</a></li>
     <li><a href="/math.covarianceP">math.covarianceP</a></li>
     <li><a href="/math.degrees">math.degrees</a></li>
     <li><a href="/math.exp">math.exp</a></li>
     <li><a href="/math.fabs">math.fabs</a></li>
     <li><a href="/math.floor">math.floor</a></li>
     <li><a href="/math.fmod">math.fmod</a></li>
     <li><a href="/math.frexp">math.frexp</a></li>
     <li><a href="/math.ldexp">math.ldexp</a></li>
     <li><a href="/math.linearModel">math.linearModel</a></li>
     <li><a href="/math.linearModelCoeff">math.linearModelCoeff</a></li>
     <li><a href="/math.linearModelIntercept">math.linearModelIntercept</a></li>
     <li><a href="/math.linearModelRsquared">math.linearModelRsquared</a></li>
     <li><a href="/math.log">math.log</a></li>
     <li><a href="/math.log10">math.log10</a></li>
     <li><a href="/math.median">math.median</a></li>
     <li><a href="/math.mode">math.mode</a></li>
     <li><a href="/math.modf">math.modf</a></li>
     <li><a href="/math.percentile">math.percentile</a></li>
     <li><a href="/math.percentRank">math.percentRank</a></li>
     <li><a href="/math.pi">math.pi</a></li>
     <li><a href="/math.pow">math.pow</a></li>
     <li><a href="/math.radians">math.radians</a></li>
     <li><a href="/math.rank">math.rank</a></li>
     <li><a href="/math.sin">math.sin</a></li>
     <li><a href="/math.sinh">math.sinh</a></li>
     <li><a href="/math.sqrt">math.sqrt</a></li>
     <li><a href="/math.stddev">math.stddev</a></li>
     <li><a href="/math.stddevP">math.stddevP</a></li>
     <li><a href="/math.tan">math.tan</a></li>
     <li><a href="/math.tanh">math.tanh</a></li>
     <li><a href="/math.trunc">math.trunc</a></li>
     <li><a href="/math.variance">math.variance</a></li>
     <li><a href="/math.varianceP">math.varianceP</a></li>
     <li><a href="/rdf.langString">rdf.langString</a></li>
     <li><a href="/rdf.langStringLanguage">rdf.langStringLanguage</a></li>
     <li><a href="/sem.bnode">sem.bnode</a></li>
     <li><a href="/sem.coalesce">sem.coalesce</a></li>
     <li><a href="/sem.datatype">sem.datatype</a></li>
     <li><a href="/sem.defaultGraphIri">sem.defaultGraphIri</a></li>
     <li><a href="/sem.if">sem.if</a></li>
     <li><a href="/sem.invalid">sem.invalid</a></li>
     <li><a href="/sem.invalidDatatype">sem.invalidDatatype</a></li>
     <li><a href="/sem.iri">sem.iri</a></li>
     <li><a href="/sem.iriToQName">sem.iriToQName</a></li>
     <li><a href="/sem.isBlank">sem.isBlank</a></li>
     <li><a href="/sem.isIRI">sem.isIRI</a></li>
     <li><a href="/sem.isLiteral">sem.isLiteral</a></li>
     <li><a href="/sem.isNumeric">sem.isNumeric</a></li>
     <li><a href="/sem.lang">sem.lang</a></li>
     <li><a href="/sem.langMatches">sem.langMatches</a></li>
     <li><a href="/sem.QNameToIri">sem.QNameToIri</a></li>
     <li><a href="/sem.random">sem.random</a></li>
     <li><a href="/sem.sameTerm">sem.sameTerm</a></li>
     <li><a href="/sem.timezoneString">sem.timezoneString</a></li>
     <li><a href="/sem.typedLiteral">sem.typedLiteral</a></li>
     <li><a href="/sem.unknown">sem.unknown</a></li>
     <li><a href="/sem.unknownDatatype">sem.unknownDatatype</a></li>
     <li><a href="/sem.uuid">sem.uuid</a></li>
     <li><a href="/sem.uuidString">sem.uuidString</a></li>
     <li><a href="/sql.bitLength">sql.bitLength</a></li>
     <li><a href="/sql.dateadd">sql.dateadd</a></li>
     <li><a href="/sql.datediff">sql.datediff</a></li>
     <li><a href="/sql.datepart">sql.datepart</a></li>
     <li><a href="/sql.day">sql.day</a></li>
     <li><a href="/sql.dayname">sql.dayname</a></li>
     <li><a href="/sql.hours">sql.hours</a></li>
     <li><a href="/sql.insert">sql.insert</a></li>
     <li><a href="/sql.left">sql.left</a></li>
     <li><a href="/sql.minutes">sql.minutes</a></li>
     <li><a href="/sql.month">sql.month</a></li>
     <li><a href="/sql.monthname">sql.monthname</a></li>
     <li><a href="/sql.octetLength">sql.octetLength</a></li>
     <li><a href="/sql.quarter">sql.quarter</a></li>
     <li><a href="/sql.rand">sql.rand</a></li>
     <li><a href="/sql.repeat">sql.repeat</a></li>
     <li><a href="/sql.right">sql.right</a></li>
     <li><a href="/sql.seconds">sql.seconds</a></li>
     <li><a href="/sql.sign">sql.sign</a></li>
     <li><a href="/sql.space">sql.space</a></li>
     <li><a href="/sql.timestampadd">sql.timestampadd</a></li>
     <li><a href="/sql.timestampdiff">sql.timestampdiff</a></li>
     <li><a href="/sql.week">sql.week</a></li>
     <li><a href="/sql.weekday">sql.weekday</a></li>
     <li><a href="/sql.year">sql.year</a></li>
     <li><a href="/sql.yearday">sql.yearday</a></li>
     <li><a href="/xdmp.add64">xdmp.add64</a></li>
     <li><a href="/xdmp.and64">xdmp.and64</a></li>
     <li><a href="/xdmp.base64Decode">xdmp.base64Decode</a></li>
     <li><a href="/xdmp.base64Encode">xdmp.base64Encode</a></li>
     <li><a href="/xdmp.castableAs">xdmp.castableAs</a></li>
     <li><a href="/xdmp.crypt">xdmp.crypt</a></li>
     <li><a href="/xdmp.crypt2">xdmp.crypt2</a></li>
     <li><a href="/xdmp.daynameFromDate">xdmp.daynameFromDate</a></li>
     <li><a href="/xdmp.decodeFromNCName">xdmp.decodeFromNCName</a></li>
     <li><a href="/xdmp.describe">xdmp.describe</a></li>
     <li><a href="/xdmp.diacriticLess">xdmp.diacriticLess</a></li>
     <li><a href="/xdmp.encodeForNCName">xdmp.encodeForNCName</a></li>
     <li><a href="/xdmp.formatNumber">xdmp.formatNumber</a></li>
     <li><a href="/xdmp.getCurrentUser">xdmp.getCurrentUser</a></li>
     <li><a href="/xdmp.hash32">xdmp.hash32</a></li>
     <li><a href="/xdmp.hash64">xdmp.hash64</a></li>
     <li><a href="/xdmp.hexToInteger">xdmp.hexToInteger</a></li>
     <li><a href="/xdmp.hmacMd5">xdmp.hmacMd5</a></li>
     <li><a href="/xdmp.hmacSha1">xdmp.hmacSha1</a></li>
     <li><a href="/xdmp.hmacSha256">xdmp.hmacSha256</a></li>
     <li><a href="/xdmp.hmacSha512">xdmp.hmacSha512</a></li>
     <li><a href="/xdmp.initcap">xdmp.initcap</a></li>
     <li><a href="/xdmp.integerToHex">xdmp.integerToHex</a></li>
     <li><a href="/xdmp.integerToOctal">xdmp.integerToOctal</a></li>
     <li><a href="/xdmp.keyFromQName">xdmp.keyFromQName</a></li>
     <li><a href="/xdmp.lshift64">xdmp.lshift64</a></li>
     <li><a href="/xdmp.md5">xdmp.md5</a></li>
     <li><a href="/xdmp.monthNameFromDate">xdmp.monthNameFromDate</a></li>
     <li><a href="/xdmp.mul64">xdmp.mul64</a></li>
     <li><a href="/xdmp.not64">xdmp.not64</a></li>
     <li><a href="/xdmp.octalToInteger">xdmp.octalToInteger</a></li>
     <li><a href="/xdmp.or64">xdmp.or64</a></li>
     <li><a href="/xdmp.parseDateTime">xdmp.parseDateTime</a></li>
     <li><a href="/xdmp.parseYymmdd">xdmp.parseYymmdd</a></li>
     <li><a href="/xdmp.position">xdmp.position</a></li>
     <li><a href="/xdmp.QNameFromKey">xdmp.QNameFromKey</a></li>
     <li><a href="/xdmp.quarterFromDate">xdmp.quarterFromDate</a></li>
     <li><a href="/xdmp.random">xdmp.random</a></li>
     <li><a href="/xdmp.resolveUri">xdmp.resolveUri</a></li>
     <li><a href="/xdmp.rshift64">xdmp.rshift64</a></li>
     <li><a href="/xdmp.sha1">xdmp.sha1</a></li>
     <li><a href="/xdmp.sha256">xdmp.sha256</a></li>
     <li><a href="/xdmp.sha384">xdmp.sha384</a></li>
     <li><a href="/xdmp.sha512">xdmp.sha512</a></li>
     <li><a href="/xdmp.step64">xdmp.step64</a></li>
     <li><a href="/xdmp.strftime">xdmp.strftime</a></li>
     <li><a href="/xdmp.timestampToWallclock">xdmp.timestampToWallclock</a></li>
     <li><a href="/xdmp.type">xdmp.type</a></li>
     <li><a href="/xdmp.urlDecode">xdmp.urlDecode</a></li>
     <li><a href="/xdmp.urlEncode">xdmp.urlEncode</a></li>
     <li><a href="/xdmp.wallclockToTimestamp">xdmp.wallclockToTimestamp</a></li>
     <li><a href="/xdmp.weekdayFromDate">xdmp.weekdayFromDate</a></li>
     <li><a href="/xdmp.weekFromDate">xdmp.weekFromDate</a></li>
     <li><a href="/xdmp.xor64">xdmp.xor64</a></li>
     <li><a href="/xdmp.yeardayFromDate">xdmp.yeardayFromDate</a></li>
     <li><a href="/xs.anyURI">xs.anyURI</a></li>
     <li><a href="/xs.boolean">xs.boolean</a></li>
     <li><a href="/xs.byte">xs.byte</a></li>
     <li><a href="/xs.date">xs.byte</a></li>
     <li><a href="/xs.dateTime">xs.dateTime</a></li>
     <li><a href="/xs.dayTimeDuration">xs.dayTimeDuration</a></li>
     <li><a href="/xs.decimal">xs.decimal</a></li>
     <li><a href="/xs.double">xs.double</a></li>
     <li><a href="/xs.duration">xs.duration</a></li>
     <li><a href="/xs.float">xs.float</a></li>
     <li><a href="/xs.gDay">xs.gDay</a></li>
     <li><a href="/xs.gMonth">xs.gMonth</a></li>
     <li><a href="/xs.gMonthDay">xs.gMonthDay</a></li>
     <li><a href="/xs.gYear">xs.gYear</a></li>
     <li><a href="/xs.gYearMonth">xs.gYearMonth</a></li>
     <li><a href="/xs.hexBinary">xs.hexBinary</a></li>
     <li><a href="/xs.int">xs.int</a></li>
     <li><a href="/xs.integer">xs.integer</a></li>
     <li><a href="/xs.language">xs.language</a></li>
     <li><a href="/xs.long">xs.long</a></li>
     <li><a href="/xs.Name">xs.Name</a></li>
     <li><a href="/xs.NCName">xs.NCName</a></li>
     <li><a href="/xs.NMTOKEN">xs.NMTOKEN</a></li>
     <li><a href="/xs.negativeInteger">xs.negativeInteger</a></li>
     <li><a href="/xs.nonNegativeInteger">xs.nonNegativeInteger</a></li>
     <li><a href="/xs.nonPositiveInteger">xs.nonPositiveInteger</a></li>
     <li><a href="/xs.normalizedString">xs.normalizedString</a></li>
     <li><a href="/xs.positiveInteger">xs.positiveInteger</a></li>
     <li><a href="/xs.QName">xs.QName</a></li>
     <li><a href="/xs.short">xs.short</a></li>
     <li><a href="/xs.string">xs.string</a></li>
     <li><a href="/xs.time">xs.time</a></li>
     <li><a href="/xs.token">xs.token</a></li>
     <li><a href="/xs.unsignedByte">xs.unsignedByte</a></li>
     <li><a href="/xs.unsignedInt">xs.unsignedInt</a></li>
     <li><a href="/xs.unsignedLong">xs.unsignedLong</a></li>
     <li><a href="/xs.unsignedShort">xs.unsignedShort</a></li>
     <li><a href="/xs.yearMonthDuration">xs.yearMonthDuration</a></li>
   </ul>   
  </apidoc:summary>
 
 <apidoc:method name="call" object="op" 
	  bucket="XQuery Library Modules" category="Optic" subcategory="Value Processing Functions">
   <apidoc:summary>
     <p> 
   This function calls value processing built-in functions that aren't listed in the list
   <a href="/js/op/value-processing-functions">Value Processing Functions</a>, the API 
   also provides a general-purpose constructor for deferred calls.
   </p>
   <p>
   Use this function with care because some builtins could adversely affect performance or 
   worse. The following restrictions apply to the use of the <code>op.call</code> function:
   <ul>
     <li>Call only MarkLogic built-in functions.  You cannot call SJS or XQY functions using 
         this function. Instead, use a map or reduce function to postprocess the results.</li>
     <li>Do not call update functions, such as 
     <a class="javascript" href="#xdmp.documentInsert">xdmp.documentInsert</a>
     <a class="xquery" href="#xdmp:documentInsert">xdmp:documentInsert</a></li> 
     <li>Do not call side effect functions, such as 
     <a class="javascript" href="#xdmp.forestClear">xdmp.forestClear</a>
     <a class="xquery" href="#xdmp:forestClear">xdmp:forestClear</a>
     </li>
   </ul>
   </p>   
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="moduleUri" type="String"> 
         The URI of the function module.
       </apidoc:param>
       <apidoc:param class="javascript" name="functionName" type="String"> 
         The function name.
       </apidoc:param>
       <apidoc:param class="javascript" name="args" type="String" optional="true"> 
         The function arguments.
       </apidoc:param>
   </apidoc:params>

    <apidoc:return class="xquery">map:map</apidoc:return>
    <apidoc:return class="javascript">expression</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Returns the host name and MarkLogic version.

const op = require('/MarkLogic/optic');

op.fromLiterals([{row:1}])
  .select([
      op.as('hostName', op.call('http://marklogic.com/xdmp', 'host-name')),
      op.as('version',  op.call('http://marklogic.com/xdmp', 'version'))
      ])
  .result();

  ]]></pre></apidoc:example>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Concatenates 'EmployeeID' with '_x'.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
 
 employees.select(['EmployeeID',  
      op.as('concatenated',  
             op.call('http://www.w3.org/2005/xpath-functions', 'concat',  
                     [op.col("EmployeeID"), "_x"]))
                  ])                                        
	        .result();

  ]]></pre></apidoc:example> 

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
	   => op:select(("EmployeeID",  
                op:as("callcheck", 
                      op:call("http://www.w3.org/2005/xpath-functions", 
                              "concat", 
                              json:to-array((op:col("EmployeeID"), "_x"))
	              ))))
	   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="call" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.call">
  </apidoc:function>



 <apidoc:method name="fromView" object="op" 
	  bucket="XQuery Library Modules" category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>
   <p>
   This function reads a row set from a configured view over TDE-indexed rows or
   a predefined view over range indexes.
     <p>
     This function creates a row set without a limit.  Use 
     <a class="javascript" href="#AccessPlan.prototype.limit">AccessPlan.prototype.limit</a> 
     <a class="xquery" href="#op:limit">op:limit</a> or
     <a class="javascript" href="#AccessPlan.prototype.offsetLimit">AccessPlan.prototype.offsetLimit</a> 
     <a class="xquery" href="#op:offset-limit">op:offset-limit</a> 
     to set a limit.
     </p>
   </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="schema" type="String"> 
        The name identifying the schema containing the view.  If the schema name is null, the engine
        searches for a view with the specified name.
       </apidoc:param>
       <apidoc:param class="xquery" name="schema" type="xs:string?">
       The name identifying the schema containing the view.  If the schema name is null, the engine
        searches for a view with the specified name.
       </apidoc:param>
       <apidoc:param class="javascript" name="view" type="String">
        The name identifying a configured template or range view for rows projected from documents.
       </apidoc:param>
       <apidoc:param class="xquery" name="view" type="xs:string">
        The name identifying a configured template or range view for rows projected from documents.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true">
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param> 
       <apidoc:param class="javascript" name="systemCols" type="String" optional="true">
        An optional named fragment id column returned by
        <a href="#op.fragmentIdCol">op.fragmentIdCol</a>. 
        One use case for fragment ids is in joins with lexicons or document content. 
       </apidoc:param>
       <apidoc:param class="xquery" name="systemCols" type="map:map?" optional="true">
        An optional named fragment id column returned by
        <a href="#op:fragment-id-col">op:fragment-id-col</a>. 
        One use case for fragment ids is in joins with lexicons or document content.  
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">AccessPlan</apidoc:return>
    <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
    The <code>fromView</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.

   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
op.fromView('main', 'employees')
   .select(['EmployeeID', 'FirstName', 'LastName'])
   .orderBy('EmployeeID')
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
op.fromView('main', 'employees', null, op.fragmentIdCol('docId'))
  .select(['EmployeeID', 'FirstName', 'LastName', 'Position', 'docId'])
  .result();
  ]]></pre></apidoc:example>


   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:result()
 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees", (), op:fragment-id-col('docId'))
   => op:select(("EmployeeID", "FirstName", "LastName", "Position", "docID"))
   => op:order-by("EmployeeID")
   => op:result()
 
  ]]></pre></apidoc:example>

 

  </apidoc:method>

  <apidoc:function class="xquery" name="from-view" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromView">
  </apidoc:function>


 <apidoc:method name="fragmentIdCol" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">
   <apidoc:summary>
     Specifies a name for adding a fragment id column to the row set identifying the 
     source documents for the rows from a view, lexicons or triples.
     The only use for the fragment id is joining other rows from the same document,
     the document uri, or the document content.  The fragment id is only useful 
     during execution of the query and not after.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The name of the fragment ID column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">fragmentIdColDef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const Plan =
op.fromLexicons(
       {EmployeeID: cts.elementReference(xs.QName('EmployeeID'))}, 
       'myview', op.fragmentIdCol('Document Fragment'),
       cts.jsonPropertyWordQuery('Position', 'Manager'));

Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-lexicons(
   map:entry("EmployeeID", cts:element-reference(xs:QName("EmployeeID"))),
   "myview",
   op:fragment-id-col("Document Fragment"))
=> op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="fragment-id-col" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fragmentIdCol">
  </apidoc:function>


 <apidoc:method name="fromTriples" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>
    Reads rows by matching patterns in the triple index.
    <p>
    The rows have a column for each column name in the patterns. While each column 
    will have a consistent datatype for all rows from a view, the columns of rows 
    from a graph may have varying data types, which could affect joins.
    </p> 
     <p>
     This function creates a row set without a limit.  Use 
     <a class="javascript" href="#AccessPlan.prototype.limit">AccessPlan.prototype.limit</a> 
     <a class="xquery" href="#op:limit">op:limit</a> or
     <a class="javascript" href="#AccessPlan.prototype.offsetLimit">AccessPlan.prototype.offsetLimit</a> 
     <a class="xquery" href="#op:offset-limit">op:offset-limit</a> 
     to set a limit.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="patterndef" type="String"> 
         One or more pattern definitions returned by the 
         <a href="#op.pattern">op.pattern</a> function. 
       </apidoc:param>
       <apidoc:param class="xquery" name="patterns" type="map:map+">
          One or more pattern definitions returned by the 
         <a href="#op:pattern">op:pattern</a> function. 
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
          Specifies a name for qualifying the column names. By default, triple rows 
          have no qualification. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
          Specifies a name for qualifying the column names. By default, triple rows 
          have no qualification. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="javascript" name="graphIri" type="String" optional="true"> 
         A list of graph IRIs to restrict the results to triples in the specified graphs. 
         The <a href="#sem.defaultGraphIri">sem.defaultGraphIri</a> function 
         returns the iri that identifies the default graph. 
       </apidoc:param>
       <apidoc:param class="xquery" name="graphIris" type="xs:anyAtomicType*" optional="true">
         A list of graph IRIs to restrict the results to triples in the specified graphs. 
         The <a href="#sem:default-graph-iri">sem:default-graph-iri</a> function 
         returns the iri that identifies the default graph. 
       </apidoc:param>
       <apidoc:param class="javascript" name="tripleOptions" type="String" optional="true"> 
         Options consisting of key-value pairs that set options. At present, the options 
         consist of dedup which can take an on|off value to enable or disable deduplication.
         Deduplication is off by default. 
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         Options consisting of key-value pairs that set options. At present, the options 
         consist of dedup which can take an on|off value to enable or disable deduplication.
         Deduplication is off by default. 
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">AccessPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
    The <code>fromTriples</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.
     <p>
   The library functions for building the fromTriples parameters are as
   follows:
  </p>
  <ul>
    <li><a href="#op.pattern">op.pattern</a></li>
    <li><a href="#op.prefixer">op.prefixer</a></li>
   </ul>    
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Returns a list of the people who were born in Brooklyn in the form 
// of a table with two columns, 'person' and 'name'.

const op = require('/MarkLogic/optic');
// prefixer is a factory for sem:iri() constructors in a namespace
const resource   = op.prefixer('http://dbpedia.org/resource/');
const foaf   = op.prefixer('http://xmlns.com/foaf/0.1/');
const onto = op.prefixer('http://dbpedia.org/ontology/');

const person = op.col('person');

const Plan =
    op.fromTriples([
        op.pattern(person, onto('birthPlace'), resource('Brooklyn')),
        op.pattern(person, foaf("name"), op.col("name"))
    ])
Plan.result(); 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $resource := op:prefixer("http://dbpedia.org/resource/")
let $foaf     := op:prefixer("http://xmlns.com/foaf/0.1/")
let $onto     := op:prefixer("http://dbpedia.org/ontology/")
let $person   := op:col("person")

return op:from-triples((
   op:pattern($person, $onto("birthPlace"), $resource("Brooklyn")), 
   op:pattern($person, $foaf("name"), op:col("name"))))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="from-triples" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromTriples">
  </apidoc:function>



 <apidoc:method name="pattern" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Building fromTriples Parameters">
   <apidoc:summary>     
    This function builds the parameters for the <a class="javascript" href="#op.fromTriples">op.fromTriples</a>
    <a class="xquery" href="#op:from-triples">op:from-triples</a> function.
    The result is passed to <a class="javascript" href="#op.fromTriples">op.fromTriples</a> 
    <a class="xquery" href="#op:from-triples">op:from-triples</a>
    to project rows from the graph of triples.  The columns in a pattern become the columns of the row.  
    The literals in a pattern are used to match triples.  You should specify at least one literal
    in each pattern, usually the predicate.  
    Where a column appears in more than one pattern, the matched triples are joined to form the row.
    You can specify optional triples with a <a class="xquery" href="#op:join-left-outer">op:join-left-outer</a>
    <a class="javascript" href="#AccessPlan.prototype.joinLeftOuter">prototype.joinLeftOuter</a>
    with a separate <a class="javascript" href="#op.fromTriples">op.fromTriples</a>
    <a class="xquery" href="#op:from-triples">op:from-triples</a>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="subjects" type="String"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem.iri">sem.iri</a> call. 
       </apidoc:param>
       <apidoc:param class="xquery" name="subjects" type="item()+"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem:iri">sem:iri</a> call.      
       </apidoc:param>
       <apidoc:param class="javascript" name="predicates" type="String"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem.iri">sem.iri</a> call. 
       </apidoc:param>
       <apidoc:param class="xquery" name="predicates" type="item()+"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem.iri">sem.iri</a> call.     
       </apidoc:param>
       <apidoc:param class="javascript" name="objects" type="String"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem.iri">sem.iri</a> call.  
       </apidoc:param>
       <apidoc:param class="xquery" name="objects" type="item()+"> 
         One column or one or more literal values, such as the literal returned by a 
         <a href="#sem:iri">sem:iri</a> call.     
       </apidoc:param>
       <apidoc:param class="javascript" name="systemCols" type="String" optional="true"> 
         Specifies the result of an <a href="#op.fragmentIdCol">op.fragmentIdCol</a> or
         <a href="#op.graphCol">op.graphCol</a> function to add columns for the
         fragment id or graph iri. 
       </apidoc:param>
       <apidoc:param class="xquery" name="systemCols" type="map:map*" optional="true"> 
         Specifies the result of an <a href="#op:fragment-id-col">op:fragment-id-col</a> or
         <a href="#op:graph-col">op:graph-col</a> function to add columns for the
         fragment id or graph iri.    
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">patterndef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
// prefixer is a factory for sem:iri() constructors in a namespace
const resource   = op.prefixer('http://dbpedia.org/resource/');
const foaf   = op.prefixer('http://xmlns.com/foaf/0.1/');
const onto = op.prefixer('http://dbpedia.org/ontology/');

const person = op.col('person');

const Plan =
    op.fromTriples([
        op.pattern(person, onto('birthPlace'), resource('Brooklyn')),
        op.pattern(person, foaf("name"), op.col("name"))
    ])
    .select();
Plan.result(); 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $resource := op:prefixer("http://dbpedia.org/resource/")
let $foaf     := op:prefixer("http://xmlns.com/foaf/0.1/")
let $onto     := op:prefixer("http://dbpedia.org/ontology/")
let $person   := op:col("person")

return op:from-triples((
   op:pattern($person, $onto("birthPlace"), $resource("Brooklyn")), 
   op:pattern($person, $foaf("name"), op:col("name"))))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="pattern" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.pattern">
  </apidoc:function>

 <apidoc:method name="prefixer" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Building fromTriples Parameters">
   <apidoc:summary  class="javascript">
    This function factory returns a new function that takes a name parameter and 
    prepends the specified base URI onto the name.   
   </apidoc:summary>
   <apidoc:summary  class="xquery">
    This function factory returns a new function that takes a name parameter and returns a 
    <a href="#sem:iri">sem:iri</a>,
    prepending the specified base URI onto the name.   
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="baseUri" type="String"> 
         The base URI to be prepended to the name.   
       </apidoc:param>
       <apidoc:param class="xquery" name="baseUri" type="xs:string"> 
         The base URI to be prepended to the name.   
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">sem:iri</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
// prefixer is a factory for sem:iri() constructors in a namespace
const resource   = op.prefixer('http://dbpedia.org/resource/');
const foaf   = op.prefixer('http://xmlns.com/foaf/0.1/');
const onto = op.prefixer('http://dbpedia.org/ontology/');

const person = op.col('person');

const Plan =
    op.fromTriples([
        op.pattern(person, onto('birthPlace'), resource('Brooklyn')),
        op.pattern(person, foaf("name"), op.col("name"))
    ])
    .select();
Plan.result(); 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $resource := op:prefixer("http://dbpedia.org/resource/")
let $foaf     := op:prefixer("http://xmlns.com/foaf/0.1/")
let $onto     := op:prefixer("http://dbpedia.org/ontology/")
let $person   := op:col("person")

return op:from-triples((
   op:pattern($person, $onto("birthPlace"), $resource("Brooklyn")), 
   op:pattern($person, $foaf("name"), op:col("name"))))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>


  <apidoc:function class="xquery" name="prefixer" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.prefixer">
  </apidoc:function>


 <apidoc:method name="fromLexicons" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>
    This function dynamically constructs a view from range indexes or the uri or collection lexicons.
    This function will only return rows for documents where the first column has a value.
    The keys in the map specify the names of the columns and the values in the map provide
    <a class="javascript" href="#cts.reference">cts.reference</a> 
    <a class="xquery" href="#cts:reference">cts:reference</a> objects to specify the lexicon 
    providing the values of the columns.  Optic emits
    rows based on co-occurrence of lexicon values within the same document similar to 
    <a class="javascript" href="#cts.valueTuples">cts.valueTuples</a> 
    <a class="xquery" href="#cts:value-tuples">cts:value-tuples</a>
    If the <a class="javascript" href="#cts.reference">cts.reference</a> 
    <a class="xquery" href="#cts:reference">cts:reference</a> sets the nullable 
    option to <code>true</code>, the column is optional in the row.
     <p>
     This function creates a row set without a limit.  Use 
     <a class="javascript" href="#AccessPlan.prototype.limit">AccessPlan.prototype.limit</a> 
     <a class="xquery" href="#op:limit">op:limit</a> or
     <a class="javascript" href="#AccessPlan.prototype.offsetLimit">AccessPlan.prototype.offsetLimit</a> 
     <a class="xquery" href="#op:offset-limit">op:offset-limit</a> 
     to set a limit.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="indexdef" type="String"> 
         An object in which each key is a column name and each value specifies a 
         <code>cts.reference</code> for a range index or other lexicon (especially the 
         <a href="#cts.uriReference">cts.uriReference</a> lexicon) with the column values.
       </apidoc:param>
       <apidoc:param class="xquery" name="columnBindings" type="map:map">
         An object in which each key is a column name and each value specifies a 
         <code>cts:reference</code> for a range index or other lexicon (especially the 
         <a href="#cts:uri-reference">cts:uri-reference</a> lexicon) with the column values.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
          Specifies a name for qualifying the column names. By default, lexicon rows have no 
          qualification. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?">
          Specifies a name for qualifying the column names. By default, lexicon rows have no 
          qualification. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="javascript" name="systemCols" type="String" optional="true">
        An optional named fragment id column returned by the 
        <a href="#op.fragmentIdCol">op.fragmentIdCol</a> function.
        The fragment id column can be used for joins. 
       </apidoc:param>
       <apidoc:param class="xquery" name="systemCols" type="map:map?" optional="true">
         An optional named fragment id column returned by the 
         <a href="#op:fragment-id-col">op:fragment-id-col</a> function.
         The fragment id column can be used for joins. 
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">AccessPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
    The <code>fromLexicons</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Return the EmployeeID, FirstName, LastName, the URI of the document 
// holding the data, and document fragment ID for each employee with 
// 'Manager' in their Position title.

const op = require('/MarkLogic/optic');

const Plan =
op.fromLexicons({
            EmployeeID: cts.elementReference(xs.QName('EmployeeID')),
            FirstName: cts.elementReference(xs.QName('FirstName')),
            LastName: cts.elementReference(xs.QName('LastName')),
            URI: cts.uriReference()}, 
            null, 
            op.fragmentIdCol('Document Fragment'));

Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-lexicons(
   map:entry("EmployeeID", cts:element-reference(xs:QName("EmployeeID"))),
   "myview",
   op:fragment-id-col("Document Fragment"))
=> op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="from-lexicons" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromLexicons">
  </apidoc:function>

<apidoc:method name="fromLiterals" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>     
   Constructs a literal row set as in the SQL VALUES or SPARQL VALUES statements.
   When specifying rows with arrays, values are mapped to column names by position.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rowdefs" type="String"> 
         This parameter is either an array of object literals or 
         <a href="#sem.binding">sem.binding</a> objects in which the
         key is a column name string identifying the column and the value is a literal 
         with the value of the column, or this parameter is an object with a columnNames key having 
         a value of an array of column names and a rowValues key having a value of an array 
         of arrays with literal values.
       </apidoc:param>
       <apidoc:param class="xquery" name="rowdefs" type="item()+">
         This parameter is either an array of object literals or 
         <a href="#sem:binding">sem:binding</a> objects in which the
         key is a column name string identifying the column and the value is a literal 
         with the value of the column, or this parameter is an object with a columnNames key having 
         a value of an array of column names and a rowValues key having a value of an array 
         of arrays with literal values.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">AccessPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
     The <code>fromLiterals</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Build a table with five rows and return the average values for 
// group 1 and group 2.

const op = require('/MarkLogic/optic');
op.fromLiterals([
            {group:1, val:2}, 
            {group:1, val:4}, 
            {group:2, val:3}, 
            {group:2, val:5}, 
            {group:2, val:7} 
            ])
          .orderBy('group')
          .groupBy('group', op.avg('valAvg', 'val')).result()
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
            map:entry("group", 1) => map:with("val", 2),
            map:entry("group", 1) => map:with("val", 4), 
            map:entry("group", 2) => map:with("val", 3),
            map:entry("group", 2) => map:with("val", 5),
            map:entry("group", 2) => map:with("val", 7) 
            ))
    => op:order-by('group') 
    => op:group-by('group', op:avg('valAvg', 'val')) 
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="from-literals" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromLiterals">
  </apidoc:function>




<apidoc:method name="fromSQL" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>
    This function dynamically constructs a row set based on a SQL SELECT query 
    from views.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="select" type="String"> 
         A SQL SELECT query expressed as a string.
       </apidoc:param>
       <apidoc:param class="xquery" name="select" type="xs:string">
         A SQL SELECT query expressed as a string.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
          Specifies a name for qualifying the column names. Placeholder parameters in the 
          SQL string may be bound in the result() call.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
          Specifies a name for qualifying the column names. Placeholder parameters in the 
          SQL string may be bound in the result() call
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
    The <code>fromSQL</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// List all of the employees in the 'employees' view.

const op = require('/MarkLogic/optic');

  op.fromSQL('SELECT employees.FirstName, employees.LastName FROM employees')
    .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Joins the row set produced by an SQL SELECT with the row set produced by a 
// SPARQL SELECT and then groups, orders, and limits the result:

const op = require('/MarkLogic/optic');

const topTweeters =
  op.fromSQL('SELECT customerId, customerName FROM customers WHERE ...', 'customers')
    .joinInner(
      op.fromSPARQL('SELECT ?customerId ?tweetId WHERE { ... }', 'tweets'),
      op.on(
        op.viewCol('customers', 'customerId'),
        op.viewCol('tweets',    'customerId')
        ))
    .groupBy('customerName', op.count('tweetCount', 'tweetId'))
    .orderBy('tweetCount')
    .limit(1000)
    .map(row => {...})
    .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: List all of the employees in the 'employees' view. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

  op:from-sql('SELECT employees.FirstName, employees.LastName FROM employees')
     => op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="from-sql" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromSQL">
  </apidoc:function>



<apidoc:method name="fromSPARQL" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Data Access Functions">
   <apidoc:summary>
    This function dynamically constructs a row set based on an SPARQL SELECT query 
    from triples.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="select" type="String"> 
         A SPARQL SELECT query expressed as a string.
       </apidoc:param>
       <apidoc:param class="xquery" name="select" type="xs:string">
         A SPARQL SELECT query expressed as a string.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
          Specifies a name for qualifying the column names. Placeholder parameters in the 
          SPARQL string may be bound in the result() call.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
          Specifies a name for qualifying the column names. Placeholder parameters in the 
          SPARQL string may be bound in the result() call
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
    The <code>fromSPARQL</code> function is one of the 
    <a href="/js/op/data-access-functions">Data Access Functions</a>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// List all of the people born in Brooklyn.

const op = require('/MarkLogic/optic');

  op.fromSPARQL('PREFIX db: <http://dbpedia.org/resource/> \
                 PREFIX foaf: <http://xmlns.com/foaf/0.1/> \
                 PREFIX onto: <http://dbpedia.org/ontology/> \
                 SELECT ?person ?name WHERE { ?person onto:birthPlace db:Brooklyn; foaf:name ?name .}')
    .result(); 

  ]]></pre></apidoc:example>


   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: List all of the people born in Brooklyn. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

  op:from-sparql('PREFIX db: <http://dbpedia.org/resource/>  
                  PREFIX foaf: <http://xmlns.com/foaf/0.1/>  
                  PREFIX onto: <http://dbpedia.org/ontology/>  
                  SELECT ?person ?name 
                    WHERE { ?person onto:birthPlace db:Brooklyn; 
                    foaf:name ?name .}')
  => op:result()

  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="from-sparql" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.fromSPARQL">
  </apidoc:function>




<apidoc:method name="prototype.col" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object">
   <apidoc:summary>
      This method identifies a column, where the column name is unique. A qualifier on 
      the column name isn't necessary (and might not exist).  In positions where only a 
      column name can appear, the unqualified column name can also be provided as a string.
      Qualified column names cannot be provided as a string.

   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map" optional="true">
         The Optic AccessorPlan created by <a href="#op:from-view">op:from-view</a>, 
         <a href="#op:from-triples">op:from-triples</a>, or 
         <a href="#op:from-lexicons">op:from-lexicons</a>.
       </apidoc:param>
       <apidoc:param class="javascript" name="colName" type="String"> 
         The name of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="colName" type="string">
         The name of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">columnIdentifier</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>col</code> is a method of the <a href="/js/AccessPlan">AccessPlan</a> class.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $resource := op:prefixer("http://dbpedia.org/resource/")
let $foaf     := op:prefixer("http://xmlns.com/foaf/0.1/")
let $onto     := op:prefixer("http://dbpedia.org/ontology/")
let $person   := op:col("person")

return op:from-triples((
   op:pattern($person, $onto("birthPlace"), $resource("Brooklyn")), 
   op:pattern($person, $foaf("name"), op:col("name"))))
   => op:result() 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                  op:view-col("employees", "EmployeeID"),
                  op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>


  <apidoc:function class="xquery" name="col" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="AccessPlan.prototype.col">
  </apidoc:function>

<apidoc:method name="schemaCol" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">
   <apidoc:summary>
     Unambiguously identifies a column with the schema name, view name, and column name. 
     Useful only for columns provided by a view.   
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="schemaName" type="String"> 
         The name of the schema.
       </apidoc:param>
       <apidoc:param class="xquery" name="schemaName" type="string?"> 
         The name of the schema.
       </apidoc:param>
       <apidoc:param class="javascript" name="viewName" type="String"> 
         The name of the view.
       </apidoc:param>
       <apidoc:param class="xquery" name="viewName" type="string?"> 
         The name of the view.
       </apidoc:param>
       <apidoc:param class="javascript" name="colName" type="String"> 
         The name of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="colName" type="string"> 
         The name of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">columnIdentifier</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
	      .orderBy(op.schemaCol('main', 'employees', 'EmployeeID'))
	      .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
	   => op:order-by(op:schema-col('main', 'employees', 'EmployeeID'))
	   => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="schema-col" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.schemaCol">
  </apidoc:function>

<apidoc:method name="viewCol" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">
   <apidoc:summary>
     Identifies a column where the combination of view and column name 
     is unique. Identifying the schema isn't necessary (and it might not exist).
     <p>
     If the combination of view and column name is not unique, an 
     ambiguous column error is thrown.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="viewName" type="String"> 
         The name of the view.
       </apidoc:param>
       <apidoc:param class="xquery" name="viewName" type="string?"> 
         The name of the view.
       </apidoc:param> 
       <apidoc:param class="javascript" name="colName" type="String"> 
         The name of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="colName" type="string"> 
         The name of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">columnIdentifier</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
	      .orderBy(op.viewCol('employees', 'EmployeeID'))
	      .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")

return $employees
   => op:join-inner($expenses, 
                    op:on(op:view-col("employees", "EmployeeID"),
                          op:view-col("expenses", "EmployeeID"))) 
   => op:select((op:view-col("employees", "EmployeeID"), 
                            "FirstName", "LastName", "Category"))
   => op:order-by(op:view-col("employees", "EmployeeID"))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="view-col" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.viewCol">
  </apidoc:function>



<apidoc:method name="col" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">
   <apidoc:summary>
     Identifies a column where the column name is unique and a qualifier 
     on the column name isn't necessary (and might not exist).
     <p>
     In positions where only a column name can appear, the unqualified column 
     name can also be provided as a string.  Qualified column names cannot be 
     provided as a string.
     </p>   
     <p>
     The returned value from this function can be modified by any of the functions
 described in <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2369308'>Expression Functions For Processing Column Values</a> in the <em>Application Developer's Guide</em>
   </p> 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="colName" type="String"> 
         The name of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">columnIdentifier</apidoc:return>
   <apidoc:usage class="javascript">
  
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();

  ]]></pre></apidoc:example>

  </apidoc:method>



  <apidoc:method name="prototype.where" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method restricts the row set to rows matched by the boolean expression.
     Use boolean composers such as 
     <a class="javascript" href="#op.and">op.and</a> 
     <a class="xquery" href="#op:and">op:and</a> 
     and <a class="javascript" href="#op.or">op.or</a> 
     <a class="xquery" href="#op:or">op:or</a> 
     to combine multiple expressions.
     <p>
     A constraining document query returns only the rows from the matched source documents. If the
     constraining document query is a node instead of a 
     <a class="javascript" href="#cts.query">cts.query</a> 
     <a class="xquery" href="#cts:query">cts:query</a> 
     object, the implementation calls the 
     <a class="javascript" href="#cts.query">cts.query</a> 
     <a class="xquery" href="#cts:query">cts:query</a> 
     parser on the node. The constraining document query applies to all upstream accessors.
     A constraining 
     <a class="javascript" href="#sem.store">sem.store</a> 
     <a class="xquery" href="#sem:store">sem:store</a> 
     returns only the triples from the specified store (potentially expanded by inference
     using a ruleset). A constraining
     <a class="javascript" href="#sem.store">sem.store</a> 
     <a class="xquery" href="#sem:store">sem:store</a> 
     applies to all upstream triples accessors.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         This can be a boolean expression, a <a href="#cts.query">cts.query</a>
         to qualify the source documents that produced the rows set, or (where part 
         of the row set was produced by the <a href="#op.fromTriples">op.fromTriples</a> 
         accessor) a <a href="#sem.store">sem.store</a> to restrict or expand the 
         triples that produce the row set.
       </apidoc:param>
       <apidoc:param class="xquery" name="condition" type="item()">
         This can be a boolean expression, a <a href="#cts:query">cts:query</a>
         to qualify the source documents that produced the rows set, or (where part 
         of the row set was produced by the <a href="#op:from-triples">op:from-triples</a> 
         accessor) a <a href="#sem:store">sem:store</a> to restrict or expand the 
         triples that produce the row set.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>where</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul>  
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Locate employee expenses that exceed the allowed limit

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const expenselimit = op.fromView('main', 'expenselimit');
 
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
         .joinInner(expenselimit, op.on(expenses.col('Category'), expenselimit.col('Category')))
         .where(op.gt(expenses.col('Amount'), expenselimit.col('Limit') ))
         .select([employees.col('EmployeeID'), 'FirstName', 'LastName', expenses.col('Category'),
                  expenses.col('Amount'),  expenselimit.col('Limit') ])
         .orderBy(employees.col('EmployeeID'))
   Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $expenselimit  := op:from-view("main", "expenselimit")
return $employees
   => op:join-inner($expenses, op:on(
                op:view-col("employees", "EmployeeID"),
                op:view-col("expenses", "EmployeeID")))
   => op:join-inner($expenselimit, op:on(
                op:view-col("expenses", "Category"),
                op:view-col("expenselimit", "Category"))) 
   => op:where(op:gt(op:view-col("expenses", "Amount"),
                op:view-col("expenselimit", "Limit"))) 
   => op:select((op:view-col("employees", "EmployeeID"), 
                "FirstName", "LastName", 
                op:view-col("expenses", "Category"),
                op:view-col("expenses", "Amount"),
                op:view-col("expenselimit", "Limit")))
   => op:order-by(op:view-col("employees", "EmployeeID"))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.where" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.where">
  </apidoc:method>

  <apidoc:function class="xquery" name="where" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="ModifyPlan.prototype.where">
  </apidoc:function>



  <apidoc:method name="prototype.whereDistinct" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method removes duplicate rows from the row set.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
     </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
     <code>whereDistinct</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromLiterals([
            {id:1, val: 2},
            {id:1, val: 2},
            {id:2, val: 4}
	        ])
   .select()
   .whereDistinct()
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
	              map:entry("id", 1) => map:with("val", 2),
	              map:entry("id", 1) => map:with("val", 2),
	              map:entry("id", 2) => map:with("val", 4)
	              ))
	            => op:select(())
	            => op:where-distinct()      
	            => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.whereDistinct" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.whereDistinct">
  </apidoc:method>

  <apidoc:function class="xquery" name="where-distinct" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.whereDistinct">
  </apidoc:function>


  <apidoc:method name="prototype.groupBy" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
    This method collapses a group of rows into a single row.
    <p> 
    If you want the results to include a column, specify the column either 
    as a grouping key or as one of the aggregates. A group-by operation without a grouping 
    key outputs a single group reflecting the entire row set.
    </p><p>
    The aggregates for a group by operation are specified as the second parameter instead of in a 
     <a class="javascript" href="#ModifyPlan.prototype.select">prototype.select</a>
     <a class="xquery" href="#op:select">op:select</a> operation (unlike SQL).
    </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
          The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="groupdef" type="String"> 
        This parameter specifies the columns used to determine the groups.
        Rows with the same values in these columns are consolidated into a single group. 
        The columns can be existing columns or new columns created by an expression specified with 
        <a href="#op.as">op.as</a>. 
        The rows produced by the group by operation include the key columns.
        Specify an empty sequence to create a single group for all of the rows in the row set.
       </apidoc:param>
       <apidoc:param class="xquery" name="keys" type="item()*">
       This parameter specifies the columns used to determine the groups.
       Rows with the same values in these columns are consolidated into a single group. 
       The columns can be existing columns or new columns created by an expression specified with 
       <a href="#op:as">op:as</a>. 
       The rows produced by the group by operation include the key columns.
       Specify an empty sequence to create a single group for all of the rows in the row set.
       </apidoc:param>
       <apidoc:param class="javascript" name="aggregatedef" type="String" optional="true">
        This parameter specifies either columns to sample or aggregate functions to apply to a column
        for all of the rows in the group.
        Sampled columns can be existing columns or new columns created by an expression specified with 
        <a href="#op.as">op.as</a>. 
        Often a sampled column might have a constant value within the group such as a title or label closely
        associated with a numeric identifier used as the grouping key.
        The aggregate functions are listed below. 
       </apidoc:param>
       <apidoc:param class="xquery" name="aggregates" type="item()*" optional="true">
         This parameter specifies either new columns for aggregate functions over the 
         rows in the group or columndefs that are constant for the group. 
         The aggregate library functions are listed below.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
      <p>
      <code>groupBy</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul>  
     <p>
   The aggregate library functions for building the groupBy parameters are as
   follows:
  </p>
  <ul>
    <li><a href="#op.arrayAggregate">op.arrayAggregate</a></li>
    <li><a href="#op.avg">op.avg</a></li>
    <li><a href="#op.count">op.count</a></li>
    <li><a href="#op.groupConcat">op.groupConcat</a></li>
    <li><a href="#op.max">op.max</a></li>
    <li><a href="#op.min">op.min</a></li>
    <li><a href="#op.sample">op.sample</a></li>
    <li><a href="#op.sum">op.sum</a></li>
    <li><a href="#op.uda">op.uda</a></li>
   </ul>    
   </apidoc:usage>
   <apidoc:usage class="xquery"> 
     <p>
   The aggregate library functions for building the group-by parameters are as
   follows:
  </p>
  <ul>
    <li><a href="#op:array-aggregate">op:array-aggregate</a></li>
    <li><a href="#op:sequence-aggregate">op:sequence-aggregate</a></li>
    <li><a href="#op:avg">op:avg</a></li>
    <li><a href="#op:count">op:count</a></li>
    <li><a href="#op:group-concat">op:group-concat</a></li>
    <li><a href="#op:max">op:max</a></li>
    <li><a href="#op:min">op:min</a></li>
    <li><a href="#op:sample">op:sample</a></li>
    <li><a href="#op:sum">op:sum</a></li>
    <li><a href="#op:uda">op:uda</a></li>
   </ul>    
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in 
// order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the average expense across all expense reports. 

const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy(null, op.avg("Average Amount", "Amount"))
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Calculate the total expenses for each employee and return results 
   in order of employee number. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                  op:view-col("employees", "EmployeeID"),
                  op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result() 
  ]]></pre></apidoc:example>
   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Calculate the average expense across all expense reports. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "expenses")
   => op:group-by((), op:avg("Average Amount", "Amount")) 
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.groupBy" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.groupBy">
  </apidoc:method>

  <apidoc:function class="xquery" name="group-by" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.groupBy">
  </apidoc:function>

  <apidoc:method name="as" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">>
   <apidoc:summary> 
      This function defines a column by assigning the value of an expression 
      over the rows in the row set.
 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="column" type="String"> 
         The name of the column to be defined. This can be
         either a string or the return value from 
         <a href="#op.col">op.col</a>, 
         <a href="#op.viewCol">op.viewCol</a>, or
         <a href="#op.schemaCol">op.schemaCol</a>.
       </apidoc:param>
       <apidoc:param class="xquery" name="column" type="item()"> 
         The name of the column to be defined. This can be
         either a string or the return value from 
         <a href="#op:col">op:col</a>, 
         <a href="#op:view-col">op:view-col</a>, or
         <a href="#op:schema-col">op:schema-col</a>.
       </apidoc:param>
       <apidoc:param class="javascript" name="expression" type="String"> 
         The expression used to define the value the column. 
       </apidoc:param>
       <apidoc:param class="xquery" name="expression" type="item()*"> 
         The expression used to define the value the column. 
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">columnBinding</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
 
const Plan =
employees.joinLeftOuter(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(op.as("TotalExpenses", op.col('totalexpenses')), expenses.col('Amount'))])
   .orderBy('EmployeeID')
   Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(("EmployeeID", op:as("node", op:xml-comment(op:col("Position")))))
   => op:order-by("EmployeeID")
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="as" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.as">
  </apidoc:function>



  <apidoc:method name="prototype.orderBy" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
      This method sorts the row set by the specified order definition.
   </apidoc:summary>
      <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
          The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="orderdef" type="String"> 
 	     The specified column or sortdef output from the 
          <a href="#op.asc">op.asc</a> or
          <a href="#op.desc">op.desc</a> function.
       </apidoc:param>
       <apidoc:param class="xquery" name="keys" type="item()+">
 	     The specified column or sortdef output from the 
          <a href="#op:asc">op:asc</a> or
          <a href="#op:desc">op:desc</a> function.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>orderBy</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
     <p>
	 The library functions that return a <code>sortdef</code> used by the 
     <code>orderdef</code> parameter are as follows:
     </p>
     <ul>
       <li><a href="#op.asc">op.asc</a></li>
       <li><a href="#op.desc">op.desc</a></li>
    </ul>    
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.orderBy" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.orderBy">
  </apidoc:method>

  <apidoc:function class="xquery" name="order-by" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.orderBy">
  </apidoc:function>



  <apidoc:method name="asc" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Building orderBy Parameters">>
   <apidoc:summary> 
      This function sorts the specified <code>columndef</code> in ascending order.
     The results are used by the 
     <a class="javascript" href="#ModifyPlan.prototype.orderBy">prototype.orderBy</a>
     <a class="xquery" href="#op:order-by">op:order-by</a> function.
   </apidoc:summary>
      <apidoc:params>
       <apidoc:param  class="javascript" name="columndef" type="String"> 
	  The column by which order the output.
       </apidoc:param>
       <apidoc:param class="xquery" name="column" type="item()">
	  The column by which order the output.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">sortdef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of total 
// expenses, lowest to highest.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy(op.asc('totalexpenses'))
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:asc(op:view-col("employees", "EmployeeID"))) 
   => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="asc" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.asc">
  </apidoc:function>



  <apidoc:method name="desc" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Building orderBy Parameters">>
   <apidoc:summary> 
      This function sorts the specified <code>columndef</code> in descending order.
     The results are used by the 
     <a class="javascript" href="#ModifyPlan.prototype.orderBy">prototype.orderBy</a>
     <a class="xquery" href="#op:order-by">op:order-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="columndef" type="String"> 
	     The column by which order the output.
       </apidoc:param>
       <apidoc:param class="xquery" name="column" type="item()">
	     The column by which order the output.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">sortdef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of total 
// expenses, highest to lowest.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy(op.desc('totalexpenses'))
Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:desc(op:view-col("employees", "EmployeeID"))) 
   => op:result()  
  ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:function class="xquery" name="desc" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.desc">
  </apidoc:function>

  <apidoc:method name="prototype.limit" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method specifies the maximum number of rows to be returned by this Plan.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="length" type="String"> 
	      The maximum number of rows to return.
       </apidoc:param>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="xquery" name="length" type="item()">
	      The number of rows to return.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>limit</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return ten results in order 
// of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
   .limit(10)
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:limit(10)
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.limit" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.limit">
  </apidoc:method>

  <apidoc:function class="xquery" name="limit" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.limit">
  </apidoc:function>

  <apidoc:method name="prototype.offset" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method returns a subset of the rows in the result set by skipping the number of
     rows specified by <code>start</code> and returning the remaining rows up to the number
     specified by the <a class="javascript" href="#ModifyPlan.prototype.limit">prototype.limit</a> 
      <a class="xquery" href="#op:limit">op:limit</a> method.
     <p>
     A common pattern is to page over a result set by using a 
     <a class="javascript" href="#op.param">op.param</a> 
     <a class="xquery" href="#op:param">op:param</a>
     placeholder parameter for the start and specifying the starting value
     in bindings for <a class="javascript" href="#op.result">op.result</a> 
     <a class="xquery" href="#op:result">op:result</a>. 
     This approach reuses the cached query instead
     of recalculating the query on each request. 
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="start" type="String"> 
     	  The number of rows to skip.
       </apidoc:param>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="xquery" name="start" type="item()">
     	  The number of rows to skip.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>limit</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return two results in order 
// of employee number, starting with the third result.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
   .offset(2)
   .limit(2)
Plan.result(); 

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:offset(2)
   => op:limit(10)
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.offset" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.offset">
  </apidoc:method>

  <apidoc:function class="xquery" name="offset" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.offset">
  </apidoc:function>

  <apidoc:method name="prototype.offsetLimit" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method returns a subset of the rows in the result set by skipping the number of
     rows specified by <code>start</code> and returning the remaining rows up to the 
     <code>length</code> limit. 
     <p>
     A common pattern is to page over a result set by using a 
     <a class="javascript" href="#op.param">op.param</a> 
     <a class="xquery" href="#op:param">op:param</a>
     placeholder parameter for the start and specifying the starting value
     in bindings for <a class="javascript" href="#op.result">op.result</a> 
     <a class="xquery" href="#op:result">op:result</a>. 
     This approach reuses the cached query instead
     of recalculating the query on each request. 
     </p>

   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="start" type="String"> 
	     The number of rows to skip.  Default is 0.
       </apidoc:param>
       <apidoc:param class="xquery" name="start" type="item()">
	     The number of rows to skip.  Default is 1.  
       </apidoc:param>
       <apidoc:param class="javascript" name="length" type="String"> 
	     The maximum number of rows to return.
       </apidoc:param>
       <apidoc:param class="xquery" name="length" type="item()">
	     The maximum number of rows to return.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>limit</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return two results in order 
// of employee number, starting with the third result.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
   .offsetLimit(2, 2)
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:offset-limit(2, 2) 
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.offsetLimit" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.offsetLimit">
  </apidoc:method>

  <apidoc:function class="xquery" name="offset-limit" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.offsetLimit">
  </apidoc:function>

 <apidoc:method name="prototype.select" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
    This call projects the specified columns from the current row set and / or
    applies a qualifier to the columns in the row set. Unlike SQL, a select call is not
    required in an Optic query.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="columns" type="String"> 
    	  The columns to select.
       </apidoc:param>
       <apidoc:param class="xquery" name="columns," type="xs:string">
    	  The columns to select.
       </apidoc:param>
       <apidoc:param class="javascript" name="qualifier" type="String" optional="true"> 
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
       <apidoc:param class="xquery" name="qualifier" type="xs:string?" optional="true">
	      Specifies a name for qualifying the column names in place of the combination of the 
          schema and view names. Use cases for the qualifier include self joins.
          Using an empty string removes all qualification from the column names.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>select</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
op.fromView('main', 'employees')
   .select(['EmployeeID', 'FirstName', 'LastName'])
   .result();
  ]]></pre></apidoc:example>


   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Return all of the expenses and expense categories for each employee and return 
// results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');

const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .select([employees.col('EmployeeID'), 'FirstName', 'LastName', expenses.col('Category'), 'Amount'])
   .orderBy(employees.col('EmployeeID'))
 
   Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.select" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.select">
  </apidoc:method>

  <apidoc:function class="xquery" name="select" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.select">
  </apidoc:function>


 <apidoc:method name="param" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">>
   <apidoc:summary> 
     This function creates a placeholder for a literal value in an expression or as 
     the offset or max for a limit.  The  
     <a class="javascript" href="#IteratePlan.prototype.result">prototype.result</a>
     <a class="xquery" href="#op:result">op:result</a> 
     function throws in an error if the binding parameter does not specify a 
     literal value for the parameter.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
	  The name of the parameter.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="xs:string"> 
	  The name of the parameter.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">literalPlaceholder</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');

employees.offsetLimit(op.param('start'), op.param('length'))
	   .select(['EmployeeID', 
               op.as('incremented', op.add(op.col('EmployeeID'), op.param('increment')))])
	   .result(null, {start:1, length:2, increment:1});

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
   => op:offset-limit(op:param('start'), op:param('length'))
   => op:select(('EmployeeID', 
                  op:as('incremented',
                  op:add(op:col('EmployeeID'),
                  op:param('increment')))))
   => op:result((), map:entry("start",1)
   => map:with("length",2)
   => map:with("increment",1))
  
  ]]></pre></apidoc:example>

  </apidoc:method>
 
  <apidoc:function class="xquery" name="param" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.param">
  </apidoc:function>







 <apidoc:method name="prototype.joinInner" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary>
    This method returns all rows from multiple tables where the join condition is met.
    In the output row set, each row concatenates one left row and one right row 
    for each match between the keys in the left and right row sets.
    <p>
    The join performs natural joins between columns with the same identifiers. To prevent 
    inadvertent natural joins, specify a different qualifier for the left or right columns
    or use different column names for the left and right columns.
    </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
	    The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
	    The row set from the left view.
       </apidoc:param>
       <apidoc:param class="javascript" name="ondef" type="String"> 
	    The equijoin from one or more calls to the <a href="#op.on">op.on</a> 
        function.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
	    The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="keys" type="map:map*" optional="true">
	    The equijoin from one or more calls to the <a href="#op:on">op:on</a> 
        function.
       </apidoc:param>
       <apidoc:param class="javascript" name="condition" type="xs.boolean" optional="true"> 
	    A boolean expression that filters the join output rows. See 
       <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
       for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="condition" type="map:map?" optional="true">
	    A boolean expression that filters the join output rows. 
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>joinInner</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
     <p>
   The library functions for building the joinInner parameters are as
   follows:
  </p>
  <ul>
    <li><a href="#op.on">op.on</a></li>
   </ul>    
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
 
const Plan =
  employees.joinInner(expenses, op.on(employees.col('EmployeeID'),
                      expenses.col('EmployeeID'))) 
           .where(op.gt(expenses.col('Amount'), 150))
           .select([employees.col('EmployeeID'), 'FirstName', 
                    'LastName', expenses.col('Amount')]);
 
  Plan.result() 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
return $employees
   => op:join-inner($expenses, op:on(
          op:view-col("employees", "EmployeeID"),
          op:view-col("expenses",   "EmployeeID"))) 
   => op:select((op:view-col("employees", "EmployeeID"), 
                 "FirstName", "LastName", "Category",
                 op:view-col("expenses",   "Amount")))
   => op:order-by(op:view-col("employees", "EmployeeID"))
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.joinInner" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.joinInner">
  </apidoc:method>

  <apidoc:function class="xquery" name="join-inner" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.joinInner">
  </apidoc:function>



 <apidoc:method name="on" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Function for Building Join Parameters">>
   <apidoc:summary>
     Specifies an equijoin using one columndef each from the left and right rows.
     The result is used by the 
     <a class="javascript" href="#ModifyPlan.prototype.joinInner">prototype.joinInner</a> 
     <a class="xquery" href="#op:join-inner">op:join-inner</a> 
      and <a class="javascript" href="#ModifyPlan.prototype.joinLeftOuter">prototype.joinLeftOuter</a>
      <a class="xquery" href="#op:join-left-outer">op:join-left-outer</a>
     functions.
     <p>
      Use <a class="xquery" href="#op:view-col">op:view-col</a> 
     <a class="javascript" href="#op.viewCol">op.viewCol</a> or 
     <a class="xquery" href="#op:col">op:col</a> 
     <a class="javascript" href="#op.col">op.col</a>
     if you need to identify columns in the two views that have 
     the same column name.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="leftCol" type="String"> 
	     The rows from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftCol" type="item()">
	     The rows from the left view.
       </apidoc:param>
       <apidoc:param class="javascript" name="rightCol" type="String"> 
	     The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightCol" type="item()">
	     The row set from the right view.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ondef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:function class="xquery" name="on" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.on">
  </apidoc:function>


 <apidoc:method name="prototype.joinLeftOuter" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary>
      This method yields one output row set with the rows from an inner join as well as 
      rows from the left row set.
     <p>
     The join performs natural joins between columns with the same identifiers. To prevent 
     inadvertent natural joins, specify a different qualifier for the left or right columns
     or use different column names for the left and right columns.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
    	  The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
    	  The row set from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
    	  The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="keys" type="map:map*" optional="true">
	  The equijoin from one or more calls to the <a href="#op:on">op:on</a> 
      function.
       </apidoc:param>
       <apidoc:param class="javascript" name="ondef" type="String" optional="true"> 
	  The equijoin from one or more calls to the <a href="#op.on">op.on</a> 
      function.
       </apidoc:param>
       <apidoc:param class="javascript" name="condition" type="xs.boolean" optional="true"> 
	   A boolean expression that filters the join output rows.  See 
       <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
       for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="condition" type="map:map?" optional="true">
	      A boolean expression that filters the join output rows. 
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>joinLeftOuter</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
     <p>
   The library functions for building the joinLeftOuter parameters are as
   follows:
  </p>
  <ul>
    <li><a href="#op.on">op.on</a></li>
   </ul>    
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinLeftOuter(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', expenses.col('Category'),
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-left-outer($expenses, op:on(
                  op:view-col("employees", "EmployeeID"),
                  op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:view-col("expenses", "Category"),
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 

   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.joinLeftOuter" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.joinLeftOuter">
  </apidoc:method>

   <apidoc:function class="xquery" name="join-left-outer" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.joinLeftOuter">
  </apidoc:function>
 

 <apidoc:method name="prototype.joinCrossProduct" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary>
     This method yields one output row set that concatenates every left row 
     with every right row.  Matches other than equality matches (for instance, 
     greater-than comparisons between keys) can be implemented with a condition 
     on the cross product.
     <p>
     The join performs natural joins between columns with the same identifiers. 
     To prevent inadvertent natural joins, specify a different qualifier for the 
     left or right columns or use different column names for the left and right columns. 
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
	     The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
	     The row set from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
	     The row set from the right view.
       </apidoc:param>
       <apidoc:param class="javascript" name="condition" type="xs.boolean" optional="true"> 
	   A boolean expression that filters the join output rows. See 
       <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
       for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="condition" type="map:map?" optional="true">
	   A boolean expression that filters the join output rows.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>joinCrossProduct</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');

const Plan =
    employees.joinCrossProduct(expenses)
             .where(op.eq(employees.col('EmployeeID'), expenses.col('EmployeeID')))
             .orderBy([employees.col('EmployeeID')])
    Plan.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-cross-product($expenses ) 
   => op:where(op:eq(op:view-col("employees", "EmployeeID"), 
                     op:view-col("expenses", "EmployeeID")))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.joinCrossProduct" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.joinCrossProduct">
  </apidoc:method>

   <apidoc:function class="xquery" name="join-cross-product" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.joinCrossProduct">
  </apidoc:function>
     

 <apidoc:method name="prototype.union" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary>
     This method yields all of the rows from the input row sets.  Columns that are present 
     only in some input row sets effectively have a null value in the rows from 
     the other row sets.
     <p>
     This method is often followed by the 
     <a class="javascript" href="#ModifyPlan.prototype.whereDistinct">prototype.whereDistinct</a> 
     <a class="xquery" href="#op:where-distinct">op:where-distinct</a> modifier.
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
	  The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
	    The row set from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
	    The row set from the right view.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>union</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');

const Plan =
    employees.union(expenses)
     .whereDistinct()
     .orderBy([employees.col('EmployeeID')])
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
 
return $employees             
   => op:union($expenses) 
   => op:where-distinct() 
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.union" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.union">
  </apidoc:method>

   <apidoc:function class="xquery" name="union" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.union">
  </apidoc:function>
      

 <apidoc:method name="prototype.intersect" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">>
   <apidoc:summary>
     This method restricts the left row set to rows where a row with the same columns 
     and values exists in the right row set.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
	  The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
	    The row set from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
	    The row set from the right view.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>intersect</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const tab1 = op.fromLiterals([
	              {id:1, val:'a'},
	              {id:2, val:'b'},
	              {id:3, val:'c'}
	              ]);
const tab2 = op.fromLiterals([
	              {id:1, val:'x'},
	              {id:2, val:'b'},
	              {id:3, val:'c'}
	              ]);

tab1.intersect(tab2)
       .orderBy('id')
       .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $tab1 := op:from-literals((
   map:entry("id", 1) => map:with("val", "a"),
   map:entry("id", 2) => map:with("val", "b"),
   map:entry("id", 3) => map:with("val", "c")
   ))
let $tab2  := op:from-literals((
   map:entry("id", 1) => map:with("val", "x"),
   map:entry("id", 2) => map:with("val", "b"),
   map:entry("id", 3) => map:with("val", "c")
   ))
return $tab1 
   => op:intersect($tab2)
   => op:order-by("id")
   => op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.intersect" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.intersect">
  </apidoc:method>

   <apidoc:function class="xquery" name="intersect" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.intersect">
  </apidoc:function>
  
 <apidoc:method name="prototype.except" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">>
   <apidoc:summary>
     This method restricts the left row set to rows where a row with the 
     same columns and values doesn't exist in the right row set.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rightPlan" type="String"> 
	    The row set from the right view.
       </apidoc:param>
       <apidoc:param class="xquery" name="leftPlan" type="map:map">
	    The row set from the left view.
       </apidoc:param>
       <apidoc:param class="xquery" name="rightPlan" type="map:map">
	    The row set from the right view.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>except</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const tab1 = op.fromLiterals([
	              {id:1, val:'a'},
	              {id:2, val:'b'},
	              {id:3, val:'c'}
	              ]);
const tab2 = op.fromLiterals([
	              {id:1, val:'x'},
	              {id:2, val:'b'},
  	              {id:4, val:'n'},
	              {id:3, val:'c'}
	              ]);

tab2.except(tab1)
       .orderBy('id')
       .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $tab1 := op:from-literals((
   map:entry("id", 1) => map:with("val", "a"),
   map:entry("id", 2) => map:with("val", "b"),
   map:entry("id", 3) => map:with("val", "c")
   ))
let $tab2  := op:from-literals((
   map:entry("id", 1) => map:with("val", "x"),
   map:entry("id", 2) => map:with("val", "b"),
   map:entry("id", 3) => map:with("val", "c"),
   map:entry("id", 4) => map:with("val", "n")
   ))
return $tab2 
   => op:except($tab1)
   => op:order-by("id")
   => op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.except" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.except">
  </apidoc:method>

   <apidoc:function class="xquery" name="except" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.except">
  </apidoc:function>

 <apidoc:method name="prototype.joinDoc" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This function specifies a document column to add to the rows by reading the 
     documents for an existing source column having a value of a document uri 
     (which can be used to read other documents) or a fragment id 
     (which can be used to read the source documents for rows).
     <p>
     As long as the values of the column are the same as document uris, the document join will work. 
     If the document doesn't exist or the uri or fragment id is null in the row, the 
     row is dropped from the rowset.
     </p> 
     <p>
     You should minimize the number of documents retrieved by filtering or limiting rows 
     before joining documents.
     </p> 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
          The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="docCol" type="String"> 
	     The document column to add to the rows. This can be a string or column 
         specifying the name of the new column that should have the document as its value.
       </apidoc:param>
       <apidoc:param class="xquery" name="docCol" type="item()">
	     The document column to add to the rows.  This can be a string or column 
         specifying the name of the new column that should have the document as its value.
       </apidoc:param>
       <apidoc:param class="javascript" name="sourceCol" type="String"> 
	     The document uri or fragment id value. This is either an 
        <a href="#op.fragmentIdCol">op.fragmentIdCol</a> object specifying a 
         fragment id column or a document uri column.  Joining on a fragment id
         is more efficient than joining on a uri column.
       </apidoc:param>
       <apidoc:param class="xquery" name="sourceCol" type="item()">
	     The document uri or fragment id value. This is either the output from 
        <a href="#op:fragment-id-col">op:fragment-id-col</a> specifying a fragment 
         id column or a document uri column.  Joining on a fragment id
         is more efficient than joining on a uri column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>joinDoc</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromLiterals([
	          {id:1, val: 2, uri:'/employee1.json'},
	          {id:2, val: 4, uri:'/employee2.json'},
	          {id:3, val: 3, uri:'/employee3.json'},
	          {id:3, val: 6, uri:'/employee20.json'}  
	          ])
    .orderBy('id')
    .joinDoc(op.col('doc'), op.col('uri'))
    .result(); 
  ]]></pre></apidoc:example>

   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Returns the 'employee' and 'expense' source documents after the row data.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees', null, 'DocId');
const expenses = op.fromView('main', 'expenses', null, 'DocId2');

const Plan =
   employees.joinInner(expenses, op.on(employees.col('EmployeeID'),
                       expenses.col('EmployeeID'))) 
  .joinDoc('Employee', op.fragmentIdCol('DocId'))
  .joinDoc('Expenses', op.fragmentIdCol('DocId2'))
  .select([employees.col('EmployeeID'), 'FirstName', 'LastName',
           expenses.col('Category'), 'Amount', 
           'Employee', 'Expenses'])
  .orderBy(employees.col('EmployeeID'))
Plan.result(); 


  ]]></pre></apidoc:example>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Returns the 'employee' and 'expense' source documents after the row data.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees', null, 'DocId');
const expenses = op.fromView('main', 'expenses', null, 'DocId2');

const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'),
                                    expenses.col('EmployeeID'))) 
  .joinDocUri(op.col('employeeURI'), op.fragmentIdCol('docId'))
  .joinDocUri(op.col('expensesURI'), op.fragmentIdCol('docId2'))
  .joinDoc('Employee', op.col('employeeURI'))
  .joinDoc('Expenses', op.col('expensesURI'))
  .select([employees.col('EmployeeID'), 'FirstName', 'LastName',
           expenses.col('Category'), 'Amount', 
           'Employee', 'Expenses'])
Plan.result(); 


  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $tab1 := op:from-literals((
   map:entry("id", 1) => map:with("uri", "/employee1.json"),
   map:entry("id", 2) => map:with("uri", "/employee2.json"),
   map:entry("id", 3) => map:with("uri", "/employee3.json"),
   map:entry("id", 4) => map:with("uri", "/employee20.json")
   ))
return $tab1 
   => op:join-doc(op:col("doc"), op:col("uri"))
   => op:order-by("id")
   => op:result() 
  ]]></pre></apidoc:example>
   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view('main', 'employees', (),
                                op:fragment-id-col('docId'))
let $expenses := op:from-view('main', 'expenses', (),
                                op:fragment-id-col('docId2'))

return $employees
   => op:join-inner($expenses, op:on(
                op:view-col('employees', 'EmployeeID'),
                op:view-col('expenses', 'EmployeeID')))
   => op:join-doc('Employee', op:fragment-id-col('DocId'))
   => op:join-doc('Expenses', op:fragment-id-col('DocId2'))
   => op:select((op:view-col('employees', 'EmployeeID'), 
                'FirstName', 'LastName', 
                op:view-col('expenses', 'Category'),
                op:view-col('expenses', 'Amount'),
                'Employee', 'Expenses'))
   => op:order-by(op:view-col('employees', 'EmployeeID'))
   => op:result() 

(: Returns the 'employee' and 'expense' source documents after the row data. :)
  ]]></pre></apidoc:example>
   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view('main', 'employees', (),
                                op:fragment-id-col('docId'))
let $expenses := op:from-view('main', 'expenses', (),
                                op:fragment-id-col('docId2'))

return $employees
   => op:join-inner($expenses, op:on(
                op:view-col('employees', 'EmployeeID'),
                op:view-col('expenses', 'EmployeeID')))                
   => op:join-doc-uri(op:col('employeeURI'), op:fragment-id-col('docId'))
   => op:join-doc-uri(op:col('expensesURI'), op:fragment-id-col('docId2'))                
   => op:join-doc('Employee', op:col('employeeURI'))
   => op:join-doc('Expenses', op:col('expensesURI'))
   => op:select((op:view-col('employees', 'EmployeeID'), 
                'FirstName', 'LastName', 
                op:view-col('expenses', 'Category'),
                op:view-col('expenses', 'Amount'),
                'Employee', 'Expenses'))
   => op:order-by(op:view-col('employees', 'EmployeeID'))
   => op:result() 

(: Returns the 'employee' and 'expense' source documents after the row data. :)
  ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="prototype.joinDoc" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.joinDoc">
  </apidoc:method>

   <apidoc:function class="xquery" name="join-doc" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.joinDoc">
  </apidoc:function>

 
 <apidoc:method name="prototype.joinDocUri" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method adds a uri column to rows based on an existing fragment id column 
     to identify the source document for each row. The fragmentIdCol must be an
     <a class="javascript" href="#op.fragmentIdCol">op.fragmentIdCol</a>
     <a class="xquery" href="#op:fragment-id-col">op:fragment-id-col</a>
     specifying a fragment id column.  
     If the fragment id column is null in the row, the row is dropped from the rowset.
     <p>
     You should minimize the number of documents retrieved by filtering or limiting rows 
     before joining documents.
     </p> 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="uriCol" type="String"> 
	     The document uri. This is an
        <a href="#op.col">op.col('uri')</a> object specifying a document uri column.
       </apidoc:param>
       <apidoc:param class="xquery" name="uriCol" type="item()">
	     The document uri. This is the output from 
        <a href="#op:col">op:col('uri')</a> that specifies a document uri column.
       </apidoc:param>
       <apidoc:param class="javascript" name="fragmentIdCol" type="String"> 
	     The document fragment id value. This is an 
        <a href="#op.fragmentIdCol">op.fragmentIdCol</a> object specifying a 
         fragment id column.
       </apidoc:param>
       <apidoc:param class="xquery" name="fragmentIdCol" type="item()">
	     The document fragment id value. This is the output from 
        <a href="#op:fragment-id-col">op:fragment-id-col</a> specifying a fragment id column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">ModifyPlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>joinDocUri</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const empldocid = op.fragmentIdCol('empldocid'); 
const employees = op.fromView('main', 'employees', null, empldocid);

employees.joinDocUri(op.col('uri'), empldocid)
         .result(); 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $empldocid := op:fragment-id-col("empldocid") 
return op:from-view("main", "employees", (), $empldocid)
     => op:join-doc-uri(op:col("uri"),  $empldocid)
     => op:result()

  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.joinDocUri" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.joinDocUri">
  </apidoc:method>

   <apidoc:function class="xquery" name="join-doc-uri" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.joinDocUri">
  </apidoc:function>

  

  <apidoc:method name="prototype.prepare" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object">
   <apidoc:summary> 
     This method prepares the specified plan for execution as an optional final step before execution.
   </apidoc:summary>
  <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="xquery" name="optimize" type="xs:unsignedShort">
	      The optimization level, which can be 0, 1, or 2 (with 1 as the default).
       </apidoc:param>
       <apidoc:param class="javascript" name="optimize" type="String"> 
	      The optimization level, which can be 0, 1, or 2 (with 1 as the default).
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">PreparePlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>prepare</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

 employees.select()
    .prepare(2)
    .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees             
   => op:select(())
   => op:prepare(2) 
   => op:result()  
    
  ]]></pre></apidoc:example>

  </apidoc:method>


  <apidoc:method name="prototype.prepare" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="ModifyPlan.prototype.prepare">
  </apidoc:method>  

   <apidoc:function class="xquery" name="prepare" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="ModifyPlan.prototype.prepare">
  </apidoc:function>

 


  <apidoc:method name="prototype.map" object="PreparePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="PreparePlan Object">
   <apidoc:summary> 
     This method applies the specified function to each row returned by the plan to produce  
     a different result row.
   </apidoc:summary>
  <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="functionref" type="String"> 
	      The function to be appied.
       </apidoc:param>
       <apidoc:param class="xquery" name="mapper" type="function(item()) as item()*">
	      The function to be appied.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">IteratePlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>map</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
       <li><a href="/js/PreparePlan">PreparePlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView("main", "employees");
 
function secondsMapper(result) {
   result.seconds = new Date().getSeconds();
   return result;
}
  
employees.orderBy('EmployeeID')
	        .map(secondsMapper)
	        .result();
 
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
   => op:order-by("EmployeeID")
   => op:map(function($row as map:map) {
             map:with($row, "seconds", floor(seconds-from-dateTime(current-dateTime())))
      })
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.map" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object" 
          copy-content-from="PreparePlan.prototype.map">
  </apidoc:method>

  <apidoc:method name="prototype.map" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="PreparePlan.prototype.map">
  </apidoc:method>

   <apidoc:function class="xquery" name="map" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="PreparePlan.prototype.map">
  </apidoc:function>

 

  <apidoc:method name="prototype.reduce" object="PreparePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="PreparePlan Object">
   <apidoc:summary> 
     This method applies a function or the builtin reducer to each row returned 
     by the plan to produce a single result as with the <code>reduce()</code> method of 
     JavaScript Array.
     <p>
     The signature of the reducer must be <code>function(previous, row)</code>, 
     where <code>previous</code> is the seed on the first request and the return from the
     previous call on subsequent request and <code>row</code> is the current row.
     </p>
     <p class="javascript"> 
     The implementation of a <code>PreparePlan.prototype.reduce</code> method 
     can call <a href="#PreparePlan.prototype.map">prototype.map</a>
     methods to chain map calls with reduce calls.
     </p>
     <p class="xquery"> 
     The implementation of a <code>op:reduce</code> function 
     can call <a href="#op:map">op:map</a>
     functions to chain map calls with reduce calls.
     </p>
   </apidoc:summary>
  <apidoc:params>
      <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="functionref" type="String"> 
	      The function to be appied.
       </apidoc:param>
       <apidoc:param class="xquery" name="reducer" type="function(item()*, item()) as item()*">
	      The function to be appied.
       </apidoc:param>
       <apidoc:param class="javascript" name="seed" type="String" optional="true"> 
     	  The value returned by the previous request.
       </apidoc:param>
       <apidoc:param class="xquery" name="seed" type="item()*" optional="true">
    	  The value returned by the previous request.
       </apidoc:param> 
   </apidoc:params>
   <apidoc:return class="javascript">IteratePlan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
      <p>
      <code>reduce</code> is a method of the following classes: 
     </p>
   <ul>
       <li><a href="/js/AccessPlan">AccessPlan</a></li>
       <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
       <li><a href="/js/PreparePlan">PreparePlan</a></li>
   </ul> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
const employees = op.fromView("main", "employees");
 
function fibReducer(previous, result) {
	  const i = Array.isArray(previous) ? previous.length : 0;
	
	  result.i = i;
	
	  switch(i) {
	  case 0:
	    result.fib = 0;
	    break;
	  case 1:
	    result.fib = 1;
	    break;
	  default:
	    result.fib = previous[i - 2].fib + previous[i - 1].fib;
	    break;
	  }
	
	  if (i === 0) {
	    previous = [result];
	  } else {
	    previous.push(result);
	  }
	
	  return previous;
	}
	
employees.orderBy('EmployeeID')
       .reduce(fibReducer)
       .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
   => op:select("EmployeeID")
   => op:order-by("EmployeeID")
   => op:reduce(function($previous as json:array, $row as map:map) as json:array {
	       let $i := json:array-size($previous)
	           return json:array-with(
	               $previous,
	               map:with($row, "foo",  $i) => map:with("bar",
	                      switch($i)
	                      case 0  return 0
	                      case 1  return 1
	                      default return map:get($previous[$i - 1], "bar") + map:get($previous[$i], "bar"))
	            )
	   },
	   json:array())
   => op:result("value")
 
  ]]></pre></apidoc:example>

  </apidoc:method>

  <apidoc:method name="prototype.reduce" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object" 
          copy-content-from="PreparePlan.prototype.reduce">
  </apidoc:method>

  <apidoc:method name="prototype.reduce" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="PreparePlan.prototype.reduce">
  </apidoc:method>

   <apidoc:function class="xquery" name="reduce" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="PreparePlan.prototype.reduce">
  </apidoc:function>

 

  <apidoc:method name="prototype.result" object="IteratePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="IteratePlan Object">
   <apidoc:summary class="javascript"> 
      This method executes the plan (mapping or reducing, if specified) to generate the result,
      which is a plan, document plan, prepared plan, or map or reduce result plan.
     <p>
      Unless otherwise mapped or reduced, each row is returned as a 
      <a href="#sem.binding">sem.binding</a> object with a 
      property for each column that exists in the row. 
     </p>
   </apidoc:summary>
   <apidoc:summary class="xquery"> 
      This method executes the plan (mapping or reducing, if specified) to generate the result,
      which is a sequence of <code>map:map</code> or <code>json:array</code> rows, 
      unless mapped or reduced to different output.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="outputType" type="String"> 
        This parameter specifies the outputType as either "object" (the default)
        for a JavaScript object with keys of the column names and values of the 
        column values or "array" for a JavaScript array.
       </apidoc:param>
       <apidoc:param class="xquery" name="outType" type="xs:string?" optional="true">
        This parameter specifies the outputType as either "object" (the default)
        for a <code>map:map</code> sequence with keys of the column names and values of the 
        column values or "array" for a <code>json:array</code> with the list of column 
        names as an initial header and the column values in the same order for the subsequent rows.
       </apidoc:param>  
       <apidoc:param class="javascript" name="bindings" type="String" optional="true"> 
         This parameter provides a JavaScript literal object with the names and 
         values of placeholder parameters. An error is thrown if a placeholder parameter is not bound.
       </apidoc:param>
       <apidoc:param class="xquery" name="bindings" type="map:map" optional="true">
         This parameter provides a map with the names and 
         values of placeholder parameters. An error is thrown if a placeholder 
         parameter is not bound.
       </apidoc:param>
       <apidoc:param class="javascript" name="traceFlags" type="String" optional="true"> 
         This parameter specifies whether the trace flags (typically, those for the builtins) 
         are enabled while getting results.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">xs:string?</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>result</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
    <li><a href="/js/PreparePlan">PreparePlan</a></li>
    <li><a href="/js/IteratePlan">IteratePlan</a></li> 
   </ul>   
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
'Optic API for Relational Operations' in the <em>Application Developer's Guide</em>     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
op.fromView('main', 'employees')orderdef
   .select(['EmployeeID', 'FirstName', 'LastName'])
   .orderBy('EmployeeID')
   .result();
  ]]></pre></apidoc:example>


 
   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:result() 
  ]]></pre></apidoc:example>


  </apidoc:method>

  <apidoc:method name="prototype.result" object="PreparePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="PreparePlan Object" 
          copy-content-from="IteratePlan.prototype.result">
  </apidoc:method>

  <apidoc:method name="prototype.result" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object" 
          copy-content-from="IteratePlan.prototype.result">
  </apidoc:method>

  <apidoc:method name="prototype.result" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="IteratePlan.prototype.result">
  </apidoc:method>

   <apidoc:function class="xquery" name="result" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="IteratePlan.prototype.result">
  </apidoc:function>

   

  <apidoc:method name="prototype.export" object="IteratePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="IteratePlan Object">
   <apidoc:summary> 
      This method generates a serialized representation of the 
      Optic query to JSON so that it can
      be persisted as a file or used as a REST payload. 
      Only the Optic query can be exported, not the results of 
      executing an Optic query.
      A mapper or reducer function cannot be exported if it is an 
      anonymous function. The export for a named function identifies 
      the module path and function name.
    <p>For more information, 
 see <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2311208'>Exporting and Importing a Serialized Optic Query</a> in the <em>Application Developer's Guide</em></p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
          The Optic Plan to be exported.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>export</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
    <li><a href="/js/PreparePlan">PreparePlan</a></li>
    <li><a href="/js/IteratePlan">IteratePlan</a></li> 
   </ul>  
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
const op = require('/MarkLogic/optic');

const EmployeePlan =
  op.fromView('main', 'employees')
     .select(['EmployeeID', 'FirstName', 'LastName'])
     .orderBy('EmployeeID')
     const planObj = EmployeePlan.export();

xdmp.documentInsert("plan.json", planObj)

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $plan := op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:export()

return xdmp:document-insert("plan.json",  xdmp:to-json($plan))

  ]]></pre></apidoc:example>

  </apidoc:method>

 
 <apidoc:method name="prototype.export" object="PreparePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="PreparePlan Object" 
          copy-content-from="IteratePlan.prototype.export">
  </apidoc:method>

  <apidoc:method name="prototype.export" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object" 
          copy-content-from="IteratePlan.prototype.export">
  </apidoc:method>

  <apidoc:method name="prototype.export" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="IteratePlan.prototype.export">
  </apidoc:method>

   <apidoc:function class="xquery" name="export" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="IteratePlan.prototype.export">
  </apidoc:function>


  <apidoc:method name="import" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Parsing an Exported Plan">
   <apidoc:summary> 
      This function instantiates a plan from the JSON 
      representation of a plan that was exported by the 
      <a class="javascript" href="#IteratePlan.prototype.export">prototype.export</a> 
      <a class="xquery" href="#op:export">op:export</a> function.
    <p>For more information, 
 see <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2311208'>Exporting and Importing a Serialized Optic Query</a> in the <em>Application Developer's Guide</em></p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="exportedPlan" type="String"> 
         The plan to be imported.  This is generated by the
         <a href="#IteratePlan.prototype.export">prototype.export</a> function.
       </apidoc:param>
       <apidoc:param class="xquery" name="importablePlan" type="item()">
         The plan to be imported.  This is generated by the
         <a href="#op:export">op:export</a> function.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
op.import(cts.doc('plan.json').toObject()).result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:import(fn:doc('plan.json')/node())
   =>op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>

   <apidoc:function class="xquery" name="import" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.import">
  </apidoc:function>


  <apidoc:method name="toSource" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Functions for Parsing an Exported Plan">
   <apidoc:summary class="javascript"> 
      This function generates a server-side JavaScript source code representation of a plan from the 
      JSON or JavaScript literal object representation of a plan that was exported by the 
      <a href="#IteratePlan.prototype.export">prototype.export</a> function.
    <p>For more information, 
 see <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2311208'>Exporting and Importing a Serialized Optic Query</a> in the <em>Application Developer's Guide</em></p>
   </apidoc:summary>
   <apidoc:summary class="xquery"> 
      This function generates an XQuery source code representation of a plan from the 
      JSON or JavaScript literal object representation of a plan that was exported by the 
      <a href="#op:export">op:export</a> function.
    <p>For more information, 
 see <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/OpticAPI.xml%2311208'>Exporting and Importing a Serialized Optic Query</a> in the <em>Application Developer's Guide</em></p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="exportedPlan" type="String"> 
         The exported plan.  This is generated by the
         <a href="#IteratePlan.prototype.export">prototype.export</a> function.
       </apidoc:param>
       <apidoc:param class="xquery" name="importablePlan" type="item()">
         The exported plan.  This is generated by the
         <a href="#op:export">op:export</a> function.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">JavaScriptSource</apidoc:return>
   <apidoc:return class="xquery">XQuerySource</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Generate the server-side JavaScript source for the exported plan, 'plan.json'.

const op = require('/MarkLogic/optic');

op.toSource(cts.doc('plan.json'))
  ]]></pre></apidoc:example>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const EmployeePlan =
   op.fromView('main', 'employees')
     .select(['EmployeeID', 'FirstName', 'LastName'])
     .orderBy('EmployeeID')
const planObj = EmployeePlan.export();
   op.toSource(planObj)

=>

op.fromView('main', 'employees', null, null)
  .select([op.col('EmployeeID'), op.col('FirstName'), op.col('LastName')], null)
  .orderBy([op.col('EmployeeID')])
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Generate the XQuery source for the exported plan, 'plan.json'. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:to-source(fn:doc("plan.json"))
  ]]></pre></apidoc:example>
   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $plan := op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:export()

return op:to-source($plan)

=>

op:from-view("main", "employees")
=>op:select(("EmployeeID", "FirstName", "LastName"))
=>op:order-by(op:col("EmployeeID"))
  ]]></pre></apidoc:example>

  </apidoc:method>

   <apidoc:function class="xquery" name="to-source" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.toSource">
  </apidoc:function>


  <apidoc:method name="prototype.explain" object="IteratePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="IteratePlan Object">>
   <apidoc:summary> 
      This method returns a representation of the builtin execution plan.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="xquery" name="plan" type="map:map">
         The Optic Plan.  You can either use the XQuery
         => chaining operator or specify the variable that captures the 
         return value from the previous operation.
       </apidoc:param>
       <apidoc:param class="javascript" name="format" type="String"> 
         The format of the returned plan, expressed as
         a lower-case string.  This can be either <code>json</code> (default)
         or <code>xml</code>.
       </apidoc:param>
       <apidoc:param class="xquery" name="format" type="xs:string">
         The format of the returned plan, expressed as
         a lower-case string.  This can be either <code>xml</code> (default)
         or <code>json</code>.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">Plan</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
      <code>explain</code> is a method of the following classes: 
     </p>
   <ul>
    <li><a href="/js/AccessPlan">AccessPlan</a></li>
    <li><a href="/js/ModifyPlan">ModifyPlan</a></li>
    <li><a href="/js/PreparePlan">PreparePlan</a></li>
    <li><a href="/js/IteratePlan">IteratePlan</a></li> 
   </ul>  
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(['EmployeeID', 'FirstName', 'LastName'])
   .orderBy('EmployeeID')
   .explain();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:explain() 
  ]]></pre></apidoc:example>

  </apidoc:method>

 <apidoc:method name="prototype.explain" object="PreparePlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="PreparePlan Object" 
          copy-content-from="IteratePlan.prototype.explain">
  </apidoc:method>

  <apidoc:method name="prototype.explain" object="ModifyPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="ModifyPlan Object" 
          copy-content-from="IteratePlan.prototype.explain">
  </apidoc:method>

  <apidoc:method name="prototype.explain" object="AccessPlan" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="AccessPlan Object" 
          copy-content-from="IteratePlan.prototype.explain">
  </apidoc:method>

   <apidoc:function class="xquery" name="explain" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="IteratePlan.prototype.explain">
  </apidoc:function>


 <apidoc:method name="jsonDocument" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON document with the root content, which  
      must be exactly one JSON object or array node.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rootContent" type="object"> 
         The JSON object or array node used to construct the JSON document.
       </apidoc:param>
       <apidoc:param class="xquery" name="root" type="map:map">
         The JSON object or array node used to construct the JSON document.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">documentNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	            op:json-object((
	                op:prop("Position", op:json-string(op:col("Position"))),
	                op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                ))
	            ))
	  )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
 
   <apidoc:function class="xquery" name="json-document" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonDocument">
  </apidoc:function>
 


 <apidoc:method name="jsonObject" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON object with the specified properties.  The object 
      can be used as the value of a column in a row or passed to a builtin function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="properties" type="propertyDef"> 
         The properties to be used to contruct the object. This is constructed
         by the <a href="#op.prop">op.prop</a> function.
       </apidoc:param>
       <apidoc:param class="xquery" name="properties" type="map:map*">
         The properties to be used to contruct the object. This is constructed
         by the <a href="#op:prop">op:prop</a> function.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">objectValue</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	                 op:json-object((
	                    op:prop("Position", op:json-string(op:col("Position"))),
	                    op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                    ))
	                 ))
	  )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
 
   <apidoc:function class="xquery" name="json-object" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonObject">
  </apidoc:function>


 <apidoc:method name="prop" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function specifies the key expression and value content for a JSON 
      property of a JSON object contructed by the 
      <a class="javascript" href="#op.jsonObject">op.jsonObject</a> 
      <a class="xquery" href="#op:json-object">op:json-object</a> 
      function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The key expression. This must evaluate to a string.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="item()">
         The key expression. This must evaluate to a string.
       </apidoc:param>
       <apidoc:param class="javascript" name="content" type="String"> 
         The value content. This must be exactly one JSON node expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The value content. This must be exactly one JSON node expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">propertyDef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	                 op:json-object((
	                    op:prop("Position", op:json-string(op:col("Position"))),
	                    op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                    ))
	                 ))
	  )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
  
   <apidoc:function class="xquery" name="prop" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.prop">
  </apidoc:function>

 <apidoc:method name="jsonArray" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON array during row processing.
       The array can be used as the 
      value of a column in a row or passed to a builtin expression function.
      The node is constructed during processing of the plan, rather than 
      when building the plan.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="content" type="String"> 
         The JSON nodes for the array.
       </apidoc:param>
       <apidoc:param class="xquery" name="items" type="item()*">
         The JSON nodes for the array.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">arrayNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	                 op:json-object((
	                    op:prop("Position", op:json-string(op:col("Position"))),
	                    op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                    ))
	                 ))
	 )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
   
   <apidoc:function class="xquery" name="json-array" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonArray">
  </apidoc:function>

 <apidoc:method name="jsonString" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON text node with the specified value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="value" type="String"> 
         The value of the JSON text node.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The value of the JSON text node.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">textNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	                 op:json-object((
	                    op:prop("Position", op:json-string(op:col("Position"))),
	                    op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                    ))
	                 ))
	  )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
    
   <apidoc:function class="xquery" name="json-string" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonString">
  </apidoc:function>

 <apidoc:method name="jsonNumber" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON number node with the specified value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="value" type="String"> 
         The value of the JSON number node.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The value of the JSON number node.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numberNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .select(op.as('Employee', op.jsonDocument(
	              op.jsonObject([
	                  op.prop('Position', op.jsonString(op.col('Position'))),
	                  op.prop('ID', op.jsonArray([
	                      op.jsonNumber(op.col('EmployeeID'))
	                      ]))
	                  ])
	              )))
  .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:select(op:as("Employee", op:json-document(
	                 op:json-object((
	                    op:prop("Position", op:json-string(op:col("Position"))),
	                    op:prop("ID", op:json-array(
	                        op:json-number(op:col("EmployeeID"))
	                    ))
	                 ))
	  )))
   => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
     
   <apidoc:function class="xquery" name="json-number" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonNumber">
  </apidoc:function>

 <apidoc:method name="jsonBoolean" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON boolean node with the specified value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="value" type="String"> 
         The value of the JSON boolean node.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The value of the JSON boolean node.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.where(op.eq(op.col('gp'), 1))
	      .select(['row',
	               op.as('node', op.jsonArray([
	                 op.jsonString(op.col('str')), 
                     op.jsonNumber(op.col('num')), 
                     op.jsonBoolean(op.col('bool')), 
                     op.jsonNull()
	               ])),
	               op.as('kind', op.xdmp.nodeKind(op.col('node')))
	             ])
	      .orderBy('row')
          .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
   map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
   map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
   map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
   map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
   map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
   map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
   map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
   map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
   ))
      => op:where(op:eq(op:col("gp"), 1))
      => op:select(("row",
            op:as("node", op:json-array((
	                op:json-string(op:col("str")),
	                op:json-number(op:col("num")),
	                op:json-boolean(op:col("bool")),
	                op:json-null()
	        )))
         ))
      => op:order-by("row")
      => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
      
   <apidoc:function class="xquery" name="json-boolean" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonBoolean">
  </apidoc:function>

 <apidoc:method name="jsonNull" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs a JSON null node.
   </apidoc:summary>
   <apidoc:return class="javascript">nullNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.where(op.eq(op.col('gp'), 1))
	      .select(['row',
	               op.as('node', op.jsonArray([
	                 op.jsonString(op.col('str')), 
                     op.jsonNumber(op.col('num')), 
                     op.jsonBoolean(op.col('bool')), 
                     op.jsonNull()
	                ])),
	                op.as('kind', op.xdmp.nodeKind(op.col('node')))
	             ])
	      .orderBy('row')
          .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
   map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
   map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
   map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
   map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
   map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
   map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
   map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
   map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
   ))
      => op:where(op:eq(op:col("gp"), 1))
      => op:select(("row",
	           op:as("node", op:json-array((
	               op:json-string(op:col("str")),
	               op:json-number(op:col("num")),
	               op:json-boolean(op:col("bool")),
	               op:json-null()
	           )))
         ))
      => op:order-by("row")
      => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
       
   <apidoc:function class="xquery" name="json-null" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.jsonNull">
  </apidoc:function>

 <apidoc:method name="xmlDocument" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML document with the root content, which 
      must be exactly one node.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="rootContent" type="String"> 
         The XML node used to construct the XML document.
       </apidoc:param>
       <apidoc:param class="xquery" name="root" type="map:map">
         The XML node used to construct the XML document.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">documentNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.where(op.eq(op.col('gp'), 1))
        .select(['row', 
                 op.as('node', 
                       op.xmlDocument(
                          op.xmlElement(op.col('nm'), 
                                        null,
                                        op.xmlElement(op.col('str'), 
                                        null, 
                                        op.xmlText(op.col('bool')))
	                       )
	                )),
                 op.as('kind', op.xdmp.nodeKind(op.col('node')))
               ])
        .orderBy('row')
        .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
          map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
          map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
          map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
          map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
          map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
          map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
          map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
          map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
          ))
	          => op:where(op:eq(op:col("gp"), 1))
              => op:select(("row",
	                  op:as("node", op:xml-document(
	                      op:xml-element(op:col("nm"), (),
	                          op:xml-element(op:col("str"), (), op:xml-text(op:col("bool"))))
	               ))))
	           => op:order-by("row")
	           => op:result()
 
  ]]></pre></apidoc:example>

  </apidoc:method>
        
   <apidoc:function class="xquery" name="xml-document" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlDocument">
  </apidoc:function>

 <apidoc:method name="xmlElement" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML element with the name (which can be a string or QName), 
      zero or more attributes, and child content.  
      The child content can include a sequence or array of atomic values or an element, 
      comment, or processing instruction nodes. Atomic values are converted to text nodes.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The string or QName for the constructed element.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="item()">
         The string or QName for the constructed element.
       </apidoc:param>
       <apidoc:param class="javascript" name="attributeValue" type="attributeNode" optional="true"> 
         Any element attributes returned from <a href="#op.xmlAttribute">op.xmlAttribute</a>,
         or <code>null</code> if no attributes.
       </apidoc:param>
       <apidoc:param class="xquery" name="attributes" type="map:map*" optional="true">
         Any element attributes returned from <a href="#op:xml-attribute">op:xml-attribute</a>,
         or <code>null</code> if no attributes.
       </apidoc:param>
       <apidoc:param class="javascript" name="childContent" type="String" optional="true"> 
         A sequence or array of atomic values or an element, 
         a comment from <a href="#op.xmlComment">op.xmlComment</a>, 
         or processing instruction nodes from <a href="#op.xmlPI">op.xmlPI</a>.
       </apidoc:param>
       <apidoc:param class="xquery" name="content" type="item()*" optional="true">
         A sequence or array of atomic values or an element, 
         a comment from <a href="#op:xml-comment">op:xml-comment</a>, 
         or processing instruction nodes from <a href="#op:xml-pi">op:xml-pi</a>.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">elementNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.where(op.eq(op.col('gp'), 1))
        .select(['row', 
                 op.as('node', 
                       op.xmlDocument(
                          op.xmlElement(op.col('nm'), 
                                        null,
                                        op.xmlElement(op.col('str'), 
                                        null, 
                                        op.xmlText(op.col('bool')))
	                       )
	                )),
                 op.as('kind', op.xdmp.nodeKind(op.col('node')))
               ])
        .orderBy('row')
        .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
          map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
          map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
          map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
          map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
          map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
          map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
          map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
          map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
          ))
	          => op:where(op:eq(op:col("gp"), 1))
              => op:select(("row",
	                  op:as("node", op:xml-document(
	                      op:xml-element(op:col("nm"), (),
	                          op:xml-element(op:col("str"), (), op:xml-text(op:col("bool"))))))
	               ))
	          => op:order-by("row")
	          => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
         
   <apidoc:function class="xquery" name="xml-element" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlElement">
  </apidoc:function>

 <apidoc:method name="xmlAttribute" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML attribute with the name (which 
      can be a string or QName) and atomic value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The attribute name.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="item()">
         The attribute name.
       </apidoc:param>
       <apidoc:param class="javascript" name="value" type="String"> 
         The attribute value.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The attribute value.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">attributeNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.select(['gp',
                 op.as('re', op.xmlElement('relem', [
                         op.xmlAttribute('row', op.col('row')),
                         op.xmlAttribute('nm', op.col('nm')),
                         op.xmlAttribute('num', op.col('num'))
                         ]))
               ])
        .groupBy('gp', op.sequenceAggregate('rs', 're'))
        .orderBy('gp')
        .select(op.as('container', 
                      op.xmlElement('gelem',
	                                 op.xmlAttribute('group', op.col('gp')),
	                                 op.xmlElement('rows', op.col('rs'))
	                    ))
	             )
        .result();        
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
          map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
          map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
          map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
          map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
          map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
          map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
          map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
          map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
          ))
             => op:select(("gp",
	                  op:as("re", op:xml-element("relem", (
	                      op:xml-attribute("row", op:col("row")),
	                      op:xml-attribute("nm",  op:col("nm")),
	                      op:xml-attribute("num", op:col("num"))
	                      ))
	                  )))
	          => op:group-by("gp", op:sequence-aggregate("rs", "re"))
	          => op:order-by("gp")
	          => op:select(op:as("container", op:xml-element("gelem",
	                      op:xml-attribute("group", op:col("gp")),
	                      op:xml-element("rows", (), op:col("rs"))
	                      )))
	          => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
          
   <apidoc:function class="xquery" name="xml-attribute" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlAttribute">
  </apidoc:function>

 <apidoc:method name="xmlText" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML text node with the specified value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="value" type="String"> 
         The value of the XML text node.
       </apidoc:param>
       <apidoc:param class="xquery" name="content" type="item()">
         The value of the XML text node.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">textNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
	          ])
literals.where(op.eq(op.col('gp'), 1))
        .select(['row', 
                 op.as('node', 
                       op.xmlDocument(
                          op.xmlElement(op.col('nm'), null,
                                        op.xmlElement(op.col('str'), null, 
                                            op.xmlText(op.col('bool')))
	                       )
	                )),
                 op.as('kind', op.xdmp.nodeKind(op.col('node')))
               ])
        .orderBy('row')
        .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
          map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
          map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
          map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
          map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
          map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
          map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
          map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
          map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
          ))
	          => op:where(op:eq(op:col("gp"), 1))
              => op:select(("row",
	                  op:as("node", op:xml-document(
	                      op:xml-element(op:col("nm"), (),
	                          op:xml-element(op:col("str"), (),
                                   op:xml-text(op:col("bool"))))))
	               ))
	          => op:order-by("row")
	          => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
           
   <apidoc:function class="xquery" name="xml-text" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlText">
  </apidoc:function>

 <apidoc:method name="xmlComment" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML comment with the atomic value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="value" type="String"> 
         The comment text.
       </apidoc:param>
       <apidoc:param class="xquery" name="content" type="item()">
         The comment text.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">commentNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
          
employees.where(op.gt(op.col('EmployeeID'), 1))
        .select(['EmployeeID', 
                 op.as('node', 
                       op.xmlComment(op.col('Position'))), 
                 op.as('kind', 
                       op.xdmp.nodeKind(op.col('node')))
                ])
        .orderBy('EmployeeID')
        .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
           => op:select(("EmployeeID", op:as("node", op:xml-comment(op:col("Position")))))
           => op:order-by("EmployeeID")
           => op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>
            
   <apidoc:function class="xquery" name="xml-comment" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlComment">
  </apidoc:function>

 <apidoc:method name="xmlPI" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function constructs an XML processing instruction with the atomic value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The name of the processing instruction.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="item()">
         The name of the processing instruction.
       </apidoc:param>
       <apidoc:param class="javascript" name="value" type="String"> 
         The value of the processing instruction.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()">
         The value of the processing instruction.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">processingInstructionNode</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {row:1, gp: 1, nm:"alpha", str:"a", num:10, bool:true},
            {row:2, gp: 1, nm:"beta", str:"b", num:20, bool:false},
            {row:3, gp: 2, nm:"gamma", str:"c", num:30, bool:true},
            {row:4, gp: 2, nm:"delta", str:"d", num:40, bool:false}
            ])
literals.where(op.eq(op.col('gp'), 1))
        .select(['row', 
                 op.as('node', op.xmlPI(op.col('str'), op.col('node')) )
                ])
        .orderBy('row')
        .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
          map:entry("row",1)=>map:with("gp",1)=>map:with("nm","alpha")=>
          map:with("str","a")=>map:with("num",10)=>map:with("bool", true()  ),
          map:entry("row",2)=>map:with("gp",1)=>map:with("nm","beta" )=>
          map:with("str","b")=>map:with("num",20)=>map:with("bool", false() ),
          map:entry("row",3)=>map:with("gp",2)=>map:with("nm","gamma")=>
          map:with("str","c")=>map:with("num",30)=>map:with("bool", true()  ),
          map:entry("row",4)=>map:with("gp",2)=>map:with("nm","delta")=>
          map:with("str","d")=>map:with("num",40)=>map:with("bool", false() )
          ))
                => op:select(("row", 
                      op:as("node", op:xml-pi(op:col("str"), op:col("num"))) 
	               ))
	            => op:order-by("row")
	            => op:result()
  
  ]]></pre></apidoc:example>

  </apidoc:method>
             
   <apidoc:function class="xquery" name="xml-pi" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xmlPI">
  </apidoc:function>

 <apidoc:method name="xpath" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Node Constructor Functions">
   <apidoc:summary> 
      This function extracts a sequence of child nodes from a column with node values --
      especially, the document nodes from a document join. The path is an XPath (specified 
      as a string) to apply to each node to generate a sequence of nodes as an
      expression value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The name of the column from which to extract the child nodes.
       </apidoc:param>
       <apidoc:param class="xquery" name="column" type="item()">
         The name of the column from which to extract the child nodes.
       </apidoc:param>
       <apidoc:param class="javascript" name="path" type="String"> 
         An XPath (specified as a string) to apply to each node.
       </apidoc:param>
       <apidoc:param class="xquery" name="path" type="xs:string">
         An XPath (specified as a string) to apply to each node.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">nodeValue</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const literals = op.fromLiterals([
            {id:1, val: 2, uri:"/employee1.json"},
            {id:2, val: 4, uri:"/employee2.json"},
            {id:3, val: 6, uri:"/employee3.json"},
            {id:4, val: 8, uri:"/employee4.json"}
            ])
literals.orderBy('id')
	        .joinDoc(op.col('doc'), op.col('uri'))
	        .select(['id', 'val', 'uri', 
                   op.as('EmployeeID', op.xpath('doc', '/(Employee/ID|Expenses/EmployeeID)'))
                  ])
	        .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
	              map:entry("id", 1) => map:with("val", 2) => map:with("uri", "/employee1.json"),
	              map:entry("id", 2) => map:with("val", 4) => map:with("uri", "/employee3.json"),
	              map:entry("id", 3) => map:with("val", 6) => map:with("uri", "/expense4.json")
	              ))
	            => op:order-by("id")
	            => op:join-doc(op:col("doc"), op:col("uri"))
	            => op:select(("id", "val", "uri", 
                            op:as("EmployeeID", op:xpath("doc", "/(Employee/ID|Expenses/EmployeeID)"))
                          ))
	            => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
              
   <apidoc:function class="xquery" name="xpath" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.xpath">
  </apidoc:function>


   <apidoc:method name="avg" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function averages the non-null values of the column for the rows in 
     the group or row set. The result is used for building the parameters used by the 
      <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a> 
      <a class="xquery" href="#op:group-by">op:group-by</a> 
      function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The column to be aggregated.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The column to be aggregated.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.avg("Average Amount", "Amount"))
   .orderBy('Category')
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	          => op:group-by("Category", op:avg("Average Amount", "Amount"))           
	          => op:order-by("Category")
	          => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
              
   <apidoc:function class="xquery" name="avg" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.avg">
  </apidoc:function>
 

   <apidoc:method name="count" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function counts the rows where the specified input column has a value. If the input column 
    is omitted, all rows in the group or row set are counted.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the column values.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
        The name to be used for the column values.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String" optional="true"> 
         The columns to be counted.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()" optional="true">
         The columns to be counted.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.count("Number of Expenses", "Amount"))
   .orderBy('Category')
   .result();
   
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	          => op:group-by("Category", op:count("Number of Expenses", "Amount"))           
	          => op:order-by("Category")
	          => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>
              
   <apidoc:function class="xquery" name="count" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.count">
  </apidoc:function>
 


   <apidoc:method name="groupConcat" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function concatenates the non-null values of the column for the rows in the 
     group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for column with the concatenated values.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for column with the concatenated values.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The name of the column with the values to be concatenated for the group. 
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The name of the column with the values to be concatenated for the group. 
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
         In addition to the <code>values</code> key, the options can take 
         a <code>separator</code> key specifying a separator character.  The value 
         can be a string or placeholder parameter.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
         In addition to the <code>values</code> key, the options can take 
         a <code>separator</code> key specifying a separator character.  The value 
         can be a string or placeholder parameter.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.groupConcat("Spent", "Amount"))
   .orderBy('Category')
   .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	     => op:group-by("Category", 
                   op:group-concat("Spent", "Amount", map:entry("separator","-") 
                   => map:with("values","distinct")))
	     => op:order-by("Category")
	     => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
              
   <apidoc:function class="xquery" name="group-concat" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.groupConcat">
  </apidoc:function>


   <apidoc:method name="max" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function gets the largest non-null value of the column for the 
     rows in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the largest value.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the largest value.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The group or row set.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The group or row set.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.max("Maximum Spent", "Amount"))
   .orderBy('Category')
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	          => op:group-by("Category", op:max("Maximum Spent", "Amount"))           
	          => op:order-by("Category")
	          => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
               
   <apidoc:function class="xquery" name="max" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.max">
  </apidoc:function>

   <apidoc:method name="min" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function gets the smallest non-null value of the column for 
     the rows in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the smallest value.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the smallest value.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The group or row set.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The group or row set.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.min("Minimum Spent", "Amount"))
   .orderBy('Category')
   .result();
  ]]></pre></apidoc:example>


   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	          => op:group-by("Category", op:min("Minimum Spent", "Amount"))           
	          => op:order-by("Category")
	          => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                
   <apidoc:function class="xquery" name="min" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.min">
  </apidoc:function>
 


   <apidoc:method name="sample" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function randomly selects one non-null value of the column from 
     the rows in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the value.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the value.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The group or row set.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The group or row set.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.sample("Sample Spent", "Amount"))
   .orderBy('Category')
   .result();
   
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
	          => op:group-by("Category", op:sample("Sample Spent", "Amount"))           
	          => op:order-by("Category")
	          => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>
                
   <apidoc:function class="xquery" name="sample" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.sample">
  </apidoc:function>

   <apidoc:method name="sum" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function adds the non-null values of the column for the 
     rows in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
     <p>
     The <a class="javascript" href="#op.sum">op.sum</a>
     <a class="xquery" href="#op:sum">op:sum</a> function differs from the 
     <a class="javascript" href="#op.add">op.add</a>
     <a class="xquery" href="#op:add">op:add</a> function in that it operates on 
     operates on a group of rows, rather than multiple column values in a row.
     </p>
   </apidoc:summary>
  <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The column with the values to add.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The column with the values to add.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Calculate the total expenses for each employee and return results in order of employee number.

const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');
const expenses = op.fromView('main', 'expenses');
const totalexpenses  = op.col('totalexpenses');
const Plan =
employees.joinInner(expenses, op.on(employees.col('EmployeeID'), expenses.col('EmployeeID')))   
   .groupBy(employees.col('EmployeeID'), ['FirstName', 'LastName', 
    op.sum(totalexpenses, expenses.col('Amount'))])
   .orderBy('EmployeeID')
Plan.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
let $expenses  := op:from-view("main", "expenses")
let $totalexpenses  := op:col("totalexpenses")
return $employees
   => op:join-inner($expenses, op:on(
                    op:view-col("employees", "EmployeeID"),
                    op:view-col("expenses", "EmployeeID")))
   => op:group-by(op:view-col("employees", "EmployeeID"),
                 ("FirstName", "LastName", 
                  op:sum($totalexpenses, 
                  op:view-col("expenses", "Amount"))))
   => op:order-by(op:view-col("employees", "EmployeeID")) 
   => op:result()
  ]]></pre></apidoc:example>

  </apidoc:method>
                 
   <apidoc:function class="xquery" name="sum" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.sum">
  </apidoc:function>
 


   <apidoc:method name="uda" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>

    This function processes the values of column for each row in the group or row set
    with the specified user-defined aggregate as implemented by an aggregate user-defined
    function (UDF) plugin. The UDF plugin must be installed on each host.
    The result is used for building the parameters used by the 
    <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
    <a class="xquery" href="#op:group-by">op:group-by</a> function.
    <p>
    For more information on UDF functions, see 
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/aggregateUDFs.xml%2335455'>Aggregate User-Defined Functions</a> in the <em>Application Developer's Guide</em>.
   </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the aggregated column. 
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The column with the values to aggregate.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The column with the values to aggregate.
       </apidoc:param>
       <apidoc:param class="javascript" name="module" type="String"> 
         The path to the installed plugin module.
       </apidoc:param>
       <apidoc:param class="xquery" name="module-path" type="xs:string">
         The path to the installed plugin module.
       </apidoc:param>
       <apidoc:param class="javascript" name="function" type="String"> 
         The name of the UDF function. 
       </apidoc:param>
       <apidoc:param class="xquery" name="func-name" type="xs:string">
         The name of the UDF function. 
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a <code>values</code> key with a distinct value to average the distinct
         values of the column and an <code>arg</code> key specifying an argument for the 
         user-defined aggregate. The value can be a string or placeholder parameter.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a <code>values</code> key with a distinct value to average the distinct
         values of the column and an <code>arg</code> key specifying an argument for the 
         user-defined aggregate. The value can be a string or placeholder parameter.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
 
      const plan1 =
        op.fromView('main', 'employees')
          .orderBy(op.schemaCol('main', 'employees', 'EmployeeID'));
      const plan2 =
        op.fromView('main', 'expenses')
          .orderBy(op.schemaCol('main', 'expenses' , 'EmployeeID'));
      const output =
        plan1.joinInner(plan2)
        .where(
          op.eq(
            op.schemaCol('main', 'employees' , 'EmployeeID'),
            op.schemaCol('main', 'expenses', 'EmployeeID')
          )
        )
        .groupBy(op.schemaCol('main', 'employees', 'EmployeeID'), 
                 op.uda('DetailSum', op.schemaCol('main', 'expenses', 'Amount'), 
                        'sampleplugin/sampleplugin', 'sum'))
        .orderBy(op.desc(op.col('DetailSum')))
        .result();
      output;

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version '1.0-ml';

import module namespace op = 'http://marklogic.com/optic'
      at 'MarkLogic/optic.xqy';
      
      let $plan1 :=
        op:from-view('main', 'employees')
          => op:order-by(op:schema-col('main', 'employees', 'EmployeeID'))
      let $plan2 :=
        op:from-view('main', 'expenses')
          => op:order-by(op:schema-col('main', 'expenses' , 'EmployeeID'))
      return
        op:join-inner($plan1, $plan2)
        => op:where(
             op:eq(
               op:schema-col('main', 'employees' , 'EmployeeID'),
               op:schema-col('main', 'expenses', 'EmployeeID')
             )
           )
        => op:group-by(op:schema-col('main', 'employees', 'EmployeeID'), 
                       op:uda('DetailSum', op:schema-col('main', 'expenses', 'Amount'), 
                      'sampleplugin/sampleplugin', 'sum'))
        => op:order-by(op:desc(op:col('DetailSum')))
        => op:result()
 
  ]]></pre></apidoc:example>

  </apidoc:method>
                 
   <apidoc:function class="xquery" name="uda" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.uda">
  </apidoc:function>
 



   <apidoc:method name="arrayAggregate" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This function constructs an array whose items are the result of evaluating 
     the column for each row in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The columns to be aggregated.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The columns to be aggregated.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.arrayAggregate("Expense Array", "Amount"))
   .orderBy('Category')
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
    => op:group-by("Category", op:array-aggregate("Expense Array", "Amount"))           
    => op:order-by("Category")
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                 
   <apidoc:function class="xquery" name="array-aggregate" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.arrayAggregate">
  </apidoc:function>
 


   <apidoc:method name="sequenceAggregate" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Aggregate Functions for Building groupBy Parameters">
   <apidoc:summary>
     This call constructs a sequence whose items are the values of a column 
     for each row in the group or row set.
     The result is used for building the parameters used by the 
     <a class="javascript" href="#ModifyPlan.prototype.groupBy">prototype.groupBy</a>
     <a class="xquery" href="#op:group-by">op:group-by</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="aggColName" type="String"> 
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="xquery" name="outCol" type="item()">
         The name to be used for the aggregated column.
       </apidoc:param>
       <apidoc:param class="javascript" name="columndef" type="String"> 
         The column with the values to aggregate.
       </apidoc:param>
       <apidoc:param class="xquery" name="inCol" type="item()">
         The column with the values to aggregate.
       </apidoc:param>
       <apidoc:param class="javascript" name="options" type="String" optional="true"> 
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
       <apidoc:param class="xquery" name="options" type="map:map?" optional="true">
         The options can take a values key with a distinct value to average 
         the distinct values of the column.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">aggregatedef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
  
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'expenses')
   .groupBy('Category', op.sequenceAggregate("Sequence Array", "Amount"))
   .orderBy('Category')
   .result();
   
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $expenses := op:from-view("main", "expenses")
 
return $expenses
    => op:group-by("Category", op:sequence-aggregate("Sequence Array", "Amount"))           
    => op:order-by("Category")
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                 
   <apidoc:function class="xquery" name="sequence-aggregate" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.sequenceAggregate">
  </apidoc:function>
 

 <apidoc:method name="eq" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the left and right expressions
     return the same value.   Otherwise, it returns 
     <code>false</code>.  In expressions, the call should pass the result from an
     <a class="javascript" href="#op.col">op.col</a> 
     <a class="xquery" href="#op:col">op:col</a> function to identify a column. 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromView('main', 'employees')
   .where(op.eq(op.col('EmployeeID'), 3))
   .select(['EmployeeID', 'FirstName', 'LastName'])
   .orderBy('EmployeeID')
   .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-view("main", "employees")
   => op:where(op:eq(op:col("EmployeeID"), 3))
   => op:select(("EmployeeID", "FirstName", "LastName"))
   => op:order-by("EmployeeID")
   => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                  
   <apidoc:function class="xquery" name="eq" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.eq">
  </apidoc:function>
 


 <apidoc:method name="gt" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the value of the left expression is 
     greater than the value of the right expression.  Otherwise, it returns 
     <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.gt(employees.col('EmployeeID'), 3))
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:gt(op:view-col("employees", "EmployeeID"), 3))
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                  
   <apidoc:function class="xquery" name="gt" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.gt">
  </apidoc:function>
 

 <apidoc:method name="ge" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the value of the left expression is 
     greater than or equal to the value of the right expression.  Otherwise, it returns 
     <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.ge(employees.col('EmployeeID'), 3))
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:ge(op:view-col("employees", "EmployeeID"), 3))
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
                  
   <apidoc:function class="xquery" name="ge" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.ge">
  </apidoc:function>


 <apidoc:method name="lt" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the value of the left expression is 
     less than the value of the right expression.  Otherwise, it returns 
     <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.lt(employees.col('EmployeeID'), 3))
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:lt(op:view-col("employees", "EmployeeID"), 3))
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
 
                  
   <apidoc:function class="xquery" name="lt" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.lt">
  </apidoc:function>

 <apidoc:method name="le" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the value of the left expression is 
     less than or equal to the value of the right expression.  Otherwise, it returns 
     <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.le(employees.col('EmployeeID'), 3))
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:le(op:view-col("employees", "EmployeeID"), 3))
    => op:result()  
  ]]></pre></apidoc:example>

  </apidoc:method>
  
                  
   <apidoc:function class="xquery" name="le" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.le">
  </apidoc:function>
 
 

 <apidoc:method name="ne" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if the value of the left expression is 
     not equal to the value of the right expression.  Otherwise, it returns 
     <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The right value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.ne(employees.col('EmployeeID'), 3))
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:ne(op:view-col("employees", "EmployeeID"), 3))
    => op:result() 
  ]]></pre></apidoc:example>

  </apidoc:method>
 
                  
   <apidoc:function class="xquery" name="ne" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.ne">
  </apidoc:function>
  

 <apidoc:method name="and" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary class="javascript"> 
     This function returns <code>true</code> if the specified boolean expressions 
     all return <code>true</code>.  Otherwise, it returns <code>false</code>.
   </apidoc:summary>
   <apidoc:summary class="xquery"> 
     This function returns <code>true</code> if the specified expressions 
     all return <code>true</code>.  Otherwise, it returns <code>false</code>.
     You can either compair 
     <p>
     As a convenience, you can pass a sequence of any number of expressions as the 
     first argument: <code>op:and((expr1, expr2, ..., exprN))</code>
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         Two or more boolean expressions.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>         
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.and(op.eq(op.col('EmployeeID'), 3), 
                       op.eq(op.col('FirstName'), 'Steve')))
.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:and(op:gt(op:col("EmployeeID"), 2),
                op:eq(op:col("FirstName"), 'Steve')))
    => op:result()   

  ]]></pre></apidoc:example>

  </apidoc:method>
                  
   <apidoc:function class="xquery" name="and" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.and">
  </apidoc:function>

 <apidoc:method name="or" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary class="javascript"> 
     This function returns <code>true</code> if either of the specified boolean expressions 
     return <code>true</code>.  Otherwise, it returns <code>false</code>.
   </apidoc:summary>
   <apidoc:summary class="xquery"> 
     This function returns <code>true</code> if the specified expressions 
     all return <code>true</code>.  Otherwise, it returns <code>false</code>.
     <p>
     As a convenience, you can pass a sequence of any number of expressions as the 
     first argument: <code>op:or((expr1, expr2, ..., exprN))</code>
     </p> 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         One or more boolean expressions.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>     
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');
 
employees.where(op.or(op.gt(op.col('EmployeeID'), 3),  
                      op.eq(op.col('FirstName'), 'Steve')))
.result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:where(op:or(op:gt(op:col("EmployeeID"), 3), 
                op:eq(op:col("FirstName"), 'Steve')))
    => op:result()   
             
  ]]></pre></apidoc:example>

  </apidoc:method>
                   
   <apidoc:function class="xquery" name="or" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.or">
  </apidoc:function>

 <apidoc:method name="not" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns <code>true</code> if neither of the specified boolean expressions 
     return <code>true</code>.  Otherwise, it returns <code>false</code>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         Exactly one boolean expression.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="operand" type="item()">
         Exactly one boolean expression, such as 
         <a href="#op:and">op:and</a> or <a href="#op:or">op:or</a>,
         or <a href="#op:is-defined">op:is-defined</a>.
       </apidoc:param>  
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
op.fromLiterals([
            {group:1, val:2},
            {group:1, val:4},
            {group:2, val:3},
            {group:2, val:5},
            {group:2, val:7}
            ])
          .where(op.not(op.eq(op.col('group'), 2)))
          .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
    map:entry("group", 1) => map:with("val", 2),
    map:entry("group", 1) => map:with("val", 4),
    map:entry("group", 2) => map:with("val", 3),
    map:entry("group", 2) => map:with("val", 5),
    map:entry("group", 2) => map:with("val", 7)
    ))
        => op:where(op:not(op:eq(op:col("group"), 2)))
        => op:result()   
             
  ]]></pre></apidoc:example>

  </apidoc:method>
                    
   <apidoc:function class="xquery" name="not" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.not">
  </apidoc:function>

 <apidoc:method name="case" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function returns the specified <code>valueExpression</code> if  
     the specified <code>valueExpression</code> is <code>true</code>.  
     Otherwise, it returns null.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="whenExpression" type="String"> 
         One or more <a href="#op.when">op.when</a> expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="when" type="map:map+">
         One or more <a href="#op:when">op:when</a> expressions.
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The value expression to return if none of the
         <a href="#op.when">op.when</a> expressions is <code>true</code>.
       </apidoc:param>
       <apidoc:param class="xquery" name="otherwise" type="item()*">
         The value expression to return  if none of the
         <a href="#op:when">op:when</a> expressions is <code>true</code>.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">valueExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(['EmployeeID', op.as('cased', op.case([
                   op.when(op.eq(op.col('EmployeeID'), 2), 'second'),
                   op.when(op.eq(op.col('EmployeeID'), 3), 'third')],
                   'otherwise'))])
          .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("EmployeeID", op:as("cased", op:case((
	              op:when(op:eq(op:col("EmployeeID"), 2), "second"),
	              op:when(op:eq(op:col("EmployeeID"), 3), "third")),
	              "otherwise"
	   ))))
    => op:result()    
  ]]></pre></apidoc:example>

  </apidoc:method>
                     
   <apidoc:function class="xquery" name="case" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.case">
  </apidoc:function>

 <apidoc:method name="when" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
     This function executes the specified expression if the specified condition is <code>true</code>
     for the row. Otherwise, the expression is not executed and the next 'when' test is checked 
     or, if there is no next 'when' text, the otherwise expression for the
     <a class="javascript" href="#op.case">op.case</a>
     <a class="xquery" href="#op:case">op:case</a> expression is executed.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         A boolean expression.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="condition" type="item()">
         A boolean expression.  
       </apidoc:param>
       <apidoc:param class="javascript" name="valueExpression" type="String"> 
         The value expression to return if the boolean expression is 
         <code>true</code>.
       </apidoc:param>
       <apidoc:param class="xquery" name="value" type="item()*">
         The value expression to return if the boolean expression is 
         <code>true</code>.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">whenExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(['EmployeeID', op.as('cased', op.case([
                   op.when(op.eq(op.col('EmployeeID'), 2), 'second'),
                   op.when(op.eq(op.col('EmployeeID'), 3), 'third')],
                   'otherwise'))])
          .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("EmployeeID", op:as("cased", op:case((
	              op:when(op:eq(op:col("EmployeeID"), 2), "second"),
	              op:when(op:eq(op:col("EmployeeID"), 3), "third")),
	              "otherwise"
	   ))))
    => op:result()    
  ]]></pre></apidoc:example>

  </apidoc:method>
                      
   <apidoc:function class="xquery" name="when" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.when">
  </apidoc:function>
 
 <apidoc:method name="isDefined" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
    This function tests whether the value of an expression is null in the row
    where the expression might be as simple as a column identified by
     <a class="javascript" href="#op.col">op.col</a> 
     <a class="xquery" href="#op:col">op:col</a>.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         A boolean expression that might be null.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="operand" type="item()"> 
         A boolean expression, such as
         <a href="#op:eq">op:eq</a> or <a href="#op:not">op:not</a>, 
         that might be null.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">booleanExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

op.fromLiterals([
	            {row:1, sparse:6},
	            {row:2},
	            {row:3, sparse:4}
	            ])
	          .select(['row', 'sparse',
	              op.as('defcheck', op.sem.if(op.isDefined(op.col('sparse')), 'present', 'absent'))
	              ])
	          .result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";
import module namespace osem="http://marklogic.com/optic/expression/sem"
     at "/MarkLogic/optic/optic-sem.xqy"; 
     
op:from-literals((
    map:entry("row", 1) => map:with("sparse", 6),
    map:entry("row", 2),
    map:entry("row", 3) => map:with("sparse", 4)
    ))
        => op:select(("row", "sparse", op:as("defcheck",
	               osem:if(op:is-defined(op:col("sparse")), "present", "absent")
	       )))
        => op:result()
 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="is-defined" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.isDefined">
  </apidoc:function>




 <apidoc:method name="sqlCondition" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Boolean Expression Functions">
   <apidoc:summary> 
    This function returns a filter definition as input for a <code>WHERE</code> operation. 
    As with a <a class="javascript" href="#cts.query">cts.query</a> 
    <a class="xquery" href="#cts:query">cts:query</a>
    or <a class="javascript" href="#sem.store">sem.store</a> 
    <a class="xquery" href="#sem:store">sem:store</a>, the filter definition 
    cannot be used in an Optic Boolean expression but, instead, must be the only argument
    to the <code>WHERE</code> call. Add a separate <code>WHERE</code> call to filter 
    based on an Optic Boolean expression.
    The condition must be a valid simple SQL Boolean expression expressed as a string.
    <p> 
    The expression may use literals, column references, SQL operators, and core SQL 
    functions but to limit exposure to injection attacks, may not use nested SELECT 
    statements or arbitrary builtin function calls.
    </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="booleanExpression" type="xs.boolean"> 
         A boolean expression that might be null.  See 
         <a href="/js/op/boolean-expression-functions">Boolean Expression Functions</a>
         for the list of functions used to build boolean expressions.
       </apidoc:param>
       <apidoc:param class="xquery" name="operand" type="item()"> 
         A boolean expression, such as
         <a href="#op:eq">op:eq</a> or <a href="#op:not">op:not</a>, 
         that might be null.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">filterdef</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage>
     <p>
     A boolean SQL expression that supports subqueries is vulnerable to an exploit 
     where a deliberately false filter is made true by an OR-related subquery, making 
     it possible to discover information about other views. Similarly, any function, 
     such as <a class="javascript" href="#cts.doc">cts.doc</a>, that reads the database 
     or its configuration could also disclose unintended information.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Return row with an 'id' value between .5 and 1.5.

const op = require('/MarkLogic/optic');

op.fromLiterals([
          {id:1, name:'Master 1', date:'2015-12-01'},
          {id:2, name:'Master 2', date:'2015-12-02'} ])
  .where(op.sqlCondition('id BETWEEN 0.5 AND 1.5'))
  .result();

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Return row with an 'id' value between .5 and 1.5. :)

xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

op:from-literals((
	    map:entry("id", 1) => map:with("name", "Master 1") => map:with("date", "2015-12-01"),
        map:entry("id", 2) => map:with("name", "Master 2") => map:with("date", "2015-12-02")))

   => op:where(op:sql-condition("id BETWEEN 0.5 AND 1.5"))
   => op:result()

 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="sql-condition" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.sqlCondition">
  </apidoc:function>







 <apidoc:method name="add" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Arithmetic Expression Functions">
   <apidoc:summary class="javascript"> 
     This function returns the sum of the specified numeric expressions.
     In expressions, the call should pass the result from an
     <a href="#op.col">op.col</a> function to identify a column. 
     <p>
     The <a href="#op.add">op.add</a> function differs from the 
     <a href="#op.sum">op.sum</a> function in that it operates on 
     operates on multiple column values in a row, rather than a group of rows.
     </p>
   </apidoc:summary>
   <apidoc:summary class="xquery"> 
     This function returns the sum of the specified numeric expressions.
     In expressions, the call should pass the result from an
     <a href="#op:col">op:col</a> function to identify a column. 
     <p>
     The <a href="#op:add">op:add</a> function differs from the 
     <a href="#op:sum">op:sum</a> function in that it operates on 
     operates on multiple column values in a row, rather than a group of rows.
     </p><p>
     As a convenience, you can pass a sequence of any number of expressions as the 
     first argument: <code>op:add((expr1, expr2, ..., exprN))</code>
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The right numeric expression.
       </apidoc:param>        
       <apidoc:param class="xquery" name="left" type="item()">
         The left value expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right value expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numericExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');

const employees = op.fromView('main', 'employees');

employees.offsetLimit(op.param('start'), op.param('length'))
	   .select(['EmployeeID', 
                op.as('incremented', 
                       op.add(op.col('EmployeeID'), op.param('increment')))
               ])
	   .result(null, {start:1, length:2, increment:1});

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
   => op:offset-limit(op:param('start'), op:param('length'))
   => op:select(('EmployeeID', 
                  op:as('incremented', 
                        op:add(op:col('EmployeeID'), 
                        op:param('increment')))
                ))
   => op:result((), map:entry("start",1)=>map:with("length",2)=>map:with("increment",1)) 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="add" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.add">
  </apidoc:function>

 <apidoc:method name="divide" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Arithmetic Expression Functions">
   <apidoc:summary> 
     This function divides the left <code>numericExpression</code> by the right 
     <code>numericExpression</code> and returns the value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The right numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right numeric expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numericExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p></p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(["FirstName", "LastName", "Position", "EmployeeID",
                   op.as("divided", op.divide(op.col("EmployeeID"), 2))])
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("FirstName", "LastName", "Position", "EmployeeID",
                  op:as("divided", op:divide(op:col("EmployeeID"), 2))))
    => op:result(); 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="divide" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.divide">
  </apidoc:function>

 <apidoc:method name="modulo" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Arithmetic Expression Functions">
   <apidoc:summary> 
        This function returns the remainder afer the division of the dividend and
        divisor expressions.  For example, op:modulo(5, 2) returns 1.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The dividend numeric expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The divisor numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The dividend numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The divisor numeric expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numericExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(["FirstName", "LastName", "Position", "EmployeeID",
                   op.as("divided", op.divide(op.col("EmployeeID"), 2)),
                   op.as("modulo", op.modulo(op.col("EmployeeID"), 2))])
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("FirstName", "LastName", "Position", "EmployeeID",
                  op:as("divided", op:divide(op:col("EmployeeID"), 2)),
                  op:as("modulo", op:modulo(op:col("EmployeeID"), 2))               
       ))
    => op:result(); 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="modulo" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.modulo">
  </apidoc:function>

 <apidoc:method name="multiply" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Arithmetic Expression Functions">
   <apidoc:summary class="javascript"> 
     This function multipies the left <code>numericExpression</code> by the right 
     <code>numericExpression</code> and returns the value.
   </apidoc:summary>
  <apidoc:summary class="xquery"> 
     This function multipies the left <code>numericExpression</code> by the right 
     <code>numericExpression</code> and returns the value.
     <p>
     As a convenience, you can pass a sequence of any number of expressions as the 
     first argument: <code>op:multiply((expr1, expr2, ..., exprN))</code>
     </p>
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The right numeric expression.
       </apidoc:param> 
       <apidoc:param class="xquery" name="left" type="item()">
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right numeric expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numericExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
        
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(["FirstName", "LastName", "Position", "EmployeeID",
                   op.as("multiplied", op.multiply(op.col("EmployeeID"), 2))])
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("FirstName", "LastName", "Position", "EmployeeID",
                  op:as("multipled", op:multiply(op:col("EmployeeID"), 2))))
    => op:result(); 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="multiply" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.multiply">
  </apidoc:function>

 <apidoc:method name="subtract" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Arithmetic Expression Functions">
   <apidoc:summary> 
     This function subtracts the right <code>numericExpression</code> from the left 
     <code>numericExpression</code> and returns the value.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="javascript" name="numericExpression" type="String"> 
         The right numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="left" type="item()">
         The left numeric expression.
       </apidoc:param>
       <apidoc:param class="xquery" name="right" type="item()">
         The right numeric expression.
       </apidoc:param>
   </apidoc:params>
   <apidoc:return class="javascript">numericExpression</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const op = require('/MarkLogic/optic');
const employees = op.fromView('main', 'employees');

employees.select(["FirstName", "LastName", "Position", "EmployeeID",
                   op.as("subtracted", op.subtract(op.col("EmployeeID"), 2))])
.result();
  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";

import module namespace op="http://marklogic.com/optic"
     at "/MarkLogic/optic.xqy";

let $employees := op:from-view("main", "employees")
 
return $employees
    => op:select(("FirstName", "LastName", "Position", "EmployeeID",
                  op:as("subtracted", op:subtract(op:col("EmployeeID"), 2))))
    => op:result(); 
  ]]></pre></apidoc:example>

  </apidoc:method>
                       
   <apidoc:function class="xquery" name="subtract" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic"  
          copy-content-from="op.subtract">
  </apidoc:function>

<apidoc:method name="graphCol" object="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" subcategory="Column and Parameter Functions">
   <apidoc:summary>
    Identifies the graph for a triple providing one or more columns for a row.  
    You pass the graph column as a system column parameter to the 
     <a class="javascript" href="#op.pattern">op.pattern</a>
     <a class="xquery" href="#op:pattern">op:pattern</a> function.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param class="javascript" name="name" type="String"> 
         The name to use for the graph column.
       </apidoc:param>
       <apidoc:param class="xquery" name="name" type="string"> 
         The name to use for the graph column.
       </apidoc:param> 
   </apidoc:params>
   <apidoc:return class="javascript">columnIdentifier</apidoc:return>
   <apidoc:return class="xquery">map:map</apidoc:return>
   <apidoc:usage class="javascript">
     <p>
 
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       
     </apidoc:see-also>
     <apidoc:see-also>
       
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[

  ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
 
  ]]></pre></apidoc:example>


  </apidoc:method>

  <apidoc:function class="xquery" name="graph-col" lib="op" 
	  bucket="XQuery Library Modules"
	  category="Optic" 
          copy-content-from="op.graphCol">
  </apidoc:function>

</apidoc:module>
