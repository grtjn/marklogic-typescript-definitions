<apidoc:module name="SearchBuiltins" category="SearchBuiltins" lib="cts" xmlns:apidoc="http://marklogic.com/xdmp/apidoc"><apidoc:summary category="SearchBuiltins">
<p xmlns="http://www.w3.org/1999/xhtml">Use the search built-in functions to search XML, JSON, and text documents,
and document properties, and to browse word and value lexicons.</p>
<p class="javascript" xmlns="http://www.w3.org/1999/xhtml">Though you can use these functions from both XQuery
and Server-Side JavaScript, JavaScript developers should consider using
the fluent native JavaScript Search (jsearch) API instead. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2346466'>Creating JavaScript Search Applications</a> in the <em>Search Developer's Guide</em>.</p>
<p xmlns="http://www.w3.org/1999/xhtml">For more details, see the <em>Search Developer's Guide</em> and the following
Search function sub-categories:</p>
<span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><ul>
	<li><a href="/cts/constructors">cts:query Constructors</a></li>
	<li><a href="/cts/cts:order-constructors">cts:order Constructors</a></li>
	<li><a href="/cts/geospatial-constructors">Geospatial Constructors</a></li>
	<li><a href="/cts/geospatial-lexicon">Geospatial Lexicon</a></li>
	<li><a href="/geo/geospatial-operations">Geospatial Operations</a></li>
	<li><a href="/cts/lexicon">Lexicon</a></li>
	<li><a href="/cts/math-lexicon">Math Lexicon</a></li>
	<li><a href="/cts/search">Search</a></li>
	<li><a href="/cts/search-clustering">Search Clustering</a></li>
	<li><a href="/cts/temporal">Temporal</a></li>
      </ul></span>
<span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><ul>
	<li><a href="/js/cts/constructors">cts:query Constructors</a></li>
	<li><a href="/js/cts/cts:order-constructors">cts:order Constructors</a></li>
	<li><a href="/js/cts/geospatial-constructors">Geospatial Constructors</a></li>
	<li><a href="/js/cts/geospatial-lexicon">Geospatial Lexicon</a></li>
	<li><a href="/js/geo/geospatial-operations">Geospatial Operations</a></li>
	<li><a href="/js/cts/lexicon">Lexicon</a></li>
	<li><a href="/js/cts/math-lexicon">Math Lexicon</a></li>
	<li><a href="/js/cts/search">Search</a></li>
	<li><a href="/js/cts/search-clustering">Search Clustering</a></li>
	<li><a href="/js/cts/temporal">Temporal</a></li>
      </ul>
<p>For a fluent and natural JavaScript interface to the same capabilities,
see the JavaScript Search (jsearch) API.</p>
</span>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Search" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">The search built-in functions are XQuery functions used to perform text
searches. The search functions are designed for use with XML and JSON
structured text. Searches that use these functions use the indexes and
are designed to return results quickly.</p>
<p class="javascript" xmlns="http://www.w3.org/1999/xhtml">Though you can use these functions from both XQuery
and Server-Side JavaScript, JavaScript developers should consider using
the fluent native JavaScript Search (jsearch) API instead. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2346466'>Creating JavaScript Search Applications</a> in the <em>Search Developer's Guide</em>.</p>
<p xmlns="http://www.w3.org/1999/xhtml">There are built-in functions to search through documents
(<a class="xquery" href="#cts:search">cts:search</a><a class="javascript" href="#cts.search">cts.search</a>,
<a class="xquery" href="#cts:contains">cts:contains</a><a class="javascript" href="#cts.contains">cts.contains</a>
 and <a class="xquery" href="#cts:highlight">cts:highlight</a><a class="javascript" href="#cts.highlight">cts.highlight</a>);
there is a function to tokenize text into different types
(<a class="xquery" href="#cts:tokenize">cts:tokenize</a><a class="javascript" href="#cts.tokenize">cts.tokenize</a>),
and there are functions to retrieve result characteristics (for example
<a class="xquery" href="#cts:quality">cts:quality</a><a class="javascript" href="#cts.quality">cts.quality</a>
and <a class="xquery" href="#cts:score">cts:score</a>)<a class="javascript" href="#cts.score">cts.score</a>.
There are also built-in functions to browse word and value lexicons
(<a class="xquery" href="#cts:words">cts:words</a><a class="javascript" href="#cts.words">cts.words</a>,
<a class="xquery" href="#cts:element-values">cts:element-values</a><a class="javascript" href="#cts.elementValues">cts.elementValues</a>,
and so on.) The lexicon built-in functions require the appropriate lexicons
to be enabled in the Admin interface.</p>
<p xmlns="http://www.w3.org/1999/xhtml">There are also functions to compose a <code>cts:query</code>,
as well as accessor functions to retrieve the parameter values
from a cts query. </p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="cts:query Constructors" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">These functions enable you to build arbitrarily complex cts queries. Each
constructor function has corresponding accessor functions, which you can use
to retrieve the parts of a constructed query.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Included in these functions is the
<a class="xquery" href="#cts:registered-query">cts:registered-query</a><a class="javascript" href="#cts.registeredQuery">cts.registeredQuery</a>
function, which provides a mechanism to precompute and store in the cache
unfiltered cts query result primitives.</p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Lexicon" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server allows you to create <em>lexicons</em>, which are lists
of unique words or values, either throughout an entire database (words only)
or within named elements or attributes (words or values). Also, you can
define lexicons that allow quick access to the document and collection
URIs in the database, and you can create word lexicons on named
fields. </p>
<p xmlns="http://www.w3.org/1999/xhtml">A <em>word lexicon</em> stores all of the unique, case-sensitive,
diacritic-sensitive words, either in a database, in an element
defined by a QName, or in an attribute defined by a QName. A
<em>value lexicon</em> stores all of the unique values for an element
or an attribute defined by a QName (that is, the entire and exact contents
of the specified element or attribute).  Value lexicons use range indexes,
which store all of the pairs of values that appear in the same fragment. A
<em>geospatial lexicon</em> returns geospatial values from the geospatial
index. You can also use the value lexicon functions to calculate buckets
of values that occur within a specified range of values.
A <em>URI lexicon</em> stores the URIs of the documents in a database, and a
<em>collection lexicon</em> stores the URIs of all collections
in a database.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the lexicon APIs.</p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Geospatial Lexicon" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server allows you to create <em>geospatial lexicons</em>, which
are lists of unique values of geospatial data. </p>
<p xmlns="http://www.w3.org/1999/xhtml"> A <em>geospatial lexicon</em> returns geospatial values from the geospatial
index. The geospatial index is required for using the geospatial lexicon
functions.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the geospatial lexicon APIs.</p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Math Lexicon" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server provides aggregate math functions that make use of value lexicons
to calculate results. The math lexicon functions differ from the math functions in the
<code>math:</code> namespace in that math lexicon functions take frequency into
consideration.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the math lexicon APIs.</p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="XPath Validation" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server provides functions that check the validity of an XPath
within the context of several features.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the XPath validation APIs.</p>
</apidoc:summary><apidoc:function name="period-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching axis by name with a
  period value with an operator.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:period-range-query</code>
  constructor require a axis definition on the axis name;
  if there is no axis configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="axis-name" type="xs:string*">
    One or more axis to match on.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"aln_equals"</dt>
        <dd>Match documents whose period1 equals value.</dd>
        <dt>"aln_contains"</dt>
        <dd>Match documents whose period1 contains value. i.e. period1 starts
	before value starts and ends before value ends.</dd>
        <dt>"aln_contained_by"</dt>
        <dd>Match documents whose period1 is contained by value.</dd>
        <dt>"aln_meets"</dt>
        <dd>Match documents whose period1 meets value, i.e. period1 ends at
	value start.</dd>
        <dt>"aln_met_by"</dt>
        <dd>Match documents whose period1 meets value, i.e. period1 starts at
	value end.</dd>
        <dt>"aln_before"</dt>
        <dd>Match documents whose period1 is before value, i.e. period1 ends
	before value starts.</dd>
        <dt>"aln_after"</dt>
        <dd>Match documents whose period1 is after value, i.e. period1 starts
	after value ends.</dd>
        <dt>"aln_starts"</dt>
        <dd>Match documents whose period1 starts value, i.e. period1 starts at
	value start and ends before value ends.</dd>
        <dt>"aln_started_by"</dt>
        <dd>Match documents whose value starts period1, i.e. period1 starts at
	value start and ends after value ends.</dd>
        <dt>"aln_finishes"</dt>
        <dd>Match documents whose period1 finishes value, i.e. period1
	finishes at value finish and starts after value starts.</dd>
        <dt>"aln_finished_by"</dt>
        <dd>Match documents whose value finishes period1, i.e. period1
	finishes at value finish and starts before value starts.</dd>
        <dt>"aln_overlaps"</dt>
        <dd>Match documents whose period1 overlaps value, i.e. period1 starts
	before value start and ends before value ends but after value
	starts.</dd>
        <dt>"aln_overlapped_by"</dt>
        <dd>Match documents whose value overlaps period1, i.e. period1
	starts after value start but before value ends and ends after
	value ends.</dd>
        <dt>"iso_contains"</dt>
        <dd>Match documents whose period1 contains value in sql 2011 standard.
        i.e. period1 starts before or at value starts and ends after or at
	value ends.</dd>
        <dt>"iso_overlaps"</dt>
        <dd>Match documents whose period1 overlaps value in sql 2011 standard.
        i.e. period1 and value have common time period.</dd>
        <dt>"iso_succeeds"</dt>
        <dd>Match documents whose period1 succeeds value in sql 2011 standard.
        i.e. period1 starts at or after value ends</dd>
        <dt>"iso_precedes"</dt>
        <dd>Match documents whose period1 precedes value in sql 2011 standard.
        i.e. period1 ends at or before value ends</dd>
        <dt>"iso_imm_succeeds"</dt>
        <dd>Match documents whose period1 immediately succeeds value in
	sql 2011 standard.
        i.e. period1 starts at value end</dd>
        <dt>"iso_imm_precedes"</dt>
        <dd>Match documents whose period1 immediately precedes value in
	sql 2011 standard.
        i.e. period1 ends at value end</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="period" type="cts:period*" optional="true">
    the cts:period to perform operations on.
    When multiple values are specified,
    the query matches if any value matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          </dl>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:period-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:period-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors, as in the last part of the example
  below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope
  factor will provide useful results. Using a slope factor greater than
  1 gives distinct scores over a smaller range of values, and produces
  generally higher scores.  Using a slope factor less than 1 gives
  distinct scores over a wider range of values, and produces generally
  lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $period := cts:period(xs:dateTime("2001-05-31T09:30:10-08:00"),
                          xs:dateTime("2003-05-31T09:30:10-08:00"))
let $query := cts:period-range-query("period1","aln_equals", $period)
return
cts:search(fn:doc(), $query)
  =&gt; documents matching the range query
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const period = cts.period(xs.dateTime("2001-05-31T09:30:10-08:00"),
                        xs.dateTime("2003-05-31T09:30:10-08:00"));
const query = cts.periodRangeQuery("period1","aln_equals", period);
cts.search(query);
  =&gt; document matching the range query
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-range-query-axis" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the axis name used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $period := cts:period(xs:dateTime("2001-05-31T09:30:10-08:00"),
                              xs:dateTime("2003-05-31T09:30:10-08:00"))
let $query := cts:period-range-query("period1","aln_equals", $period)
return
cts:period-range-query-axis($query)
  =&gt;
    period1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const period = cts.period(xs.dateTime("2001-05-31T09:30:10-08:00"),
                        xs.dateTime("2003-05-31T09:30:10-08:00"));
const query = cts.periodRangeQuery("period1","aln_equals", period);
cts.periodRangeQueryAxis(query);
  =&gt;
    period1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $period := cts:period(xs:dateTime("2001-05-31T09:30:10-08:00"),
                          xs:dateTime("2003-05-31T09:30:10-08:00"))
let $query := cts:period-range-query("period1","aln_equals", $period)
return
cts:period-range-query-opertor($query)
  =&gt;
    aln_equals
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const period = cts.period(xs.dateTime("2001-05-31T09:30:10-08:00"),
                        xs.dateTime("2003-05-31T09:30:10-08:00"));
const query = cts.periodRangeQuery("period1","aln_equals", period);
cts.periodRangeQueryOperator(query);
  =&gt;
    aln_equals
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-range-query-period" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the period used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $period := cts:period(xs:dateTime("2001-05-31T09:30:10-08:00"),
                          xs:dateTime("2003-05-31T09:30:10-08:00"))
let $query := cts:period-range-query("period1","aln_equals", $period)
return
cts:period-range-query-period($query)
  =&gt;
cts:period(xs:dateTime("2001-05-31T17:30:10"),
xs:dateTime("2003-05-31T17:30:10"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const period = cts.period(xs.dateTime("2001-05-31T09:30:10-08:00"),
                        xs.dateTime("2003-05-31T09:30:10-08:00"));
const query = cts.periodRangeQuery("period1","aln_equals", period);
cts.periodRangeQueryPeriod(query);
  =&gt;
cts.period(xs.dateTime("2001-05-31T17:30:10"),
           xs.dateTime("2003-05-31T17:30:10"))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $period := cts:period(xs:dateTime("2001-05-31T09:30:10-08:00"),
                          xs:dateTime("2003-05-31T09:30:10-08:00"))
let $query := cts:period-range-query("period1","aln_equals", $period)
return
cts:period-range-query-options($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const period = cts.period(xs.dateTime("2001-05-31T09:30:10-08:00"),
                        xs.dateTime("2003-05-31T09:30:10-08:00"));
const query = cts.periodRangeQuery("period1","aln_equals", period);
cts.periodRangeQueryOptions(query);
  =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="lsqt-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
Returns only documents before LSQT or a timestamp before LSQT for
stable query results.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="temporal-collection" type="xs:string">
    The name of the temporal collection.
  </apidoc:param>
      <apidoc:param name="timestamp" type="xs:dateTime?" optional="true">
   Return only temporal documents with a system start time less than or equal
   to this value.
   Default is <code xmlns="http://www.w3.org/1999/xhtml">temporal:get-lsqt($temporal-collection)</code>.
   Timestamps larger than LSQT are rejected.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"cached-incremental"</dt>
        <dd>Break down the query into sub-queries and then cache each
        one of them for better performance. This is enabled, by default.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:lsqt-query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:lsqt-query("temporal",(),"cached-incremental", xs:double("3.13"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.lsqtQuery("temporal", null, "cached-incremental", xs.double("3.13"));
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="lsqt-query-temporal-collection" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the name of the temporal collection used to construct specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:lsqt-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:lsqt-query("temporal",(),"cached-incremental", xs:double("3.13"))
return
  cts:lsqt-query-temporal-collection($query)
  =&gt; temporal
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.lsqtQuery("temporal",null,"cached-incremental", xs.double("3.13"));
cts.lsqtQueryTemporalCollection(query);
  =&gt; temporal
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="lsqt-query-timestamp" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns timestamp used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:lsqt-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:dateTime</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:lsqt-query("temporal",
                 xs:dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs:double("3.13"))
return
  cts:lsqt-query-timestamp($query)
  =&gt; 2014-09-03T15:26:41.452342-07:00
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.lsqtQuery("temporal",
                 xs.dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs.double("3.13"));
cts.lsqtQueryTimestamp(query);
  =&gt; 2014-09-03T22:26:41.452342
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="lsqt-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:lsqt-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:lsqt-query("temporal",
                 xs:dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs:double("3.13"))
return
  cts:lsqt-query-options($query)
  =&gt; cached-incremental
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.lsqtQuery("temporal",
                 xs.dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs.double("3.13"));
cts.lsqtQueryOptions(query);
  =&gt; cached-incremental
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="lsqt-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:lsqt-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:lsqt-query("temporal",
                 xs:dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs:double("3.13"))
return
  cts:lsqt-query-weight($query)
  =&gt; 3.13
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.lsqtQuery("temporal",
                 xs.dateTime("2014-09-03T15:26:41.452342-07:00"),
		 "cached-incremental", xs.double("3.13"));
cts.lsqtQueryWeight(query);
  =&gt; 3.13
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-compare-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching documents that have relevant
  pair of period values.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:period-compare-query</code>
  constructor require two valid names of period, if the either of the specified
  period does not exist, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="axis-1" type="xs:string">
    Name of the first axis to compare
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator. Period is the two timestamps contained in the axis.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"aln_equals"</dt>
        <dd>Match documents whose period1 equals period2.</dd>
        <dt>"aln_contains"</dt>
        <dd>Match documents whose period1 contains period2. i.e. period1
	starts before period2 starts and ends before period2 ends.</dd>
        <dt>"aln_contained_by"</dt>
        <dd>Match documents whose period1 is contained by period2.</dd>
        <dt>"aln_meets"</dt>
        <dd>Match documents whose period1 meets period2, i.e. period1 ends at
	period2 start.</dd>
        <dt>"aln_met_by"</dt>
        <dd>Match documents whose period1 meets period2, i.e. period1 starts
	at period2 end.</dd>
        <dt>"aln_before"</dt>
        <dd>Match documents whose period1 is before period2, i.e. period1 ends
	before period2 starts.</dd>
        <dt>"aln_after"</dt>
        <dd>Match documents whose period1 is after period2, i.e. period1
	starts after period2 ends.</dd>
        <dt>"aln_starts"</dt>
        <dd>Match documents whose period1 starts period2, i.e. period1 starts
	at period2 start and ends before period2 ends.</dd>
        <dt>"aln_started_by"</dt>
        <dd>Match documents whose period2 starts period1, i.e. period1 starts
	at period2 start and ends after period2 ends.</dd>
        <dt>"aln_finishes"</dt>
        <dd>Match documents whose period1 finishes period2, i.e. period1
	finishes at period2 finish and starts after period2 starts.</dd>
        <dt>"aln_finished_by"</dt>
        <dd>Match documents whose period2 finishes period1, i.e. period1
	finishes at period2 finish and starts before period2 starts.</dd>
        <dt>"aln_overlaps"</dt>
        <dd>Match documents whose period1 overlaps period2, i.e. period1
	starts before period2 start and ends before period2 ends but after
	period2 starts.</dd>
        <dt>"aln_overlapped_by"</dt>
        <dd>Match documents whose period2 overlaps period1, i.e. period1
	starts after period2 start but before period2 ends and ends after
	period2 ends.</dd>
        <dt>"iso_contains"</dt>
        <dd>Match documents whose period1 contains period2 in sql 2011 standard.
        i.e. period1 starts before or at period2 starts and ends after or
	at period2 ends.</dd>
        <dt>"iso_overlaps"</dt>
        <dd>Match documents whose period1 overlaps period2 in sql 2011 standard.
        i.e. period1 and period2 have common time period.</dd>
        <dt>"iso_succeeds"</dt>
        <dd>Match documents whose period1 succeeds period2 in sql 2011 standard.
        i.e. period1 starts at or after period2 ends</dd>
        <dt>"iso_precedes"</dt>
        <dd>Match documents whose period1 precedes period2 in sql 2011 standard.
        i.e. period1 ends at or before period2 ends</dd>
        <dt>"iso_succeeds"</dt>
        <dd>Match documents whose period1 succeeds period2 in sql 2011 standard.
        i.e. period1 starts at or after period2 ends</dd>
        <dt>"iso_precedes"</dt>
        <dd>Match documents whose period1 precedes period2 in sql 2011 standard.
        i.e. period1 ends at or before period2 ends</dd>
        <dt>"iso_imm_succeeds"</dt>
        <dd>Match documents whose period1 immediately succeeds period2 in
	sql 2011 standard.  i.e. period1 starts at period2 ends</dd>
        <dt>"iso_imm_precedes"</dt>
        <dd>Match documents whose period1 immediately precedes period2 in
	sql 2011 standard.  i.e. period1 ends at period2 ends</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="axis-2" type="xs:string">
    Name of the second period to compare
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:period-compare-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of period comparisons, you can combine multiple
  <code>cts:</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors, as in the last part of the example
  below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:period-compare-query("system","aln_overlaps","valid",
    "cached", xs:double("3.13"))

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.periodCompareQuery("system","aln_overlaps","valid",
    "cached", xs.double("3.13"));

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-compare-query-axis-1" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the name of the first axis used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-compare-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:period-compare-query("system","aln_overlaps","valid",
    "cached", xs:double("3.13"))
return
  cts:period-compare-query-axis-1($query)
  =&gt; system
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.periodCompareQuery("system","aln_overlaps","valid",
    "cached", xs.double("3.13"));
cts.periodCompareQueryAxis1(query);
  =&gt; system
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-compare-query-axis-2" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the name of the second axis used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-compare-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:period-compare-query("system","aln_overlaps","valid",
    "cached", xs:double("3.13"))
return
  cts:period-compare-query-axis-2($query)
  =&gt; valid
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.periodCompareQuery("system","aln_overlaps","valid",
    "cached", xs.double("3.13"));
cts.periodCompareQueryAxis2(query);
  =&gt; valid
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-compare-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-compare-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:period-compare-query("system","aln_overlaps","valid",
    "cached", xs:double("3.13"))
return
  cts:period-compare-query-operator($query)
  =&gt; aln_overlaps
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.periodCompareQuery("system","aln_overlaps","valid",
    "cached", xs.double("3.13"));
cts.periodCompareQueryOperator(query);
  =&gt; aln_overlaps
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period-compare-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:period-compare-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:period-compare-query("system","aln_overlaps","valid",
    "cached", xs:double("3.13"))
return
  cts:period-compare-query-options($query)
  =&gt; cached
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.periodCompareQuery("system","aln_overlaps","valid",
    "cached", xs.double("3.13"));
cts.periodCompareQueryOptions(query);
  =&gt; cached
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="true-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query that matches all fragments.
</apidoc:summary>
    <apidoc:params/>
    <apidoc:return>cts:and-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(fn:doc(),cts:true-query())
  =&amp;gt; all documents in database
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.trueQuery())
=&gt; all documents in database
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="false-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query that matches no fragments.
</apidoc:summary>
    <apidoc:params/>
    <apidoc:return>cts:or-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(fn:doc(),cts:false-query())
  =&amp;gt; empty sequence
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.falseQuery())
=&gt; empty
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query specifying the intersection
  of the matches specified by the sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*">
    A sequence of sub-queries.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ordered"</dt>
        <dd>An ordered and-query, which specifies that the sub-query matches
            must occur in the order of the specified sub-queries.  For example,
            if the sub-queries are "cat" and "dog", an ordered
            query will only match fragments where both "cat" and "dog" occur,
            and where "cat" comes before "dog" in the fragment.</dd>
        <dt>"unordered"</dt>
        <dd>An unordered and-query, which specifies that the sub-query matches
        can occur in any order. </dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:and-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If the options parameter contains neither "ordered" nor "unordered",
  then the default is "unordered".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you specify the empty sequence for the <code>queries</code> parameter
  to <code class="xquery">cts:and-query</code><code class="javascript">cts.andQuery</code>, you will get a match for every document in
  the database.  For example, the following query always returns true:</p>
 <pre class="xquery" xmlns="http://www.w3.org/1999/xhtml">  cts:contains(collection(), cts:and-query(()))</pre>
 <pre class="javascript" xmlns="http://www.w3.org/1999/xhtml">  cts.contains(fn.collection(), cts.andQuery([]))</pre>
 <p xmlns="http://www.w3.org/1999/xhtml"> In order to match a <code class="xquery">cts:and-query</code><code class="javascript">cts.andQuery</code>, the matches
  from each of the specified sub-queries must all occur in the same
  fragment.
 </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:and-query((
      cts:word-query("to be or"),
      cts:word-query("or not to be"))))
  =&amp;gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the phrase 'to be or' AND some node
  whose text content contains the phrase 'or not to be'.
  With high probability this intersection contains only
  one 'PLAY' element, namely,

    PLAY/TITLE =
      "The Tragedy of Hamlet, Prince of Denmark".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.estimate(
  cts.andQuery([cts.wordQuery("to be or"),
                         cts.wordQuery("or not to be")]));
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a sequence of the queries that were used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:and-query-queries($query)
  =&gt; ... a sequence of the queries used to
            construct this query
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.andQueryQueries(query);
  =&gt; ... a Sequence of the queries used to
            construct this query
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:and-query((
    cts:word-query("to be or"),
    cts:word-query("or not to be")))
return cts:and-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1)
         cts:word-query("or not to be", (), 1))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.andQuery([
    cts.wordQuery("to be or"),
    cts.wordQuery("or not to be")]);
cts.andQueryQueries(query);
  =&gt; Sequence(
       cts.wordQuery("to be or", ["lang=en"], 1),
       cts.wordQuery("to be or", ["lang=en"], 1))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:and-query((
    cts:word-query("to be or"),
    cts:word-query("or not to be")))
return cts:and-query-queries($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.andQuery([
    cts.wordQuery("to be or"),
    cts.wordQuery("or not to be")]);
cts.andQueryOptions(query);
  =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="boost-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query specifying that matches to <code xmlns="http://www.w3.org/1999/xhtml">$matching-query</code>
  should have their search relevance scores boosted if they also match
  <code xmlns="http://www.w3.org/1999/xhtml">$boosting-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="matching-query" type="cts:query">
    A sub-query that is used for match and scoring.
  </apidoc:param>
      <apidoc:param name="boosting-query" type="cts:query">
    A sub-query that is used only for boosting score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:boost-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">When used in a search, <code>$boosting-query</code> is not evaluated
  if there are no matches to <code>$matching-query</code>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When used in a search, all matches to <code>$matching-query</code>
  are included in the search results. <code>$boosting-query</code>
  only contributes to search relevances scores. Scoring is done the same
  way as for a <code>cts:and-query</code>.</p>
</apidoc:usage>
    <apidoc:see-also-list>
  <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/relevance.xml%2330927'>Boosting Relevance Score With a Secondary Query</a> in the <em>Search Developer's Guide</em>
  </apidoc:see-also>
</apidoc:see-also-list>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(fn:collection(),
    cts:boost-query(cts:word-query("George"),
                    cts:word-query("Washington", (), 10.0)
    )
  )[1 to 10]
  =&gt; The first 10 documents containing the word "George". Those documents
     that also contain the word "Washington" have a higher relevance
     score than those elements that do not.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
fn.subsequence(
 cts.search(
  cts.boostQuery(
      cts.wordQuery("George"),
      cts.wordQuery("Washington", null, 10.0)
  )), 1, 10)
  =&gt; The first 10 documents containing the word "George". Those documents
     that also contain the word "Washington" have a higher relevance
     score than those elements that do not.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="boost-query-matching-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the matching (first parameter) query used to construct the
  specified boost query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:boost-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:boost-query(
                cts:word-query("wanted"),
                cts:word-query("unwanted"))
return cts:boost-query-matching-query($query)

  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.boostQuery(
                cts.wordQuery("wanted"),
                cts.wordQuery("unwanted"));
cts.boostQueryMatchingQuery(query);

  =&gt; cts.wordQuery("wanted", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="boost-query-boosting-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the boosting (second parameter) query used to construct the
  specified boost query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:boost-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:boost-query(
                cts:word-query("wanted"),
                cts:word-query("unwanted"))
return cts:boost-query-boosting-query($query)

  =&gt; cts:word-query("unwanted", (), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.boostQuery(
                cts.wordQuery("wanted"),
                cts.wordQuery("unwanted"));
cts.boostQueryBoostingQuery(query);

  =&gt; cts.wordQuery("unwanted", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="or-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query specifying the union
  of the matches specified by the sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*">
    A sequence of sub-queries.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options to this query. The default is <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">()</span><span class="javascript" xmlns="http://www.w3.org/1999/xhtml">[]</span>.
  <p xmlns="http://www.w3.org/1999/xhtml">
  Options include:
  </p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
  <dt>"synonym"</dt>
  <dd>Specifies that all of the terms in the $queries parameter are
  considered synonyms for scoring purposes.  The result is that
  occurrences of more than one of the synonyms are scored as if
  there are more occurrences of the same term (as opposed to
  having a separate term that contributes to score).
  </dd>
  </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:or-query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:or-query((
      cts:word-query("summer"),
      cts:word-query("sun of York"))))
  =&gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the word 'summer' OR some node
  whose text content contains the phrase 'sun of York'.
  This union contains at least one 'PLAY' node with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second",

  but also contains other 'PLAY' nodes containing some
  text node with the word "summer", for example,

    PLAY/TITLE = "A Midsummer Night's Dream".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.estimate(
    cts.orQuery([
      cts.wordQuery("summer"),
      cts.wordQuery("sun of York")]))
  =&gt; 31 plays have text content that
  contains the word 'summer' OR some node
  whose text content contains the phrase 'sun of York'.

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="or-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a sequence of the queries that were used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:or-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:or-query-queries($query)
  =&gt; ... a sequence of the queries used to construct this query
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.orQueryQueries(query);
  =&gt; ... a Sequence containing the queries used to construct this query
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="or-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:or-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:or-query-options($query)
  =&gt; "synonym"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.orQueryOptions(query);
  =&gt; "synonym"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query specifying the set difference of
  the matches specified by two sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="positive-query" type="cts:query">
    A positive query, specifying the search results
    filtered in.
  </apidoc:param>
      <apidoc:param name="negative-query" type="cts:query">
    A negative query, specifying the search results
    to filter out.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:and-not-query</apidoc:return>
    <apidoc:usage>
  The <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> constructor is fragment-based, so
  it returns true only if the specified query does not produce a match
  anywhere in a fragment.  Therefore, a search using
  <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> is only guaranteed to be accurate if the
  underlying query that is being negated is accurate from its index
  resolution (that is,
  if the unfiltered results of the <code xmlns="http://www.w3.org/1999/xhtml">$negative-query</code> parameter to
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> are accurate).  The accuracy of the index
  resolution depends on many factors such as the query, if you search
  at a fragment root (that is, if the first parameter of
  <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> specifies an XPath that resolves to a fragment root),
  the index options enabled on the database, the search options,
  and other factors.
  In cases where the <code xmlns="http://www.w3.org/1999/xhtml">$negative-query</code> parameter has false
  positive matches,
  the negation of the query can miss matches (have false negative matches).
  In these cases,
  searches with <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> can miss results, even if those
  searches are filtered.
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:and-not-query(
      cts:word-query("summer"),
      cts:word-query("glorious")))
  =&gt; .. sequence of 'PLAY' elements containing some
  text node with the word 'summer' BUT NOT containing
  any text node with the word 'glorious'.  This sequence
  may be (in fact is) non-empty, but certainly does not
  contain the PLAY element with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second"

  since this play contains both 'glorious' and 'summer'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.estimate(
    cts.andNotQuery(
      cts.wordQuery("summer"),
      cts.wordQuery("glorious")))
  =&gt; .. 12 Shakespeare Plays contain some text node with the word
  'summer' BUT NOT the word 'glorious'.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query-positive-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the positive (first parameter) query used to construct the
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-not-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:and-not-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"))
return cts:and-not-query-positive-query($query)

  =&gt; cts:word-query("wanted", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.andNotQuery(
                 cts.wordQuery("wanted"),
                 cts.wordQuery("unwanted"));
cts.andNotQueryPositiveQuery(query);

  =&gt; cts.wordQuery("wanted", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query-negative-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the negative (second parameter) query used to construct the
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-not-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:and-not-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"))
return cts:and-not-query-negative-query($query)

  =&gt; cts:word-query("unwanted", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.andNotQuery(
                 cts.wordQuery("wanted"),
                 cts.wordQuery("unwanted"));
cts.andNotQueryNegativeQuery(query);

  =&gt; cts.wordQuery("unwanted", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query specifying the matches not specified by its sub-query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query">
    A negative query, specifying the search results
    to filter out.
  </apidoc:param>
      <!-- Do not document: this shouldn't be here and doesn't work
  <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order. The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
  -->
    </apidoc:params>
    <apidoc:return>cts:not-query</apidoc:return>
    <apidoc:usage>
  The <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> constructor is fragment-based, so
  it returns true only if the specified query does not produce a match
  anywhere in a fragment.  Therefore, a search using
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> is only guaranteed to be accurate if the underlying
  query that is being negated is accurate from its index resolution (that is,
  if the unfiltered results of the <code xmlns="http://www.w3.org/1999/xhtml">$query</code> parameter to
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> are accurate).  The accuracy of the index
  resolution depends on the many factors such as the query, if you search
  at a fragment root (that is, if the first parameter of
  <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> specifies an XPath that resolves to a fragment root),
  the index options enabled on the database, the search options,
  and other factors.
  In cases where the <code xmlns="http://www.w3.org/1999/xhtml">$query</code> parameter has false-positive matches,
  the negation of the query can miss matches (have false negative matches).
  In these cases,
  searches with <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> can miss results, even if those
  searches are filtered.
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:not-query(
      cts:word-query("summer")))
  =&gt; ...  sequence of 'PLAY' elements not containing
          any text node with the word 'summer'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.notQuery(
      cts.wordQuery("summer")));
  =&gt; ...  a Sequence of documents not containing
          any text node with the word 'summer'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $doc :=
  &lt;doc&gt;
   &lt;p n="1"&gt;Dogs, cats, and pigs&lt;/p&gt;
   &lt;p n="2"&gt;Trees, frogs, and cats&lt;/p&gt;
   &lt;p n="3"&gt;Dogs, alligators, and wolves&lt;/p&gt;
  &lt;/doc&gt;
return
$doc//p[cts:contains(., cts:not-query("cat"))]
(: Returns the third p element (the one without
   a "cat" term). Note that the
   cts:contains forces the constraint to happen
   in the filtering stage of the query. :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Insert the following documents:

declareUpdate();
const doc1 = {doc:"Dogs, cats, and pigs"};
const doc2 = {doc:"Trees, frogs, and cats"};
const doc3 = {doc:"Dogs, alligators, and wolves"};
xdmp.documentInsert("/cat1.json", doc1);
xdmp.documentInsert("/cat2.json", doc2);
xdmp.documentInsert("/nocat.json", doc3);

******
// Now run the following search:

cts.search(cts.notQuery("cat"));

=&gt;
The document /nocat.json with the following json:

{"doc":"Dogs, alligators, and wolves"}
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:not-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:not-query("MarkLogic Server);
return
cts:not-query-query($query)

=&gt; cts:word-query("MarkLogic Server"), ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.notQuery("MarkLogic Server);
cts.notQueryQuery(query);

=&gt; cts.wordQuery("MarkLogic Server", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:not-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:not-query("MarkLogic Server);
return
cts:not-query-weight($query)

=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.notQuery("MarkLogic Server);
cts.notQueryWeight(query);

=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching text content containing a given phrase.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string*">
    Some words or phrases to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.
        The default value is 0.0 (no impact of proximity). The
        weight should be between 64 and -16.
        Weights greater than 64 will have the same effect as a
        weight of 64.
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that
        use score-simple, score-random, or score-zero (because those scoring
        algorithms do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
        <dt>"lexicon-expand=<em>value</em>"</dt>
        <dd>The <em>value</em> is one of <code>full</code>,
        <code>prefix-postfix</code>, <code>off</code>, or
        <code>heuristic</code> (the default is <code>heuristic</code>).
        An option with a value of <code>lexicon-expand=full</code>
        specifies that wildcards are resolved by expanding the pattern to
        words in a lexicon (if there is one available), and turning into a
        series of <code>cts:word-queries</code>, even if this takes a long
        time to evaluate.
        An option with a value of <code>lexicon-expand=prefix-postfix</code>
        specifies that wildcards are resolved by expanding the pattern to the
        pre- and postfixes of the words in the word lexicon (if there is one),
	and turning the query into a series of character queries, even if it
	takes a long time to evaluate.
	An option with a value of <code>lexicon-expand=off</code>
	specifies that wildcards are only resolved by looking up character
	patterns in the search pattern index, not in the lexicon.
	An option with a value of <code>lexicon-expand=heuristic</code>,
	which is the default, specifies that wildcards are resolved by using
	a series of internal rules, such as estimating the number of lexicon
	entries that need to be scanned, seeing if the estimate crosses
	certain thresholds, and (if appropriate), using another way besides
	lexicon expansion to resolve the query.
       	</dd>
        <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Relevance adjustment for the "distance-weight" option depends on
  the closest proximity of any two matches of the query.  For example,
  <pre xml:space="preserve">
  cts:word-query(("dog","cat"),("distance-weight=10"))
  </pre>
  will adjust relevance based on the distance between the closest pair of
  matches of either "dog" or "cat" (the pair may consist only of matches of
  "dog", only of matches of "cat", or a match of "dog" and a match of "cat").
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node containing the phrase
  'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation",
                   "case-insensitive"))
  =&gt; .. relevance-ordered sequence of 'function'
  element ancestors (or self) of any node containing
  the phrase 'MarkLogic Corporation' or any other
  case-shift like 'MarkLogic Corporation',
  'MARKLOGIC Corporation', etc.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.wordQuery("MarkLogic Corporation"));

  =&gt; .. A Sequence containing relevance-ordered
  documents containing the phrase 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.wordQuery("MarkLogic Corporation",
                   ["case-insensitive"]));

  =&gt; ..  A Sequence containing relevance-ordered
  documents containing the phrase 'MarkLogic Corporation'
  or any other case-shift like 'MarkLogic Corporation',
  'MARKLOGIC Corporation', etc.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//SPEECH,
    cts:word-query("to be, or not to be",
                   "punctuation-insensitive"))

  =&gt; .. relevance-ordered sequence of 'SPEECH'
  element ancestors (or self) of any node
  containing the phrase 'to be, or not to be',
  ignoring punctuation.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.wordQuery("to be, or not to be",
                   ["punctuation-insensitive"]));

  =&gt; .. relevance-ordered sequence of 'SPEECH'
  element ancestors (or self) of any node
  containing the phrase 'to be, or not to be',
  ignoring punctuation.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
   the following query uses the "synonym" option to make the
   terms "cat" and "kitty" treated the same for scoring
   purposes
:)
cts:search(fn:collection(),
   cts:word-query(("cat", "kitty"), "synonym") )
 =&gt; Returns relevance-ordered documents containing
    at least one of the specified terms, where the
    words "cat" and "kitty" are treated, for scoring
    purposes, as if they are both the word "cat".
    Without the synonym option, there would be one
    contribution to the score from "cat" matches and
    one from "kitty" matches.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   the following query uses the "synonym" option to make the
//   terms "cat" and "kitty" treated the same for scoring
//   purposes

cts.search(
   cts.wordQuery(["cat", "kitty"], ["synonym"]) );

 =&gt; Returns a Sequence containing relevance-ordered
    documents containing at least one of the specified terms,
    where the words "cat" and "kitty" are treated, for scoring
    purposes, as if they are both the word "cat".  Without
    the synonym option, there would be one contribution to
    the score from "cat" matches and one from "kitty" matches.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.wordQueryText(cts.wordQuery("choice of law"));
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 cts.wordQueryOptions(
    cts.wordQuery("MarkLogic, Corporation",
      ["case-sensitive", "punctuation-insensitive"]));

  =&gt; "case-sensitive", "punctuation-insensitive", "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.wordQueryWeight(cts.wordQuery("hello"));
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching specified nodes with a
  range-index entry compared to a given value.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:range-query</code>
  constructor require a range index;
  if there is no range index configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="index" type="cts:reference*">
    One or more range index references.
    When multiple indexes are specified,
    the query matches if any index matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*">
    One or more values to match.
    When multiple values are specified,
    the query matches if any value matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors, as in the last part of the example
  below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/dates.xml",
&lt;root&gt;
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
&lt;/root&gt;);

(:
   requires a range index of
   type xs:date on element "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:range-query(cts:element-reference(xs:QName("date")), "&lt;=",
      xs:date("2000-01-01")))
(:
  returns the following node:
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
:)
;
(:
   requires a range index of
   type xs:date on element "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:and-query((
   cts:range-query(cts:element-reference(xs:QName("date")), "&gt;",
      xs:date("2006-01-01")),
   cts:range-query(cts:element-reference(xs:QName("date")), "&lt;",
      xs:date("2008-01-01")))))
(:
  returns the following 2 nodes:
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
:)
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data
declareUpdate();
xdmp.documentInsert("/dates.xml",
xdmp.unquote('&lt;root&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;2007-01-01&lt;/date&gt;\n\
    &lt;info&gt;Some information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;2006-06-23&lt;/date&gt;\n\
    &lt;info&gt;Some other information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;1971-12-23&lt;/date&gt;\n\
    &lt;info&gt;Some different information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
&lt;/root&gt;'));

*****
//   requires a range index of
//   type xs.date on element "date"

const res = [];
for (const x of cts.search(
  cts.rangeQuery(cts.elementReference(xs.QName("date")), "&lt;=",
      xs.date("2000-01-01")))){
  res.push(x.xpath("/root/entry"));
};
res;
=&gt;
  returns an array with the following node:
[
   &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
]
*****
//   requires a range index of
//   type xs:date on element "date"

const res = new Array();
for (const x of cts.search(
  cts.andQuery((
   cts.rangeQuery(cts.elementReference(xs.QName("date")), "&gt;",
      xs.date("2006-01-01")),
   cts.rangeQuery(cts.elementReference(xs.QName("date")), "&lt;",
      xs.date("2008-01-01"))))) ) {
 res.push(x.xpath("/root/entry")); }
res;
=&gt;
  returns an array with the following 2 nodes:

  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="range-query-index" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the range index used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:range-query">
    A range query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:range-query(cts:element-reference(xs:QName("date")), "&lt;=",
      xs:date("2000-01-01"))
return
cts:range-query-index($query)
  =&gt; cts:element-reference(xs:QName("date"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.rangeQueryIndex(
  cts.rangeQuery(cts.elementReference(xs.QName("date")), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; cts.elementReference(xs.QName("date"))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:range-query">
    A range query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:range-query-operator($query)
  =&gt;
     &lt;=
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.rangeQueryOperator(
  cts.rangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt;
     &lt;=
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:range-query-value($query)
  =&gt;
     "2000-01-01" (as an xs.date)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.rangeQueryValue(
  cts.rangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt;
     "2000-01-01" (as an xs.date)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:range-query-options($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.rangeQueryOptions(
  cts.rangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.rangeQueryWeight(
  cts.rangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name with a
  range-index entry equal to a given value.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-range-query</code>
  constructor require an element range index on the specified QName(s);
  if there is no range index configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*">
    One or more element values to match.
    When multiple values are specified,
    the query matches if any value matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:element-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors, as in the last part of the example
  below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/dates.xml",
&lt;root&gt;
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
&lt;/root&gt;);

(:
   requires an element (range) index of
   type xs:date on "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01")))
(:
  returns the following node:
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
:)
;
(:
   requires an element (range) index of
   type xs:date on "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:and-query((
   cts:element-range-query(xs:QName("date"), "&gt;",
      xs:date("2006-01-01")),
   cts:element-range-query(xs:QName("date"), "&lt;",
      xs:date("2008-01-01")))))
(:
  returns the following 2 nodes:
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
:)
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data
declareUpdate();
xdmp.documentInsert("/dates.xml",
xdmp.unquote('&lt;root&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;2007-01-01&lt;/date&gt;\n\
    &lt;info&gt;Some information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;2006-06-23&lt;/date&gt;\n\
    &lt;info&gt;Some other information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
  &lt;entry&gt;\n\
    &lt;date&gt;1971-12-23&lt;/date&gt;\n\
    &lt;info&gt;Some different information.&lt;/info&gt;\n\
  &lt;/entry&gt;\n\
&lt;/root&gt;'));

*****
//   requires an element (range) index of
//   type xs.date on "date"

const res = [];
for (const x of cts.search(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")))){
  res.push(x.xpath("/root/entry"));
};
res;
=&gt;
  returns an array with the following node:
[
   &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
]
*****
//   requires an element (range) index of
//   type xs:date on "date"

const res = new Array();
for (const x of cts.search(
  cts.andQuery((
   cts.elementRangeQuery(xs.QName("date"), "&gt;",
      xs.date("2006-01-01")),
   cts.elementRangeQuery(xs.QName("date"), "&lt;",
      xs.date("2008-01-01"))))) ) {
 res.push(x.xpath("/root/entry")); }
res;
=&gt;
  returns an array with the following 2 nodes:

  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:element-range-query-element-name($query)
  =&gt; "date" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementRangeQueryElementName(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; "date" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:element-range-query-operator($query)
  =&gt;
     &lt;=
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementRangeQueryOperator(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt;
     &lt;=
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:element-range-query-value($query)
  =&gt;
     "2000-01-01" (as an xs.date)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementRangeQueryValue(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt;
     "2000-01-01" (as an xs.date)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:element-range-query-options($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementRangeQueryOptions(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01"))
return
cts:element-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementRangeQueryWeight(
  cts.elementRangeQuery(xs.QName("date"), "&lt;=",
      xs.date("2000-01-01")));
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching JSON properties by name with a
  range-index entry equal to a given value.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:json-property-range-query</code>
  constructor require a property range index on the specified names;
  if there is no range index configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more property name to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*" class="xquery">
    One or more property values to match.
    When multiple values are specified,
    the query matches if any value matches. The value must be a type for
    which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="value" type="any[]" class="javascript">
    One or more property values to match.
    When multiple values are specified,
    the query matches if any value matches. The value must be a type for
    which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:json-property-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Suppose there are three documents in the database :)

1.json:
{
  "entry" : {
    "date" : "2007-01-01",
    "info" : "Some information."
  }
}

2.json:
{
  "entry" : {
    "date" : "2006-06-23",
    "info" : "Some other information."
  }
}

3.json:
{
  "entry" : {
    "date" : "1971-12-23",
    "info" : "Some different information."
  }
}

(:
   requires a property (range) index of
   type xs:date on "date"
:)
cts:search(fn:collection(),
  cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01")))
(:
  returns the third document
:)

</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Suppose there are three documents in the database inserted
// as follows:

declareUpdate();
xdmp.documentInsert("/1.json",
{
  "entry" : {
    "date" : "2007-01-01",
    "info" : "Some information."
  }
});

xdmp.documentInsert("/2.json",
{
  "entry" : {
    "date" : "2006-06-23",
    "info" : "Some other information."
  }
});

xdmp.documentInsert("/3.json",
{
  "entry" : {
    "date" : "1971-12-23",
    "info" : "Some different information."
  }
});

******

//   requires a property (element) range index of
//   type xs:date on "date"

cts.search(
  cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01")));

//  returns the third document
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the JSON property name used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01"))
return
cts:json-property-range-query-property-name($query)
  =&gt; "date"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01"));
cts.jsonPropertyRangeQueryPropertyName(query);
  =&gt; "date"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01"))
return
cts:json-property-range-query-operator($query)
  =&gt; "&lt;="
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01"));
cts.jsonPropertyRangeQueryOperator(query);
  =&gt; "&lt;="
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01"))
return
cts:json-property-range-query-value($query)
  =&gt; 2000-01-01
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01"));
cts.jsonPropertyRangeQueryValue(query);
  =&gt; 2000-01-01
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01"))
return
cts:json-property-range-query-options($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01"));
cts.jsonPropertyRangeQueryOptions(query);
  =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-range-query("date", "&lt;=",
      xs:date("2000-01-01"))
return
cts:json-property-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyRangeQuery("date", "&lt;=",
      xs.date("2000-01-01"));
cts.jsonPropertyRangeQueryWeight(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching triples with a
  triple index entry equal to the given values. Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:triple-range-query</code> constructor require the triple index;
  if the triple index is not configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="subject" type="xs:anyAtomicType*">
    The subjects to look up.
    When multiple values are specified, the query matches if any value matches.
    When the empty sequence is specified, then triples with any subject are
    matched.
  </apidoc:param>
      <apidoc:param name="predicate" type="xs:anyAtomicType*">
    The predicates to look up.
    When multiple values are specified, the query matches if any value matches.
    When the empty sequence is specified, then triples with any predicate are
    matched.
  </apidoc:param>
      <apidoc:param name="object" type="xs:anyAtomicType*">
    The objects to look up.
    When multiple values are specified, the query matches if any value matches.
    When the empty sequence is specified, then triples with any object are
    matched.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string*" optional="true">
    If a single string is provided it is treated as the operator for the
    $object values. If a sequence of three strings are provided, they give
    the operators for $subject, $predicate and $object in turn.
    The default operator is "=".
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"sameTerm"</dt>
        <dd>Match triple index values which are the same RDF term as $value.
        This compares aspects of values that are ignored in XML Schema
	comparison semantics,
        like timezone and derived type of $value.</dd>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:triple-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:triple-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope
  factor will provide useful results. Using a slope factor greater than
  1 gives distinct scores over a smaller range of values, and produces
  generally higher scores.  Using a slope factor less than 1 gives distinct
  scores over a wider range of values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics" at
"/MarkLogic/semantics.xqy";
(: insert a couple of triples :)

sem:rdf-insert(
  sem:triple(sem:iri("http://example.com/ns/directory#m"),
             sem:iri("http://example.com/ns/person#firstName"),
             "Mark"),
  "override-graph=test1") ,
sem:rdf-insert(
  sem:triple(sem:iri("http://example.com/Mark"),
             sem:iri("http://example.com/ns/person#age"),
             37),
  "override-graph=test1")

 =&gt;
 /triplestore/46a9deab2e3d1e5a.xml
 /triplestore/b954ee9d04dc536d.xml


xquery version "1.0-ml";
import module namespace sem = "http://marklogic.com/semantics"
    at "/MarkLogic/semantics.xqy";
(: find all documents that have an embedded triple matching Mark-less-than-50 :)

let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return cts:search(fn:collection()//sem:triple, $query)

=&gt;
&lt;sem:triple xmlns:sem="http://marklogic.com/semantics"&gt;
  &lt;sem:subject&gt;http://example.com/Mark&lt;/sem:subject&gt;
  &lt;sem:predicate&gt;http://example.com/ns/person#age&lt;/sem:predicate&gt;
  &lt;sem:object
    datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;37&lt;/sem:object&gt;
&lt;/sem:triple&gt;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">

declareUpdate();
const sem = require("/MarkLogic/semantics.xqy");
// insert a couple of triples
// make sure the triple index is enabled on the database

const a = sem.rdfInsert(
  sem.triple(sem.iri("http://example.com/ns/directory#m"),
             sem.iri("http://example.com/ns/person#firstName"),
             "Mark"),
  "override-graph=test1");
const b = sem.rdfInsert(
  sem.triple(sem.iri("http://example.com/Mark"),
             sem.iri("http://example.com/ns/person#age"),
             37),
  "override-graph=test1");
const res = new Array();
res.push(a);
res.push(b);
res;

 =&gt;
 ["/triplestore/a805aaab9109e05f.xml", "/triplestore/d58262c00c3ab97f.xml"]

******
// find all documents that have an embedded triple matching Mark-less-than-50
//
// make sure the triple index is enabled on the database

const sem = require("/MarkLogic/semantics.xqy");
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
const res = [];
for (const x of cts.search(query)) {
	res.push(x.xpath("//sem.triple"));
};
res;

=&gt;
[
"&lt;sem:triple xmlns:sem="http://marklogic.com/semantics"&gt;
  &lt;sem:subject&gt;http://example.com/Mark&lt;/sem:subject&gt;
  &lt;sem:predicate&gt;http://example.com/ns/person#age&lt;/sem:predicate&gt;
  &lt;sem:object
    datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;37&lt;/sem:object&gt;
&lt;/sem:triple&gt;"
]

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-subject" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the subject value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-subject($query)
  =&gt; &lt;http://example.com/Mark&gt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQuerySubject(query);
  =&gt; &lt;http://example.com/Mark&gt;
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-predicate" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the predicate value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-predicate($query)
  =&gt; http://example.com/ns/person#age
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQueryPredicate(query);
  =&gt; http://example.com/ns/person#age
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-object" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the object value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-object($query)
  =&gt; 50
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQueryObject(query);
  =&gt; 50
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operators used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-operator($query)
  =&gt;
    =
    =
    &lt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQueryOperator(query);
  =&gt;
    =
    =
    &lt;
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-options($query)
  =&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQueryOptions(query);
  =&gt;  ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:triple-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:triple-range-query(
    sem:iri("http://example.com/Mark"),
    sem:iri("http://example.com/ns/person#age"),
    50,
    "&lt;")
return
cts:triple-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.tripleRangeQuery(
    sem.iri("http://example.com/Mark"),
    sem.iri("http://example.com/ns/person#age"),
    50,
    "&lt;");
cts.tripleRangeQueryWeight(query);
  =&gt;  1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching fields by name with a
  range-index entry equal to a given value.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-range-query</code>
  constructor require a field range index on the specified field name(s);
  if there is no range index configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-name" type="xs:string*">
    One or more field names to match. When multiple field names are specified,
    the query matches if any field name matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*" class="xquery">
    One or more field values to match.
    When multiple values are specified,
    the query matches if any value matches. The value must be a type for
    which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="value" type="any[]" class="javascript">
    One or more field values to match.
    When multiple values are specified,
    the query matches if any value matches. The value must be a type for
    which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:field-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:field-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives
  distinct scores over a smaller range of values, and produces
  generally higher scores.  Using a slope factor less than 1 gives
  distinct scores over a wider range of values, and produces generally
  lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Requires a field that includes name and excludes mname :)
(: Insert few documents with test data :)
let $content1 :=
 &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
let $content2 :=
 &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
let $content3 :=
 &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;
let $content4 :=
 &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
return (
xdmp:document-insert("/aname1.xml",$content1),
xdmp:document-insert("/aname2.xml",$content2),
xdmp:document-insert("/aname3.xml",$content3),
xdmp:document-insert("/aname4.xml",$content4));

(:
   requires a field (range) index of
   type xs:string on field "aname"
:)

cts:search(doc(),cts:field-range-query("aname","&gt;","Jim Kurla"));

(:
  returns the following:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;
  &lt;fname&gt;John&lt;/fname&gt;
  &lt;mname&gt;Rob&lt;/mname&gt;
  &lt;lname&gt;Goldings&lt;/lname&gt;
&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;
  &lt;fname&gt;Ooi&lt;/fname&gt;
  &lt;mname&gt;Ben&lt;/mname&gt;
  &lt;lname&gt;Fu&lt;/lname&gt;
&lt;/name&gt;
:)

(:
   requires a field (range) index of
   type xs:string on "aname"
:)
cts:contains(doc(),cts:field-range-query("aname","&gt;","Jim Kurla"))
(:
  returns "true".
:)
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Requires a field named "aname" that includes name and excludes mname
// and a field range index of type xs:string on the field.
//
// Insert few documents with test data
declareUpdate();
const content1 = xdmp.unquote(
 '&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;');
const content2 = xdmp.unquote(
 '&lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;');
const content3 = xdmp.unquote(
 '&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;');
const content4 = xdmp.unquote(
 '&lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;');
xdmp.documentInsert("/aname1.xml", content1);
xdmp.documentInsert("/aname2.xml", content2);
xdmp.documentInsert("/aname3.xml", content3);
xdmp.documentInsert("/aname4.xml", content4);

******

//   requires a field range index of
//   type xs:string on field "aname"

cts.search(cts.fieldRangeQuery("aname","&gt;","Jim Kurla"));

=&gt;

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;
  &lt;fname&gt;John&lt;/fname&gt;
  &lt;mname&gt;Rob&lt;/mname&gt;
  &lt;lname&gt;Goldings&lt;/lname&gt;
&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;
  &lt;fname&gt;Ooi&lt;/fname&gt;
  &lt;mname&gt;Ben&lt;/mname&gt;
  &lt;lname&gt;Fu&lt;/lname&gt;
&lt;/name&gt;

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the fieldname used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-range-query("aname","&gt;","Jim Kurla")
return
cts:field-range-query-field-name($query)
  =&gt; aname
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldRangeQuery("aname","&gt;","Jim Kurla");
cts.fieldRangeQueryFieldName(query);
  =&gt; aname
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-range-query("aname","&gt;","Jim Kurla")
return
cts:field-range-query-operator($query)
  =&gt; &gt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldRangeQuery("aname","&gt;","Jim Kurla");
cts.fieldRangeQueryOperator(query);
  =&gt; &gt;
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-range-query("aname","&gt;","Jim Kurla")
return
cts:field-range-query-value($query)
  =&gt; "Jim Kurla"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldRangeQuery("aname","&gt;","Jim Kurla");
cts.fieldRangeQueryValue(query);
  =&gt; "Jim Kurla"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-range-query("aname","&gt;","Jim Kurla")
return
cts:field-range-query-options($query)
  =&gt; collation=http://marklogic.com/collation/
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldRangeQuery("aname","&gt;","Jim Kurla");
cts.fieldRangeQueryOptions(query);
  =&gt; collation=http://marklogic.com/collation/
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-range-query("aname","&gt;","Jim Kurla")
return
cts:field-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldRangeQuery("aname","&gt;","Jim Kurla");
cts.fieldRangeQueryWeight(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="valid-index-path" type="builtin" lib="cts" category="SearchBuiltins" subcategory="XPath Validation">
    <apidoc:summary>
 Parses path expressions and resolves namespaces based on the server
 run-time environment. Returns <code xmlns="http://www.w3.org/1999/xhtml">true</code> if the argument is
 permissible as a path for indexing.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="string" type="xs:string">
    The path to be tested as a string.
  </apidoc:param>
      <apidoc:param name="ignorens" type="xs:boolean">
    Ignore namespace prefix binding errors.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-index-path("/aaa:a/bbb:b[1]/ccc:c",fn:false())
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-index-path("/a/b[c=/a/b/d]/p",fn:true())
  =&gt; false
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validIndexPath("/aaa:a/bbb:b[1]/ccc:c", false);
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validIndexPath("/a/b[c=/a/b/d]/p", true);
  =&gt; false
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="valid-tde-context" type="builtin" lib="cts" category="Template Driven Extraction">
    <apidoc:summary>
 Parses path expressions and resolves namespaces using the $map parameter.
 Returns <code xmlns="http://www.w3.org/1999/xhtml">true</code> if the argument is permissible as a context element
 in a TDE template.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="string" type="xs:string">
    The path to be tested as a string.
  </apidoc:param>
      <apidoc:param name="map" type="map:map?" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the evaluation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-tde-context("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";
  let $namespaces := map:map()
  let $_ := map:put($namespaces, "ns1", "http://example.org/myns")
  return cts:valid-tde-context("/ns1:foo/ns1:bar[@baz = '1']",$namespaces)
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validTdeContext("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validTdeContext("/ns1:foo/ns1:bar[@baz = '1']",{ns1:"http://example.org/myns"})
  =&gt; true
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="valid-optic-path" type="builtin" lib="cts" category="SearchBuiltins" subcategory="XPath Validation">
    <apidoc:summary>
 Parses path expressions and resolves namespaces using the $map parameter.
 Returns <code xmlns="http://www.w3.org/1999/xhtml">true</code> if the argument is permissible as a path for
 Optic op:xpath
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="string" type="xs:string">
    The path to be tested as a string.
  </apidoc:param>
      <apidoc:param name="map" type="map:map?" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the evaluation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-optic-path("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";
  let $namespaces := map:map()
  let $_ := map:put($namespaces, "ns1", "http://example.org/myns")
  return cts:valid-optic-path("/ns1:foo/ns1:bar[@baz = '1']",$namespaces)
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validOpticPath("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validOpticPath("/ns1:foo/ns1:bar[@baz = '1']",{ns1:"http://example.org/myns"})
  =&gt; true
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="valid-extract-path" type="builtin" lib="cts" category="SearchBuiltins" subcategory="XPath Validation">
    <apidoc:summary>
 Parses path expressions and resolves namespaces using the $map parameter.
 Returns <code xmlns="http://www.w3.org/1999/xhtml">true</code> if the argument is permissible as a path for
 extract-path option in extract-document-data
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="string" type="xs:string">
    The path to be tested as a string.
  </apidoc:param>
      <apidoc:param name="map" type="map:map?" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the evaluation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-extract-path("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";
  let $namespaces := map:map()
  let $_ := map:put($namespaces, "ns1", "http://example.org/myns")
  return cts:valid-extract-path("/ns1:foo/ns1:bar[@baz = '1']",$namespaces)
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validExtractPath("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validExtractPath("/ns1:foo/ns1:bar[@baz = '1']",{ns1:"http://example.org/myns"})
  =&gt; true
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="valid-document-patch-path" type="builtin" lib="cts" category="SearchBuiltins" subcategory="XPath Validation">
    <apidoc:summary>
 Parses path expressions and resolves namespaces using the $map parameter.
 Returns <code xmlns="http://www.w3.org/1999/xhtml">true</code> if the argument is permissible as a path for
 document PATCH.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="string" type="xs:string">
    The path to be tested as a string.
  </apidoc:param>
      <apidoc:param name="map" type="map:map?" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the evaluation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:valid-document-patch-path("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";
  let $namespaces := map:map()
  let $_ := map:put($namespaces, "ns1", "http://example.org/myns")
  return cts:valid-document-patch-path("/ns1:foo/ns1:bar[@baz = '1']",$namespaces)
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validDocumentPatchPath("/foo/bar[@baz = '1']")
  =&gt; true
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.validDocumentPatchPath("/ns1:foo/ns1:bar[@baz = '1']",{ns1:"http://example.org/myns"})
  =&gt; true
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching documents where the content
  addressed by an XPath expression satisfies the specified relationship
  (=, &lt;, &gt;, etc.) with respect to the input criteria values. A path range
  index must exist for each path when you perform a search.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="path-expression" type="xs:string*">
    One or more XPath expressions that identify the content to match.
    When multiple paths are specified, the query matches if any path matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*" class="xquery">
    One or more values to match. These values are compared to the value(s)
    addressed by the <code xmlns="http://www.w3.org/1999/xhtml">path-expression</code> parameter. When multiple
    When multiple values are specified, the query matches if any value
    matches. The value must be a type for which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="value" type="any[]" class="javascript">
    One or more values to match. These values are compared to the value(s)
    addressed by the <code xmlns="http://www.w3.org/1999/xhtml">path-expression</code> parameter. When multiple
    When multiple values are specified, the query matches if any value
    matches. The value must be a type for which there is a range index defined.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:path-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:path-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable
  <code>cts:query</code> constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
  <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">Use <a href="#cts.rangeQuery">cts.rangeQuery</a>
   if you need to include namespace bindings in your path range query.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Insert few documents with test data :)
xdmp:document-insert("/aname1.xml",
  &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname2.xml",
  &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname3.xml",
  &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname4.xml",
  &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;)

Requires a path (range) index of type xs:string on path "/name/fname".

cts:contains(doc(),cts:path-range-query("/name/fname","=","John"))
 =&gt; true

cts:search(doc(),cts:path-range-query("/name/fname","&gt;","Jim"),"filtered")
 =&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;

cts:search(doc(),cts:path-range-query("/name/fname","&lt;","John"),"unfiltered")
 =&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Insert few documents with test data.  Requires a
// path (range) index of type xs:string on path "/name/fname".

declareUpdate();
xdmp.documentInsert("/aname1.xml", fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;')
   ));
xdmp.documentInsert("/aname2.xml", fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;')
  ));
xdmp.documentInsert("/aname3.xml", fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;')
  ));
xdmp.documentInsert("/aname4.xml", fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;')
  ));

*****
// Requires a path (range) index of type xs:string on path "/name/fname".

cts.contains(fn.doc(),cts.pathRangeQuery("/name/fname","=","John"))
 =&gt; true

cts.search(cts.pathRangeQuery("/name/fname","&gt;","Jim"),"filtered");
 =&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;

cts.search(cts.pathRangeQuery("/name/fname","&lt;","John"),"unfiltered");
 =&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query-path-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the path expression used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-range-query("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs:double("3.13"))
return
cts:path-range-query-path-name($query)
  =&gt; /a/b/c
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.pathRangeQuery("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs.double("3.13"));
cts.pathRangeQueryPathName(query);
  =&gt; /a/b/c
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-range-query("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs:double("3.13"))
return
cts:path-range-query-operator($query)
  =&gt; &gt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.pathRangeQuery("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs.double("3.13"));
cts.pathRangeQueryOperator(query);
  =&gt; &gt;
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-range-query("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs:double("3.13"))
return
cts:path-range-query-value($query)
  =&gt; "Jim"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.pathRangeQuery("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs.double("3.13"));
cts.pathRangeQueryValue(query);
  =&gt; "Jim"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-range-query("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs:double("3.13"))
return
cts:path-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.pathRangeQuery("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs.double("3.13"));
cts.pathRangeQueryOptions(query);
  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-range-query("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs:double("3.13"))
return
cts:path-range-query-weight($query)
  =&gt; 3.13
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.pathRangeQuery("/a/b/c","&gt;","Jim",
  "collation=http://marklogic.com/collation/", xs.double("3.13"));
cts.pathRangeQueryWeight(query);
  =&gt; 3.13
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching elements by name with text content equal a
  given phrase.  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-value-query</code> only matches against
  simple elements (that is, elements that contain only text and have no element
  children).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="true">
    One or more element values to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
        <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    When you use the "exact" option, you should also enable
    "fast case sensitive searches" and "fast diacritic sensitive searches"
    in your database configuration.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Note that the text content for the value in a
  <code>cts:element-value-query</code> is treated the same as a phrase in a
  <code>cts:word-query</code>, where the phrase is the element value.
  Therefore, any wildcard and/or stemming rules are treated like a phrase.
  For example, if you have an element value of "hello friend" with wildcarding
  enabled for a query, a <code>cts:element-value-query</code> for "he*" will
  not match because the wildcard matches do not span word boundaries, but a
  <code>cts:element-value-query</code> for "hello *" will match.  A search
  for "*" will match, because a "*" wildcard by itself is defined to match
  the value.  Similarly, stemming rules are applied to each term, so a
  search for "hello friends" would match when stemming is enabled for the query
  because "friends" matches "friend". For an example, see the
  <a href="#evq4">fourth example</a> below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Similarly, because a "*" wildcard by itself is defined to match
  the value, the following query will match any element with the
  QName <code>my-element</code>, regardless of the wildcard indexes enabled in
  the database configuration:
  <pre><code>cts:element-value-query(xs:QName("my-element"), "*", "wildcarded")</code></pre>
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementValueQuery(
      xs.QName("function"),
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence of documents
  having 'function' elements whose text
  content equals 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"),
      "MarkLogic Corporation", "case-insensitive"))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation', or any other
  case-shift like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementValueQuery(
      xs.QName("function"),
      "MarkLogic Corporation", "case-insensitive"));

  =&gt; .. relevance-ordered sequence of documents
  having 'function' elements whose text
  content equals 'MarkLogic Corporation', or any other
  case-shift like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-value-query(
        xs:QName("function"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-value-query(
        xs:QName("title"),
        "Word Query"))))
  =&gt; .. relevance-ordered sequence of 'module' elements
  which are ancestors of both:
  (a) 'function' elements with text content equal to
      'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements with text content equal to
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.elementValueQuery(
        xs.QName("function"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts.elementValueQuery(
        xs.QName("title"),
        "Word Query")]));
  =&gt; .. relevance-ordered sequence of documents having both:
  (a) 'function' elements with text content equal to
      'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements with text content equal to
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $node := &lt;my-node&gt;hello friend&lt;/my-node&gt;
return (
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "hello friends", "stemmed")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "he*", "wildcarded")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "hello f*", "wildcarded"))
)

=&gt; true
   false
   true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const node = fn.head(xdmp.unquote('&lt;my-node&gt;hello friend&lt;/my-node&gt;')).root;
const res = new Array();
res.push(cts.contains(node, cts.elementValueQuery(xs.QName('my-node'),
      "hello friends", "stemmed")));
res.push(cts.contains(node, cts.elementValueQuery(xs.QName('my-node'),
      "he*", "wildcarded")));
res.push(cts.contains(node, cts.elementValueQuery(xs.QName('my-node'),
      "hello f*", "wildcarded")));
res;

=&gt; [true, false, true]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementValueQuery(
              xs.QName("function"),
              "MarkLogic Corporation");
cts.elementValueQueryElementName(query);

  =&gt; xs.QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-text($query)

  =&gt; "MarkLogic Corporation"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementValueQuery(
              xs.QName("function"),
              "MarkLogic Corporation");
cts.elementValueQueryText(query);

  =&gt; "MarkLogic Corporation"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-options($query)

  =&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementValueQuery(
              xs.QName("function"),
              "MarkLogic Corporation");
cts.elementValueQueryOptions(query);

  =&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-weight($query)

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementValueQuery(
              xs.QName("function"),
              "MarkLogic Corporation");
cts.elementValueQueryWeight(query);

  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching JSON properties by name with value equal the given
  value. For arrays, the query matches if the value of any elements in the array
  matches the given value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*">
    One or more property values to match. When multiple values are specified,
    the query matches if any value matches. The values can be strings, numbers
    or booleans. If the value is the empty sequence, the query matches null.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
        <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    When you use the "exact" option, you should also enable
    "fast case sensitive searches" and "fast diacritic sensitive searches"
    in your database configuration.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Note that the text content for the value in a
  <code>cts:json-property-value-query</code> is treated the same as a phrase in a
  <code>cts:word-query</code>, where the phrase is the property value.
  Therefore, any wildcard and/or stemming rules are treated like a phrase.
  For example, if you have an property value of "hello friend" with wildcarding
  enabled for a query, a <code>cts:json-property-value-query</code> for "he*" will
  not match because the wildcard matches do not span word boundaries, but a
  <code>cts:json-property-value-query</code> for "hello *" will match.  A search
  for "*" will match, because a "*" wildcard by itself is defined to match
  the value.  Similarly, stemming rules are applied to each term, so a
  search for "hello friends" would match when stemming is enabled for the query
  because "friends" matches "friend". For an example, see the
  <a href="#pvq4">fourth example</a> below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Similarly, because a "*" wildcard by itself is defined to match
  the value, the following query will match any property with the
  name <code>my-property</code>, regardless of the wildcard indexes enabled in
  the database configuration:
  <pre><code>cts:json-property-value-query("my-property", "*", "wildcarded")</code></pre>
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:json-property-value-query(
      "function",
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' property
  ancestors of 'function' properties whose text
  content equals 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.jsonPropertyValueQuery(
      "function",
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence of documents having 'function'
  properties whose text content equals 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:json-property-value-query(
      "function",
      "MarkLogic Corporation", "case-insensitive"))

  =&gt; .. relevance-ordered sequence of 'module' property
  ancestors of 'function' properties whose text
  content equals 'MarkLogic Corporation', or any other
  case-shift like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.jsonPropertyValueQuery(
      "function",
      "MarkLogic Corporation", "case-insensitive"));

  =&gt; .. relevance-ordered sequence of documents having 'function'
  properties whose text content equals 'MarkLogic Corporation',
  or any other case-shift like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:json-property-value-query(
        "function",
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:json-property-value-query(
        "title",
        "Word Query"))))
  =&gt; .. relevance-ordered sequence of 'module' properties
  which are ancestors of both:
  (a) 'function' properties with text content equal to
      'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' properties with text content equal to
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.jsonPropertyValueQuery(
        "function",
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts.jsonPropertyValueQuery(
        "title",
        "Word Query")]));
  =&gt; .. relevance-ordered sequence of documents which have both:

  (a) 'function' properties with text content equal to
      'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' properties with text content equal to
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</pre></apidoc:example>
    <apidoc:example class="xquery"><a id="pvq4" xmlns="http://www.w3.org/1999/xhtml"></a>
<pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: for a document foo.json with content like {"foo" : 1} :)
cts:contains(fn:doc("foo.json"), cts:json-property-value-query("foo",1))

=&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><a id="pvq4" xmlns="http://www.w3.org/1999/xhtml"></a>
<pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// for a document foo.json with content like {"foo" : 1}
cts.contains(cts.doc("foo.json"), cts.jsonPropertyValueQuery("foo",1));

=&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the JSON property name used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-value-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-value-query-property-name($query)

  =&gt; "function"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyValueQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyValueQueryPropertyName(query);

  =&gt; "function"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-value-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-value-query-value($query)

  =&gt;  "MarkLogic Corporation"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyValueQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyValueQueryValue(query);

  =&gt;  "MarkLogic Corporation"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-value-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-value-query-text($query)

  =&gt; "MarkLogic Corporation"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyValueQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyValueQueryText(query);

  =&gt; "MarkLogic Corporation"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-value-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-value-query-options($query)

  =&gt;  "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyValueQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyValueQueryOptions(query);

  =&gt;  "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-value-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-value-query-weight($query)

  =&gt;  1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyValueQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyValueQueryWeight(query);

  =&gt;  1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching elements by name with text content containing
  a given phrase.  Searches only through immediate text node children of
  the specified element as well as any text node children of child elements
  defined in the Admin Interface as element-word-query-throughs
  or phrase-throughs; does not search through any other children of
  the specified element.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*">
    Some words or phrases to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.
        The default value is 0.0 (no impact of proximity). The
        weight should be between 64 and -16.
        Weights greater than 64 will have the same effect as a
        weight of 64.
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that
        use score-simple, score-random, or score-zero (because those scoring
        algorithms do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
	<dt>"lexicon-expand=<em>value</em>"</dt>
	<dd>The <em>value</em> is one of <code>full</code>,
	<code>prefix-postfix</code>, <code>off</code>, or
	<code>heuristic</code> (the default is <code>heuristic</code>).
	An option with a value of <code>lexicon-expand=full</code>
	specifies that wildcards are resolved by expanding the pattern to
	words in a lexicon (if there is one available), and turning into a
        series of <code>cts:word-queries</code>, even if this takes a long
	time to evaluate.
	An option with a value of <code>lexicon-expand=prefix-postfix</code>
	specifies that wildcards are resolved by expanding the pattern to the
	pre- and postfixes of the words in the word lexicon (if there is one),
	and turning the query into a series of character queries, even if it
	takes a long time to evaluate.
	An option with a value of <code>lexicon-expand=off</code>
	specifies that wildcards are only resolved by looking up character
	patterns in the search pattern index, not in the lexicon.
	An option with a value of <code>lexicon-expand=heuristic</code>,
	which is the default, specifies that wildcards are resolved by using
	a series of internal rules, such as estimating the number of lexicon
	entries that need to be scanned, seeing if the estimate crosses
	certain thresholds, and (if appropriate), using another way besides
	lexicon expansion to resolve the query.
       	</dd>
 *      <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Relevance adjustment for the "distance-weight" option depends on
  the closest proximity of any two matches of the query.  For example,
  <pre xml:space="preserve">
  cts:element-word-query(xs:QName("p"),("dog","cat"),("distance-weight=10"))
  </pre>
  will adjust relevance based on the distance between the closest pair of
  matches of either "dog" or "cat" within an element named "p"
  (the pair may consist only of matches of
  "dog", only of matches of "cat", or a match of "dog" and a match of "cat").
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementWordQuery(
      xs.QName("function"),
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence of documents
  with elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"),
        "MarkLogic Corporation", "case-sensitive"))

  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation', case-sensitive (so 'MarkLogic Corporation'
  matches but 'MARKLOGIC Corporation' does not).
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementWordQuery(
      xs.QName("function"),
        "MarkLogic Corporation", "case-sensitive"));

  =&gt; .. relevance-ordered sequence of documents
  with elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation', case-sensitive (so 'MarkLogic Corporation'
  matches but 'MARKLOGIC Corporation' does not).
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-word-query(
        xs:QName("function"),
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
  (a) 'function' elements with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance
      score.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.elementWordQuery(
        xs.QName("function"),
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts.elementWordQuery(
        xs.QName("title"),
        "faster")]));

  =&gt; .. relevance-ordered sequence of documents having both:

  (a) 'function' elements with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance
      score.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:element-word-query(xs:QName("elem"), "choice of law")
  return
  cts:element-word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.elementWordQuery(xs.QName("elem"), "choice of law");
  cts.elementWordQueryText(query);
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:element-word-query(xs:QName("elem"), "choice of law")
  return
  cts:element-word-query-element-name($query)
  =&gt; xs:QName("elem")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.elementWordQuery(xs.QName("elem"), "choice of law");
  cts.elementWordQueryElementName(query);
  =&gt; xs.QName("elem")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:element-word-query(xs:QName("elem"), "choice of law")
  return
  cts:element-word-query-options($query)
  =&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.elementWordQuery(xs.QName("elem"), "choice of law");
  cts.elementWordQueryOptions(query);
  =&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:element-word-query(xs:QName("elem"), "choice of law")
  return
  cts:element-word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.elementWordQuery(xs.QName("elem"), "choice of law");
  cts.elementWordQueryWeight(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching JSON properties by name with text content containing
  a given phrase.  Searches only through immediate text node children of the
  specified property.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more JSON property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*">
    Some words or phrases to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.
        The default value is 0.0 (no impact of proximity). The
        weight should be between 64 and -16.
        Weights greater than 64 will have the same effect as a
        weight of 64.
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that
        use score-simple, score-random, or score-zero (because those scoring
        algorithms do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
  <dt>"lexicon-expand=<em>value</em>"</dt>
  <dd>The <em>value</em> is one of <code>full</code>,
  <code>prefix-postfix</code>, <code>off</code>, or
  <code>heuristic</code> (the default is <code>heuristic</code>).
  An option with a value of <code>lexicon-expand=full</code>
  specifies that wildcards are resolved by expanding the pattern to
  words in a lexicon (if there is one available), and turning into a
        series of <code>cts:word-queries</code>, even if this takes a long
  time to evaluate.
  An option with a value of <code>lexicon-expand=prefix-postfix</code>
  specifies that wildcards are resolved by expanding the pattern to the
  pre- and postfixes of the words in the word lexicon (if there is one),
  and turning the query into a series of character queries, even if it
  takes a long time to evaluate.
  An option with a value of <code>lexicon-expand=off</code>
  specifies that wildcards are only resolved by looking up character
  patterns in the search pattern index, not in the lexicon.
  An option with a value of <code>lexicon-expand=heuristic</code>,
  which is the default, specifies that wildcards are resolved by using
  a series of internal rules, such as estimating the number of lexicon
  entries that need to be scanned, seeing if the estimate crosses
  certain thresholds, and (if appropriate), using another way besides
  lexicon expansion to resolve the query.
        </dd>
 *    <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Relevance adjustment for the "distance-weight" option depends on
  the closest proximity of any two matches of the query.  For example,
  <pre xml:space="preserve">
  cts:json-property-word-query(xs:QName("p"),("dog","cat"),("distance-weight=10"))
  </pre>
  will adjust relevance based on the distance between the closest pair of
  matches of either "dog" or "cat" within a property named "p"
  (the pair may consist only of matches of
  "dog", only of matches of "cat", or a match of "dog" and a match of "cat").
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:json-property-word-query(
      "function",
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' properties
  ancestors (or self) of properties with name 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.jsonPropertyWordQuery(
      "function",
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence of documents
  having properties with name 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:json-property-word-query(
      "function",
      "MarkLogic Corporation", "case-sensitive"))

  =&gt; .. relevance-ordered sequence of 'module' properties
  ancestors (or self) of properties with name 'function'
  and text content containing the phrase 'MarkLogic
  Corporation',
  or any other case-shift, like 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.jsonPropertyWordQuery(
      "function",
      "MarkLogic Corporation", "case-sensitive"));

  =&gt; .. relevance-ordered sequence of documents
  having properties with name 'function'
  and text content containing the phrase 'MarkLogic
  Corporation',
  or any other case-shift, like 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:json-property-word-query(
        "function",
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts:json-property-word-query(
        "title",
        "faster"))))

  =&gt; .. relevance-ordered sequence of 'module' properties
  ancestors (or self) of both:
  (a) 'function' properties with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' properties containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance
      score.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.jsonPropertyWordQuery(
        "function",
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts.jsonPropertyWordQuery(
        "title",
        "faster")]));

  =&gt; .. relevance-ordered sequence of documents having both:

  (a) 'function' properties with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' properties containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance
      score.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:json-property-word-query("prop", "choice of law")
  return
  cts:json-property-word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.json-propertyWordQuery("prop", "choice of law");
  cts.jsonPropertyWordQueryText(query);
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the name used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:json-property-word-query("prop", "choice of law")
  return
  cts:json-property-word-query-property-name($query)
  =&gt; "prop"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.jsonPropertyWordQuery("prop", "choice of law");
  cts.jsonPropertyWordQueryPropertyName(query);
  =&gt; "prop"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:json-property-word-query("prop", "choice of law")
  return
  cts:json-property-word-query-options($query)
  =&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.jsonPropertyWordQuery("prop", "choice of law");
  cts.jsonPropertyWordQueryOptions(query);
  =&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $query := cts:json-property-word-query("prop", "choice of law")
  return
  cts:json-property-word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  const query = cts.json-propertyWordQuery("prop", "choice of law");
  cts.jsonPropertyWordQueryWeight(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching fields whose content contains the given
  phrase. If the specified field does not exist, this function
  throws an exception.  A field
  is a named object that specified elements to include and exclude
  from a search, and can include score weights for any included elements.
  You create fields at the database level using the Admin Interface.  For
  details on fields, see the chapter on "Fields Database Settings" in the
  <em xmlns="http://www.w3.org/1999/xhtml">Administrator's Guide</em>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-name" type="xs:string*">
    One or more field names to search over. If multiple field names are
    supplied, the match can be in any of the specified fields (or-query
    semantics).
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*">
    The word or phrase to match. If multiple strings are specified,
    the query matches if any of the words or phrases match (or-query
    semantics).
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.
        The default value is 0.0 (no impact of proximity). The
        weight should be between 64 and -16.
        Weights greater than 64 will have the same effect as a
        weight of 64.
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that
        use score-simple, score-random, or score-zero (because those scoring
        algorithms do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
	<dt>"lexicon-expand=<em>value</em>"</dt>
	<dd>The <em>value</em> is one of <code>full</code>,
	<code>prefix-postfix</code>, <code>off</code>, or
	<code>heuristic</code> (the default is <code>heuristic</code>).
	An option with a value of <code>lexicon-expand=full</code>
	specifies that wildcards are resolved by expanding the pattern to
	words in a lexicon (if there is one available), and turning into a
        series of <code>cts:word-queries</code>, even if this takes a long
	time to evaluate.
	An option with a value of <code>lexicon-expand=prefix-postfix</code>
	specifies that wildcards are resolved by expanding the pattern to the
	pre- and postfixes of the words in the word lexicon (if there is one),
	and turning the query into a series of character queries, even if it
	takes a long time to evaluate.
	An option with a value of <code>lexicon-expand=off</code>
	specifies that wildcards are only resolved by looking up character
	patterns in the search pattern index, not in the lexicon.
	An option with a value of <code>lexicon-expand=heuristic</code>,
	which is the default, specifies that wildcards are resolved by using
	a series of internal rules, such as estimating the number of lexicon
	entries that need to be scanned, seeing if the estimate crosses
	certain thresholds, and (if appropriate), using another way besides
	lexicon expansion to resolve the query.
       	</dd>
 *      <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:field-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with
  <code>cts:field-word-query</code>, the distance supplied in the near query
  applies to the whole document, not just to the field.  For example, if
  you specify a near query with a distance of 3, it will return matches
  when the words or phrases are within 3 words in the whole document,
  even if some of those words are not in the specified field.  For a code
  example illustrating this, see the
  <a href="#fqex2" class="xquery">second example</a>
  <a href="#fqex2j" class="javascript">second example</a>
  below. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Phrases are determined based on words being next to each other
  (word positions with a distance of 1) and words being in the same
  instance of the field.  Because field word positions
  are determined based on the fragment, not on the field, field phrases
  cannot span excluded elements (this is because MarkLogic Server breaks
  out of the field when it encounters the excluded element and start a new
  field when it encounters the next included element).  Similarly, field
  phrases will not span included sibling elements.  The
  <a href="#fqex2" class="xquery">second code example below</a>
  <a href="#fqex2j" class="javascript">second code example below</a>
  illustrates this. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Field phrases will automatically phrase-through all child elements of
  an included element, until it encounters an explicitly excluded
  element. The
  <a href="#fqex3" class="xquery">third example</a>
  <a href="#fqex3j" class="javascript">third example</a>
  below illustrates this.
  An example of when this automatic phrase-through behavior might be
  convenient is if you create a field that includes only the element
  <code>ABSTRACT</code>.  Then all child elements of <code>ABSTRACT</code>
  are included in the field, and phrases would span all of the child
  elements (that is, phrases would "phrase-through" all the child elements).</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Assume the database configuration includes a field named "myField"
 : on the paths /root/a/name and /root/b/name and a corresponding
 : field range index.
 :)

cts:search(fn:doc(), cts:field-word-query("myField", ("amy", "bill")))

(: Then the search matches all documents that contain either "amy" or
 : "bill" in the value of /root/a/name or /root/b/name (the field). 
 : For example, it would match this document:
 :
 :   &lt;root&gt;&lt;a&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/a&gt;&lt;/root&gt;
 :
 : But would not match this document:
 :
 :   &lt;root&gt;&lt;c&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/c&gt;&lt;/root&gt;
 :
 : By contrast, if you defined an element index on the element "name"
 : and queried using cts:element-word-query, both documents would match.
 :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Assume the database configuration includes a field named "myField"
// on the paths /root/a/name and /root/b/name and a corresponding
// field range index.

cts.search(cts.fieldWordQuery('myField', ['amy','bill']));

// Then the search matches all documents that contain either "amy" or
// "bill" in the value of /root/a/name or /root/b/name (the field). 
// For example, it would match this document:
//
//   &lt;root&gt;&lt;a&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/a&gt;&lt;/root&gt;
//
// But would not match this document because the path /root/c/name is
// not in the field definition:
//
//   &lt;root&gt;&lt;c&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/c&gt;&lt;/root&gt;
//
// By contrast, if you defined an element index on the element "name"
// and queried using cts:element-word-query, both documents would match.
</pre></apidoc:example>
    <apidoc:example class="xquery">
<a id="fqex2" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Assume the database configuration includes a field named "buzz"
 : on the path /hello/buzz, with localname "buzz" as an include and
 : localname "baz" as an exclude.
 :)

let $x :=
  &lt;hello&gt;word1 word2 word3
    &lt;buzz&gt;word4 word5&lt;/buzz&gt;
    &lt;baz&gt;word6 word7 word8&lt;/baz&gt;
    &lt;buzz&gt;word9 word10&lt;/buzz&gt;
  &lt;/hello&gt;
return (
  cts:contains($x, cts:near-query(
    (cts:field-word-query("buzz", "word5"),
     cts:field-word-query("buzz", "word9")), 3)),
  cts:contains($x, cts:near-query(
    (cts:field-word-query("buzz", "word5"),
     cts:field-word-query("buzz", "word9")), 4)),
  cts:contains($x,
    cts:field-word-query("buzz", "word5 word9")))

(:
 : Returns the sequence ("false", "true", "false").
 : The first part does not match because "word5" and "word9" do 
 : not occur within 3 words of each other; distance is calculated 
 : based on the whole node (or document if querying documents in 
 : the database), rather than on the field. The distance requirement
 : of the second near-query (4) is met, so the query matches and
 : returns true. The third query does not match because there
 : are words between "word5" and "word9", and the phrase is based
 : on the entire node, not on the field.
:)

</pre></apidoc:example>
    <apidoc:example class="javascript">
<a id="fqex2j" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">

// Assume the database configuration includes a field named "buzz"
// on the path /hello/buzz, with localname "buzz" as an include and
// localname "baz" as an exclude.

'use strict';

const content = fn.head(xdmp.unquote(
  '&lt;hello&gt;word1 word2 word3' +
    '&lt;buzz&gt;word4 word5&lt;/buzz&gt;' +
    '&lt;baz&gt;word6 word7 word8&lt;/baz&gt;' +
    '&lt;buzz&gt;word9 word10&lt;/buzz&gt;' +
  '&lt;/hello&gt;'));
const results = [
  cts.contains(content, cts.nearQuery(
    [cts.fieldWordQuery('buzz', 'word5'),
     cts.fieldWordQuery('buzz', 'word9')], 3)),
  cts.contains(content, cts.nearQuery(
    [cts.fieldWordQuery('buzz', 'word5'),
     cts.fieldWordQuery('buzz', 'word9')], 4)),
  cts.contains(content,
    cts.fieldWordQuery('buzz', 'word5 word9'))
];
results;

// Returns [false, true, false].
// The first part does not match because "word5" and "word9" do 
// not occur within 3 words of each other; distance is calculated 
// based on the whole node (or document if querying documents in 
// the database), rather than on the field. The distance requirement
// of the second near-query (4) is met, so the query matches and
// returns true. The third query does not match because there
// are words between "word5" and "word9", and the phrase is based
// on the entire node, not on the field.

</pre></apidoc:example>
    <apidoc:example class="xquery">
<a id="fqex3" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Assume the database configuration includes a field named "buzz"
 : on the path /hello/buzz, with localname "buzz" as an include and
 : localname "baz" as an exclude.
 :)
let $x :=
&lt;hello&gt;
  &lt;buzz&gt;word1 word2
    &lt;gads&gt;word3 word4 word5&lt;/gads&gt;
    &lt;zukes&gt;word6 word7 word8&lt;/zukes&gt;
  word9 word10
  &lt;/buzz&gt;
&lt;/hello&gt;
return (
cts:contains($x,
  cts:field-word-query("buzz", "word2 word3")))

(: Returns "true" because the children of "buzz" are not excluded, 
 : and are therefore automatically phrased through.
:)

</pre></apidoc:example>
    <apidoc:example class="javascript">
<a id="fqex3j" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Assume the database configuration includes a field named "buzz"
// on the path /hello/buzz, with localname "buzz" as an include and
// localname "baz" as an exclude.

const content = fn.head(xdmp.unquote(
  '&lt;hello&gt;' +
    '&lt;buzz&gt;word1 word2' +
      '&lt;gads&gt;word3 word4 word5&lt;/gads&gt;' +
      '&lt;zukes&gt;word6 word7 word8&lt;/zukes&gt;' +
    'word9 word10' +
    '&lt;/buzz&gt;' +
  '&lt;/hello&gt;'));
cts.contains(content,
  cts.fieldWordQuery('buzz', 'word2 word3'));

// Returns true because the children of "buzz" are not excluded, 
// and are therefore automatically phrased through.

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-text($query)

=&gt; "choice of law"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldWordQuery("myField", "choice of law");
cts.fieldWordQueryText(query);

=&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the names used to construct the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-field-name($query)

=&gt; "myField"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldWordQuery("myField", "choice of law");
cts.fieldWordQueryFieldName(query);

=&gt; "myField"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-options($query)

=&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldWordQuery("myField", "choice of law");
cts.fieldWordQueryOptions(query);

=&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-weight($query)

=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldWordQuery("myField", "choice of law");
cts.fieldWordQueryWeight(query);

=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching text content containing a given value in the
  specified field.  If the specified field does not exist,
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-value-query</code> throws an exception.
  If the specified field does not have the index setting
  <code xmlns="http://www.w3.org/1999/xhtml">field value searches</code> enabled, either for the database or
  for the specified field, then a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> with a
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-value-query</code> throws an exception. A field
  is a named object that specified elements to include and exclude
  from a search, and can include score weights for any included elements.
  You create fields at the database level using the Admin Interface.  For
  details on fields, see the chapter on "Fields Database Settings" in the
  <em xmlns="http://www.w3.org/1999/xhtml">Administrator's Guide</em>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-name" type="xs:string*">
    One or more field names to search over. If multiple field names are
    supplied, the match can be in any of the specified fields (or-query
    semantics).
  </apidoc:param>
      <apidoc:param name="text" type="xs:anyAtomicType*">
    The values to match. If multiple values are specified,
    the query matches if any of the values match (or-query
    semantics). For XML documents, the values should be strings.
    For JSON, the values can be strings, numbers or booleans.
    To match null, pass in the empty sequence.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.
        The default value is 0.0 (no impact of proximity). The
        weight should be between 64 and -16.
        Weights greater than 64 will have the same effect as a
        weight of 64.
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that
        use score-simple or score-random (because those scoring algorithms
        do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
        <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:field-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with
  <code>cts:field-value-query</code>, the distance supplied in the near query
  applies to the whole document, not just to the field.  For example, if
  you specify a near query with a distance of 3, it will return matches
  when the values are within 3 words in the whole document,
  For a code example illustrating this, see the
  <a href="#fqex2" class="xquery">second example</a>
  <a href="#fqex2j" class="javascript">second example</a>
  below. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Values are determined based on words (tokens)of values of elements that are
  included in the field. Field values span all the included elements. They
  cannot span excluded elements (this is because MarkLogic Server breaks
  out of the field when it encounters the excluded element and start it again
  field when it encounters the next included element). Field
  values will also span included sibling elements.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    When you use the "exact" option, you should also enable
    "fast case sensitive searches" and "fast diacritic sensitive searches"
    in your database configuration.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $contents :=
  &lt;Employee&gt;
    &lt;name&gt;
      &lt;fname&gt;Jaz&lt;/fname&gt;
      &lt;mname&gt;Roy&lt;/mname&gt;
      &lt;lname&gt;Smith&lt;/lname&gt;
    &lt;/name&gt;
  &lt;/Employee&gt;
return
cts:contains($contents,cts:field-value-query("myField","Jaz Roy Smith"))

=&gt; false, assuming the field "myField" is defined to include element
   "name" and exclude element "mname". The field must exist in the
   database against which this query is evaluated.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const contents = fn.head(xdmp.unquote(
'  &lt;Employee&gt;\n\
    &lt;name&gt;\n\
      &lt;fname&gt;Jaz&lt;/fname&gt;\n\
      &lt;mname&gt;Roy&lt;/mname&gt;\n\
      &lt;lname&gt;Smith&lt;/lname&gt;\n\
    &lt;/name&gt;\n\
  &lt;/Employee&gt;'));
cts.contains(contents,
	cts.fieldValueQuery("myField","Jaz Roy Smith"));

=&gt; false, assuming the field "myField" is defined to include element
   "name" and exclude element "mname". The field must exist in the
   database against which this query is evaluated.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $contents :=
  &lt;Employee&gt;
    &lt;name&gt;
      &lt;fname&gt;Jaz&lt;/fname&gt;
      &lt;mname&gt;Roy&lt;/mname&gt;
      &lt;lname&gt;Smith&lt;/lname&gt;
    &lt;/name&gt;
  &lt;/Employee&gt;
return
cts:contains($contents,cts:field-value-query("myField","Jaz Smith"))

=&gt; true, assuming the field "myField" is defined to include element
   "name" and exclude element "mname". The field must exist in
   the database against which this query is evaluated.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const contents = fn.head(xdmp.unquote(
'  &lt;Employee&gt;\n\
    &lt;name&gt;\n\
      &lt;fname&gt;Jaz&lt;/fname&gt;\n\
      &lt;mname&gt;Roy&lt;/mname&gt;\n\
      &lt;lname&gt;Smith&lt;/lname&gt;\n\
    &lt;/name&gt;\n\
  &lt;/Employee&gt;'));
cts.contains(contents,
	cts.fieldValueQuery("myField","Jaz Smith"));

=&gt; true, assuming the field "myField" is defined to include element
   "name" and exclude element "mname". The field must exist in
   the database against which this query is evaluated.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
In this query, the search is fully resolved in the index.

cts:search(
  fn:doc("/Employee/jaz.xml"),
  cts:field-value-query("myField","Jaz Smith"),
  "unfiltered")

=&gt; Returns the doc which has field "myField" and a match
   with the value of the field.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// In this query, the search is fully resolved in the index.

cts.search(
  cts.fieldValueQuery("myField","Jaz Smith"),
  "unfiltered")

=&gt; Returns the document which has field "myField" and a match
   with the value of the field.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the values used to construct the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-value-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-value-query("myField", "choice of law")
return
cts:field-value-query-text($query)

=&gt; "choice of law"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldValueQuery("myField", "choice of law");
cts.fieldValueQueryText(query);

=&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the names used to construct the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-value-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-value-query("myField", "choice of law")
return
cts:field-value-query-field-name($query)

=&gt; "myField"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldValueQuery("myField", "choice of law");
cts.fieldValueQueryFieldName(query);

=&gt; "myField"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-value-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-value-query("myField", "choice of law")
return
cts:field-value-query-options($query)

=&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldValueQuery("myField", "choice of law");
cts.fieldValueQueryOptions(query);

=&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-value-query("myField", "choice of law")
return
cts:field-value-query-weight($query)

=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.fieldValueQuery("myField", "choice of law");
cts.fieldValueQueryWeight(query);

=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching element-attributes by name with a
  range-index entry equal to a given value.  Searches with the
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-attribute-range-query</code>
  constructor require an attribute range index on the specified QName(s);
  if there is no range index configured, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*">
    One or more attribute QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string">
    A comparison operator.
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*">
    Some values to match.
    When multiple values are specified,
    the query matches if any value matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $value parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:element-attribute-range-query</code> constructors together
  with <code>cts:and-query</code> or other composable <code>cts:query</code>
  constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/attributes.xml",
&lt;root&gt;
  &lt;entry sku="100"&gt;
    &lt;product&gt;apple&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="200"&gt;
    &lt;product&gt;orange&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
&lt;/root&gt;) ;

(:
   requires an attribute (range) index of
   type xs:int on the "sku" attribute of
   the "entry" element
:)
cts:search(doc("/attributes.xml")/root/entry,
  cts:element-attribute-range-query(
      xs:QName("entry"), xs:QName("sku"), "&gt;=",
      500))
(:
  returns the following node:
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
:)
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data
declareUpdate();
xdmp.documentInsert("/attribute1.xml", fn.head(xdmp.unquote(
'&lt;root&gt;\n\
  &lt;entry sku="100"&gt;\n\
    &lt;product&gt;apple&lt;/product&gt;\n\
  &lt;/entry&gt;\n\
&lt;/root&gt;'))) ;
xdmp.documentInsert("/attribute2.xml", fn.head(xdmp.unquote(
'&lt;root&gt;\n\
  &lt;entry sku="200"&gt;\n\
    &lt;product&gt;orange&lt;/product&gt;\n\
  &lt;/entry&gt;\n\
&lt;/root&gt;'))) ;
xdmp.documentInsert("/attribute3.xml", fn.head(xdmp.unquote(
'&lt;root&gt;\n\
  &lt;entry sku="1000"&gt;\n\
    &lt;product&gt;electric car&lt;/product&gt;\n\
  &lt;/entry&gt;\n\
&lt;/root&gt;'))) ;

******
//   requires an attribute (range) index of
//   type xs:int on the "sku" attribute of
//   the "entry" element

cts.search(
  cts.elementAttributeRangeQuery(
      xs.QName("entry"), xs:QName("sku"), "&gt;=",
      500));

//  returns the following document (with URI "/attribute3.xml"):
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
&lt;/root&gt;

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryElementName(query);

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-attribute-name($query)

  =&gt; xs:QName("name")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryAttributeName(query);

  =&gt; xs:QName("name")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-operator($query)

  =&gt; "&gt;"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryOperator(query);

  =&gt; "&gt;"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-value($query)

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryValue(query);

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-options($query)

  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryOptions(query);

  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"), "&gt;",
              "MarkLogic Corporation")
return cts:element-attribute-range-query-weight($query)

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeRangeQuery(
              xs.QName("function"),
              xs.QName("name"), "&gt;",
              "MarkLogic Corporation");
cts.elementAttributeRangeQueryWeight(query);

  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching elements by name with attributes by name
  with text content equal a given phrase.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*">
    One or more attribute QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*">
    One or more attribute values to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
 *      <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    When you use the "exact" option, you should also enable
    "fast case sensitive searches" and "fast diacritic sensitive searches"
    in your database configuration.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-value-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of 'function' elements that have
  an attribute 'type' whose value equals 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementAttributeValueQuery(
      xs.QName("function"),
      xs.QName("type"),
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence of documents
  having 'function' elements that have
  an attribute 'type' whose value equals 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-value-query(
        xs:QName("function"),
        xs:QName("type"),
        "MarkLogic Corporation",
        (), 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
   (a) 'function' elements with attribute 'type' whose
       value equals the string 'MarkLogic Corporation',
       ignoring embedded punctuation,
   AND
   (b) 'title' elements whose text content contains the
       word 'faster', with the results from (a) given
       weight 0.5, and the results from (b) given default
       weight 1.0.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.elementAttributeValueQuery(
        xs.QName("function"),
        xs.QName("type"),
        "MarkLogic Corporation",
        null, 0.5),
      cts.elementWordQuery(
        xs.QName("title"),
        "faster")]));

  =&gt; .. relevance-ordered sequence documents having both:
   (a) 'function' elements with attribute 'type' whose
       value equals the string 'MarkLogic Corporation',
       ignoring embedded punctuation,
   AND
   (b) 'title' elements whose text content contains the
       word 'faster', with the results from (a) given
       weight 0.5, and the results from (b) given default
       weight 1.0.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-value-query-text($query)

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeValueQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeValueQueryText(query);

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the element QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-value-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeValueQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeValueQueryElementName(query);

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the attribute QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-value-query-attribute-name($query)

  =&gt; xs:QName("name")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeValueQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeValueQueryAttributeName(query);

  =&gt; xs.QName("name")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-value-query-options($query)

  =&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeValueQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeValueQueryOptions(query);

  =&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-value-query-weight($query)

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeValueQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeValueQueryWeight(query);

  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching elements by name
  with attributes by name
  with text content containing a given phrase.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*">
    One or more attribute QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*">
    Some words or phrases to match.
    When multiple strings are specified,
    the query matches if any string matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd>
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive",
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $text parameter are
        considered synonyms for scoring purposes.  The result is that
        occurrences of more than one of the synonyms are scored as if
        there are more occurrences of the same term (as opposed to
        having a separate term that contributes to score). </dd>
	<dt>"lexicon-expand=<em>value</em>"</dt>
	<dd>The <em>value</em> is one of <code>full</code>,
	<code>prefix-postfix</code>, <code>off</code>, or
	<code>heuristic</code> (the default is <code>heuristic</code>).
	An option with a value of <code>lexicon-expand=full</code>
	specifies that wildcards are resolved by expanding the pattern to
	words in a lexicon (if there is one available), and turning into a
        series of <code>cts:word-queries</code>, even if this takes a long
	time to evaluate.
	An option with a value of <code>lexicon-expand=prefix-postfix</code>
	specifies that wildcards are resolved by expanding the pattern to the
	pre- and postfixes of the words in the word lexicon (if there is one),
	and turning the query into a series of character queries, even if it
	takes a long time to evaluate.
	An option with a value of <code>lexicon-expand=off</code>
	specifies that wildcards are only resolved by looking up character
	patterns in the search pattern index, not in the lexicon.
	An option with a value of <code>lexicon-expand=heuristic</code>,
	which is the default, specifies that wildcards are resolved by using
	a series of internal rules, such as estimating the number of lexicon
	entries that need to be scanned, seeing if the estimate crosses
	certain thresholds, and (if appropriate), using another way besides
	lexicon expansion to resolve the query.
       	</dd>
 *      <dt>"lexicon-expansion-limit=<em>number</em>"</dt>
        <dd>Specifies the limit for lexicon expansion. This puts a restriction
  on the number of lexicon expansions that can be performed. If the limit is
  exceeded, the server may raise an error depending on whether the "limit-check"
  option is set. The default value for this option will be 4096.
        </dd>
        <dt>"limit-check"</dt>
        <dd>Specifies that an error will be raised if the lexicon expansion
  exceeds the specified limit.</dd>
        <dt>"no-limit-check"</dt>
        <dd>Specifies that error will not be raised if the lexicon expansion
  exceeds the specified limit. The server will try to resolve the wildcard.
        </dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive"
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive"
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded"
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the
    wildcard characters '?' or '*', it specifies "wildcarded".
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed"
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".
    Otherwise it specifies "unstemmed".
    If the query is a wildcarded query and also a phrase query
    (contains two or more terms), the wildcard terms in the query
    are unstemmed.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementAttributeWordQuery(
      xs.QName("function"),
      xs.QName("type"),
      "MarkLogic Corporation"));

  =&gt; .. relevance-ordered sequence documents
  having 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation", "case-insensitive"))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation', or any other case-shift,
  like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.elementAttributeWordQuery(
      xs.QName("function"),
      xs.QName("type"),
      "MarkLogic Corporation", ["case-insensitive"]));

  =&gt; .. relevance-ordered sequence documents
  having 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation', or any other case-shift,
  like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-word-query(
        xs:QName("function"),
        xs:QName("type"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of both:
  (a) 'function' elements with 'type' attribute whose value
      contains the phrase 'MarkLogic Corporation',
      ignoring embedded punctuation,
  AND
  (b) 'title' elements whose text content contains the
      term 'faster',
  with the results of the first query given weight 0.5,
  as opposed to the default 1.0 for the second query.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.andQuery([
      cts.elementAttributeWordQuery(
        xs.QName("function"),
        xs.QName("type"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts.elementWordQuery(
        xs.QName("title"),
        "faster")]));

  =&gt; .. relevance-ordered sequence of documents having both:

  (a) 'function' elements with 'type' attribute whose value
      contains the phrase 'MarkLogic Corporation',
      ignoring embedded punctuation,
  AND
  (b) 'title' elements whose text content contains the
      term 'faster',
  with the results of the first query given weight 0.5,
  as opposed to the default 1.0 for the second query.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-word-query-text($query)

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeWordQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeWordQueryText(query);

  =&gt; MarkLogic Corporation
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the element QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-word-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeWordQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeWordQueryElementName(query);

  =&gt; xs.QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the attribute QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-word-query-attribute-name($query)

  =&gt; xs:QName("name")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeWordQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeWordQueryAttributeName(query);

  =&gt; xs.QName("name")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-word-query-options($query)

  =&gt; "lang=en"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeWordQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeWordQueryOptions(query);

  =&gt; "lang=en"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-word-query-weight($query)

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementAttributeWordQuery(
              xs.QName("function"),
              xs.QName("name"),
              "MarkLogic Corporation");
cts.elementAttributeWordQueryWeight(query);

  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching nodes similar to the model nodes.  It uses an
  algorithm which finds the most "relevant" terms in the model nodes
  (that is, the terms with the highest scores), and then creates a
  query equivalent to a <code xmlns="http://www.w3.org/1999/xhtml">cts:or-query</code> of those terms.  By default
  16 terms are used.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*">
    Some model nodes.
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
      <apidoc:param name="options" type="element()?" optional="true">
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">An XML representation of</span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">An object containing</span> the options for defining
    which terms to generate and how to evaluate them.
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">The options node must be in the
    <code>cts:distinctive-terms</code> namespace.</span> The following is
    a sample options <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">node</span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">object</span>:
    <pre xml:space="preserve" class="xquery" xmlns="http://www.w3.org/1999/xhtml"><br/>
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt; </pre>
    <pre xml:space="preserve" class="javascript" xmlns="http://www.w3.org/1999/xhtml"><br/>
    {
      maxTerms: 20
    }
    </pre>

    <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">See <a href="cts:distinctive-terms#db-term-options">the
    <code>cts:distinctive-terms</code>
    options</a> for the valid options to use with this function.</p>
    <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">See
    <a href="cts.distinctiveTerms#db-term-options">the
    <code>cts.distinctiveTerms</code>
    options</a> for the valid options to use with this function.</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Note that enabling index settings that
    are disabled in the database configuration will not affect the results,
    as similar documents will not be found on the basis of terms that do
    not exist in the actual database index.</p>

  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:similar-query</apidoc:return>
    <apidoc:usage>
   As the number of fragments in a database grows, the results
   of <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>cts:similar-query</code></span>
   <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><code>cts.similarQuery</code></span> become
   increasingly accurate. For best results, there should be at least 10,000
   fragments for 32-bit systems, and 1,000 fragments for 64-bit systems.
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:similar-query((//function)[1]))
  <br/>
  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node similar to the first
  'function' element.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xdmp:estimate(
  cts:search(//function,
    cts:similar-query((//function)[1], (),
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)))
=&gt; the number of fragments containing any node similar
   to the first 'function' element.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  // Note that although the API is defined as taking string
  // representations of nodes, MarkLogic will automatically convert
  // sequences of nodes to an array of their string representation
  // when required.
  cts.search(
    cts.similarQuery(fn.doc("nodes-like-this.xml"),
                     2, { maxTerms: 20 })
    );
=&gt; the number of fragments containing any node similar
   to 'nodes-like-this.xml'.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the nodes used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:similar-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:similar-query(fn:doc("/mydoc.xml"))
return cts:similar-query-nodes($query)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.similarQuery(cts.doc("/mydoc.xml"));
cts.similarQueryNodes(query);

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:similar-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:similar-query(fn:doc("/mydoc.xml"))
return cts:similar-query-weight($query)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.similarQuery(cts.doc("/mydoc.xml"));
cts.similarQueryWeight(query);

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns true if any of a sequence of values matches a query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="item()*">
    The nodes or atomic values to be checked for a match. Atomic
    values are converted to a text node before checking for a match,
    which may result in an error if the value cannot be converted.
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">If you pass in a single value,
  it is treated as a Sequence with that single item; therefore, if you
  pass in an array, the function will return the array. If you mean to check
  the values of each item in the array, then you can call
  <a href="#xdmp.arrayValues">xdmp.arrayValues</a> on the array. </span>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query">
    A query to match against.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:contains(//PLAY
  [TITLE="The Tragedy of Hamlet, Prince of Denmark"]
      /ACT[3]/SCENE[1],
    cts:word-query("To be, or not to be"))
  =&gt; ..true, if ACT II, SCENE I of Hamlet contains
    the phrase "To be, or not to be" (it does).
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const j = {"my-property":"hello"} ;
cts.contains(j, cts.jsonPropertyWordQuery("my-property", "hello"))

// returns true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="search" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns a relevance-ordered sequence of nodes specified by a given query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="expression" type="node()*" class="xquery">
    An expression to be searched.
    This must be an inline fully searchable path expression.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?">
    A <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:query</code>
    <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.query</code>
    specifying the search to perform.  If a string is entered, the string is
    treated as a <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code>
    <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.wordQuery</code> of the specified string.
  </apidoc:param>
      <apidoc:param name="options" type="(cts:order|xs:string)*" optional="true">
    Options to this search.  The default is ().
    <a id="unfiltered" xmlns="http://www.w3.org/1999/xhtml"></a><p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt><p>"filtered"</p></dt>
        <dd><p>A filtered search (the default). Filtered searches
        eliminate any false-positive matches and properly resolve cases where
        there are multiple candidate matches within the same fragment.
        Filtered search results fully satisfy the specified
        <code>cts:query</code>.</p>
        </dd>
        <dt><p>"unfiltered"</p></dt>
        <dd><p>
        An unfiltered search.  An unfiltered search
        selects fragments from the indexes that are candidates to satisfy
        the specified <code>cts:query</code>, and then it returns
        a single node from within each fragment that satisfies the specified
        searchable path expression. Unfiltered searches are useful because
        of the performance they afford when jumping deep into the
        result set (for example, when paginating a long result set and
        jumping to the 1,000,000th result). However, depending on the
        searchable path expression, the
        <code>cts:query</code> specified, the structure of the documents in
        the database, and the configuration of the database, unfiltered
        searches may yield false-positive results being included in the
        search results.  Unfiltered searches may also result in missed
        matches or in incorrect matches, especially when there are
        multiple candidate matches within a single fragment.
        To avoid these problems, you should only use unfiltered searches
        on top-level XPath expressions (for example, document nodes,
        collections, directories) or on fragment roots. Using unfiltered
        searches on complex XPath expressions or on XPath expressions that
        traverse below a fragment root can result in unexpected results.</p>
        </dd>
        <dt><p>"score-logtfidf"</p></dt>
        <dd><p>Compute scores using the logtfidf method (the default scoring
        method). This uses the formula: <br/><br/>
          <code>log(term frequency) * (inverse document frequency)
        </code></p></dd>
        <dt><p>"score-logtf"</p></dt>
        <dd><p>Compute scores using the logtf method. This does not take into
        account how many documents have the term and uses the formula: <br/>
        <br/>
          <code>log(term frequency)</code></p></dd>
        <dt><p>"score-simple"</p></dt>
        <dd><p>Compute scores using the simple method. The score-simple
        method gives a score of 8*weight for each matching term in the
        <code>cts:query</code> expression, and then scales the score up by
	multiplying by 256. It does not matter how
        many times a given term matches (that is, the term
        frequency does not matter); each match contributes 8*weight
        to the score.  For example, the following query  (assume the
        default weight of 1) would give a score of 8*256=2048 for
        any fragment with one or more matches for "hello", a score of
	16*256=4096
        for any fragment that also has one or more matches for "goodbye",
        or a score of zero for fragments that have no matches for
        either term:<br/><br/>
          <code>cts:or-query(("hello", "goodbye"))</code></p></dd>
        <dt><p>"score-random"</p></dt>
        <dd><p>Compute scores using the random method. The score-random
        method gives a random value to the score.  You can use this
        to randomly choose fragments matching a query.</p></dd>
        <dt><p>"score-zero"</p></dt>
        <dd><p>Compute all scores as zero.
        When combined with a quality weight of zero,
        this is the fastest consistent scoring method.</p></dd>
        <dt>"checked"</dt>
        <dd><p>Word positions are checked (the default) when resolving
        the query. Checked searches eliminate false-positive matches for
        phrases during the index resolution phase of search processing.</p></dd>
        <dt>"unchecked"</dt>
        <dd><p>Word positions are not checked when resolving the
        query.  Unchecked searches do not take into account word positions
        and can lead to false-positive matches during the index resolution
        phase of search processing.  This setting is useful
        for debugging, but not recommended for normal use.</p></dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"faceted"</dt>
        <dd><p>Do a little more work to save faceting information about
        fragments matching this search so that calculating facets
        will be faster.</p></dd>
        <dt>"unfaceted"</dt>
        <dd><p>Do not save faceting information about fragments matching
        this search.</p></dd>
        <dt>"relevance-trace"</dt>
        <dd><p>Collect relevance score computation details with which you
        can generate a trace report using <code>cts:relevance-info</code>.
        Collecting this information is costly and will significantly
        slow down your search, so you should only use it when using
        <code>cts:relevance-info</code> to tune a query.</p></dd>
        <dt>"format-<em>FORMAT</em>"</dt>
        <dd><p>Limit the search to documents in document format specified
        by <em>FORMAT</em> (binary, json, text, or xml)</p></dd>
	<dt class="javascript">"any"</dt>
        <dd class="javascript">Search from any fragment.</dd>
        <dt class="javascript">"document"</dt>
        <dd class="javascript">Search from document fragments.</dd>
        <dt class="javascript">"properties"</dt>
        <dd class="javascript">Search only from properties fragments.</dd>
        <dt class="javascript">"locks"</dt>
        <dd class="javascript">search only from locks fragments.</dd>
        <dt><em>cts:order Specification</em></dt>
        <dd><p>A sequence of <code>cts:order</code> specifications. The order
	is evaluated in the order each appears in the sequence.  The sequence
	typically consists of one or more of:
	<code><a href="#cts:index-order">cts:index-order</a></code>,
	<code><a href="#cts:score-order">cts:score-order</a></code>,
	<code><a href="#cts:confidence-order">cts:confidence-order</a></code>,
	<code><a href="#cts:fitness-order">cts:fitness-order</a></code>,
	<code><a href="#cts:quality-order">cts:quality-order</a></code>,
	<code><a href="#cts:document-order">cts:document-order</a></code>,
	<code><a href="#cts:unordered">cts:unordered</a></code>.  When using
	<code>cts:index-order</code>, there must be a range index defined
	on the index(es) specified by the <code>cts:reference</code>
        specification (for example,
     <code><a href="#cts:element-reference">cts:element-reference</a></code>.)
	</p></dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is (). In the XQuery version, you can use
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> with this
    parameter and an empty <code xmlns="http://www.w3.org/1999/xhtml">cts:and-query</code> to specify a
    forest-specific XPath statement (see the <a href="#searchEx3" xmlns="http://www.w3.org/1999/xhtml">third
    example</a> below). If you
    use this to constrain an XPath to one or more forests, you should set
    the <code xmlns="http://www.w3.org/1999/xhtml">quality-weight</code> to zero to keep the XPath document
    order.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:usage>
<p class="xquery" xmlns="http://www.w3.org/1999/xhtml">Queries that use <code>cts:search</code> require that
the XPath expression
searched is fully searchable. A <em>fully searchable</em> path is one that
has no steps that are unsearchable and whose last step is searchable.
You can use the
<code>xdmp:query-trace()</code> function to see if the path is fully
searchable. If there are no entries in the <code>xdmp:query-trace()</code>
output indicating that a step is unsearchable, and if the last step
is searchable, then that path is fully
searchable. Queries that use <code>cts:search</code> on unsearchable
XPath expressions will fail with an error message. You can often make
the path expressions fully searchable by rewriting the query or adding
new indexes.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Each node that
<code class="xquery">cts:search</code><code class="javascript">cts.search</code> returns has a score with which
it is associated. To access the score, use the
<code class="xquery">cts:score</code><code class="javascript">cts.score</code>
function. The nodes are returned in relevance order (most relevant to least
relevant), where more relevant nodes have a higher score.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "filtered" or "unfiltered" options may be specified
in the options parameter. If neither "filtered" nor "unfiltered", is
specified then the default is "filtered".</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
"score-random", or "score-zero" options may be specified in the
options parameter.
If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
or "score-zero" are specified, then the default is "score-logtfidf".</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
in the options parameter.  If the neither "checked" nor "unchecked" are
specified, then the default is "checked".</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "faceted" or "unfaceted" options may be specified
in the options parameter.  If the neither "faceted" nor "unfaceted" are
specified, then the default is "unfaceted".</p>
<p class="xquery" xmlns="http://www.w3.org/1999/xhtml">If the <code>cts:query</code> specified is the
empty string (equivalent to <code>cts:word-query("")</code>), then the
search returns the empty sequence.</p>
<p class="javascript" xmlns="http://www.w3.org/1999/xhtml">If the <code>cts:query</code> specified is the
empty string (equivalent to <code>cts.wordQuery("")</code>), then the
search returns an empty Iterator.</p>
<p class="javascript" xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
</apidoc:usage>
    <!-- XQuery examples -->
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//SPEECH,
    cts:word-query("with flowers"))

  =&gt; ... a sequence of 'SPEECH' element ancestors (or self)
     of any node containing the phrase 'with flowers'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(collection("self-help")/book,
    cts:element-query(xs:QName("title"), "meditation"),
    "score-simple", 1.0, (xdmp:forest("prod"),xdmp:forest("preview")))

  =&gt; ... a sequence of book elements matching the XPath
     expression which are members of the "self-help"
     collection, reside in the "prod" or "preview" forests and
     contain "meditation" in the title element, using the
     "score-simple" option.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" id="searchEx3" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(/some/xpath, cts:and-query(()), (), 0.0,
    xdmp:forest("myForest"))

  =&gt; ... a sequence of /some/xpath elements that are
     in the forest named "myForest".  Note the
     empty and-query, which matches all documents (and
     scores them all the same) and the quality-weight
     of 0, which together make each result have a score
     of 0, which keeps the results in document order.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(fn:doc(), "hello",
    ("unfiltered",
     cts:index-order(cts:element-reference(xs:QName("Title")))
    ) )[1 to 10]
=&gt; Returns the first 10 documents with the word "hello", unfiltered,
   ordered by the range index on the element "Title".  An element
   range index on Title is required for this search, otherwise it
   throws an exception.
</pre></apidoc:example>
    <!-- Javascript examples -->
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.wordQuery("with flowers"));

 =&gt; ... an Iterator of any node containing the phrase 'with flowers'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
fn.subsequence(cts.search(cts.wordQuery("with flowers")), 1, 10);

 =&gt; ... an Iterator of the first 10 nodes containing the phrase 'with flowers'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
fn.subsequence(
    cts.search("hello", ["unfiltered",
     cts.indexOrder(cts.elementReference(fn.QName("", "Title")))
    ] ), 1, 10);
=&gt; Returns the first 10 documents with the word "hello", unfiltered,
   ordered by the range index on the element "Title".  An element
   range index on Title is required for this search, otherwise it
   throws an exception.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="quality" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the quality of a node,
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:search</code>
    <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.search</code> operation.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code class="xquery">cts:quality</code>
  <code class="javascript">cts.quality</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are the retrieved
  from the database (an item from a <code class="xquery">cts:search</code>
  <code class="javascript">cts.search</code> result or an
  item from the result of an XPath expression that searches through the
  database).</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;, (), (), 50);
for $x in cts:search(collection(),"my test")
return cts:quality($x)

=&gt; 50
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for $a in cts:search(collection(),"my test")
where $a[cts:quality() gt 10]
return xdmp:node-uri($a)

=&gt; /test.xml
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//  assume a document created as follows:
//  declareUpdate();
//  xdmp.documentInsert("/test.json", {"a":"my test"}, null, null, 50);
for (const x of cts.search("my test")) {
  cts.quality(x);
};

=&gt; 50
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for (const a of cts.search("my test")) {
  if (cts.quality(a) &gt; 10) {
    xdmp.nodeUri(a);
  };
};

=&gt; /test.json
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="score" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the score of a node,
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:search</code>
    <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.search</code> operation.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Score is computed according to the scoring method specified in the
  <code class="xquery">cts:search</code>
    <code class="javascript">cts.search</code> expression, if any.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code class="xquery">cts:score</code>
  <code class="javascript">cts.score</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are retrieved
  from the database (an item from a search result or an
  item from the result of an XPath expression that searches through the
  database).</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: run this on the Shakespeare content set :)
for $hit in cts:search(//SPEECH,
    cts:word-query("with flowers"))[1 to 10]
return element hit {
  attribute score { cts:score($hit) },
  $hit
}
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
  for $x in cts:search(doc("/test.xml"),"my test")
  return cts:score($x) =&gt; 11
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  for $a in cts:search(collection(),"my test")
  where $a[cts:score() gt 10]
  return xdmp:node-uri($a) =&gt; /test.xml
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const res = new Array();
const s = fn.subsequence(cts.search("bar"), 1, 10);
for (const item of s) {
 res.push(cts.score(item));
}
res;
// returns the scores for the first 10 results that match the search
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="relevance-info" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Return the relevance score computation report for a node.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>cts:search</code></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><code>cts.search</code></span> operation.
    If this parameter is omitted, the context node is used.
  </apidoc:param>
      <apidoc:param class="xquery" name="output-kind" type="xs:string" optional="true">
    The output kind. It can be either "element" or "object".
    With "element", the built-in returns an XML element.
    With "object",  the built-in returns a map:map.
    The default is "element".
  </apidoc:param>
      <apidoc:param class="javascript" name="output-kind" type="xs:string" optional="true">
    The output kind. It can be either "object" or "element".
    With "object",  the built-in returns an object.
    With "element", the built-in returns an XML element node.
    The default is "object".
  </apidoc:param>
    </apidoc:params>
    <apidoc:return class="xquery">element()?</apidoc:return>
    <apidoc:return class="javascript">Object</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    This function returns <span class="xquery">an XML report</span>
    <span class="javascript">a JavaScript object</span> that contains
    details about the
    score computation only if the following conditions are met:
    The <code>node</code> parameter or context node is the result
    of a <span class="xquery"><code>cts:search</code></span>
    <span class="javascript"><code>cts.search</code></span> call that
    included the <code>relevance-trace</code> option; and the score is
    non-zero. For
    example, you will not get a report if you use the <code>score-zero</code>
    option on your <span class="xquery"><code>cts:search</code></span>
    <span class="javascript"><code>cts.search</code></span>, if the
    search returns no results, or if <code>node</code> is not the result
    of <span class="xquery"><code>cts:search</code></span>
    <span class="javascript"><code>cts.search</code></span>.
  </p><p xmlns="http://www.w3.org/1999/xhtml">
    The score computation reflects the scoring method specified in the
    <span class="xquery"><code>cts:search</code></span>
    <span class="javascript"><code>cts.search</code></span> expression,
    if any. The <code>score-zero</code> and <code>score-random</code>
    methods do not generate a report.
  </p><p xmlns="http://www.w3.org/1999/xhtml">
    Collecting score computation details with which to generate this report
    is costly, so using the <code>relevance-trace</code> option will
    slow down your search significantly.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: must use the relevance-trace option on cts:search to get relevance info :)
for $n in cts:search(//SPEECH,"to be or not to be", "relevance-trace")
return cts:relevance-info($n);
=&gt;
&lt;qry:relevance-info xmlns:qry="http://marklogic.com/cts/query"&gt;
  &lt;qry:score
    formula="(256*scoreSum/weightSum)+(256*qualityWeight*documentQuality)"
    computation="(256*1274/4)+(256*1*0)"&gt;81536&lt;/qry:score&gt;
  &lt;qry:confidence
    formula="sqrt(score/(256*8*maxlogtf*maxidf))"
    computation="sqrt(81536/(256*8*18*log(11360)))"&gt;0.486687&lt;/qry:confidence&gt;
  &lt;qry:fitness
    formula="sqrt(score/(256*8*maxlogtf*avgidf))"
    computation="sqrt(81536/(256*8*18*(23.6745/4)))"&gt;0.611312&lt;/qry:fitness&gt;
  &lt;qry:uri&gt;hamlet.xml&lt;/qry:uri&gt;
  &lt;qry:path&gt;fn:doc("hamlet.xml")/PLAY/ACT[3]/SCENE[1]/SPEECH[19]&lt;/qry:path&gt;
  &lt;qry:and&gt;
    &lt;qry:score formula="scoreSum" computation="390+366+228+290"&gt;1274&lt;/qry:score&gt;
    &lt;qry:term weight="8.125"&gt;
      &lt;qry:score formula="8*weight*logtf" computation="65*6"&gt;390&lt;/qry:score&gt;
      &lt;qry:key&gt;13470285622946442720&lt;/qry:key&gt;
      &lt;qry:annotation&gt;pair(word("be"),word("or"))&lt;/qry:annotation&gt;
    &lt;/qry:term&gt;
    &lt;qry:term weight="7.625"&gt;
      &lt;qry:score formula="8*weight*logtf" computation="61*6"&gt;366&lt;/qry:score&gt;
      &lt;qry:key&gt;13951883977767006862&lt;/qry:key&gt;
      &lt;qry:annotation&gt;pair(word("or"),word("not"))&lt;/qry:annotation&gt;
    &lt;/qry:term&gt;
    &lt;qry:term weight="4.75"&gt;
      &lt;qry:score formula="8*weight*logtf" computation="38*6"&gt;228&lt;/qry:score&gt;
      &lt;qry:key&gt;13642437994068421010&lt;/qry:key&gt;
      &lt;qry:annotation&gt;pair(word("not"),word("to"))&lt;/qry:annotation&gt;
    &lt;/qry:term&gt;
    &lt;qry:term weight="3.625"&gt;
      &lt;qry:score formula="8*weight*logtf" computation="29*10"&gt;290&lt;/qry:score&gt;
      &lt;qry:key&gt;7885524737699073672&lt;/qry:key&gt;
      &lt;qry:annotation&gt;pair(word("to"),word("be"))&lt;/qry:annotation&gt;
    &lt;/qry:term&gt;
  &lt;/qry:and&gt;
&lt;/qry:relevance-info&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const x = cts.search("dog", ["relevance-trace"]).toArray();
cts.relevanceInfo(x[0]);
=&gt;
{
  "score":{
    "formula":"(256*scoreSum/weightSum)+(256*qualityWeight*documentQuality)",
    "computation":"(256*8/1)+(256*1*0)",
    "value":2048
  },
  "confidence":{
    "formula":"sqrt(score/(256*8*maxlogtf*maxidf))",
    "computation":"sqrt(2048/(256*8*18*log(1)))",
    "value":0
  },
  "fitness":{
    "formula":"sqrt(score/(256*8*maxlogtf*avgidf))",
    "computation":"sqrt(2048/(256*8*18*(0/1)))",
    "value":0.2357023
  },
  "uri":"othello.xml",
  "path":"fn:doc('othello.xml')",
  "term":{
    "weight":0.125,
    "score":{
      "formula":"8*weight*logtf",
      "computation":"1*8",
      "value":8
    },
    "key":"5166487143365525844",
    "annotation":"word(\"dog\")"
  }
}
}</pre></apidoc:example>
  </apidoc:function><apidoc:function name="confidence" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the confidence of a node,
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:usage>
   <p xmlns="http://www.w3.org/1999/xhtml">Confidence is similar to score, except that it is bounded.
   It is similar to fitness, except that it is influenced by term IDFs.
   It is an <code>xs:float</code> in the range of 0.0 to 1.0.
   It does not include quality.</p>
   <p xmlns="http://www.w3.org/1999/xhtml">When using with any of the scoring methods, the confidence is
   calculated by first bounding the score in the range of 0.0 to 1.0,
   then taking the square root of that number.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := cts:search(collection(), "dog")
return
cts:confidence($x[1])

 =&gt; Returns the confidence value for the first item
    in the search.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const res = new Array();
const count = 0;
const s = cts.search("dog");
for (const item of s) {
  count++;
  if (count &gt; 3) { break;}
  res.push(cts.confidence(item));
  res.push(xdmp.nodeUri(item));
}
res;

// returns an array of the confidence numbers and the URI for the
// first 3 items returned by the search
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="fitness" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the fitness of a node,
  or of the context node if no node is provided. Fitness is a normalized
  measure of relevance that is based on how well a node matches the query
  issued, not taking into account the number of documents in which
  the query term(s) occur.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:usage>
   <p xmlns="http://www.w3.org/1999/xhtml">Fitness is similar to score, except that it is bounded.
   It is similar to confidence, except that it is not influenced by term IDFs.
   It is an <code>xs:float</code> in the range of 0.0 to 1.0.
   It does not include quality.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := cts:search(collection(), "dog")
return
cts:fitness($x[1])

=&gt; Returns the fitness value for the first item
   in the search.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const s = cts.search("dog");
for (const x of fn.subsequence(s, 1, 1) ) {
  cts.fitness(x);
};
// returns the fitness of the first "dog" hit
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="remainder" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns an estimated search result size for a node,
  or of the context node if no node is provided.
  The search result size for a node is the number of fragments remaining
  (including the current node) in the result sequence containing the node.
  This is useful to quickly estimate the size of a search result sequence,
  without using <code xmlns="http://www.w3.org/1999/xhtml">fn:count()</code> or <code xmlns="http://www.w3.org/1999/xhtml">xdmp:estimate()</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation.  If you specify the first item
    from a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> expression,
    then <code xmlns="http://www.w3.org/1999/xhtml">cts:remainder</code> will return an estimate of the number
    of fragments that match that expression.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">This function makes it efficient to estimate the size of a search result
  and execute that search in the same query.  If you only need an estimate of
  the size of a search but do not need to run the search, then
  <a href="#xdmp:estimate"><code class="xquery">xdmp:estimate</code></a>
  <a href="#xdmp.estimate"><code class="javascript">xdmp.estimate</code></a>
  is more efficient.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To return the estimated size of a search with
  <code class="xquery">cts:remainder</code>
  <code class="javascript">cts:remainder</code>,
  use the first item of a
  <a href="#cts:search"><code class="xquery">cts:search</code></a>
  <a href="#cts.search"><code class="javascript">cts.search</code></a>
  result sequence as the
  parameter to
  <code class="xquery">cts:remainder</code><code class="javascript">cts.remainder</code>. For example, the following
  query returns the estimated number of fragments that contain the word
  "dog":</p>
  <pre class="xquery" xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:remainder(cts:search(collection(), "dog")[1]) </pre>
  <pre class="javascript" xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.remainder(fn.subsequence(cts.search("dog"), 1, 1)) </pre>
  <p xmlns="http://www.w3.org/1999/xhtml"><span class="xquery">When you put the position predicate on the
  <code>cts:search</code> result sequence, </span>
  <span class="javascript">When you take a subsequence of the
  <code>cts.search</code> result Sequence, </span>
  MarkLogic Server will filter all of the false-positive results
  up to the specified position, but not the false-positive results beyond
  the specified
  position. Because of this, when you
  <span class="xquery">increase the position number in the parameter, the
  result from <code>cts:remainder</code> </span>
  <span class="javascript">increase the number of results in the
  subsequence, the result from <code>cts.remainder</code> </span>
  might decrease
  by a larger number than the increase in position number, or it might not
  decrease at all. For example, if
  the query above returned 10, then the following query might return 9, it
  might return 10, or it might return less than 9, depending on how the
  results are dispersed throughout different fragments:</p>
  <pre class="xquery" xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:remainder(cts:search(collection(), "dog")[2]) </pre>
  <pre class="javascript" xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.remainder(fn.subsequence(cts.search("dog"), 2, 2)) </pre>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code class="xquery">cts:remainder</code>
  <code class="javascript">cts.remainder</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are the retrieved
  from the database (an item from a search result or an
  item from the result of an XPath expression that searches through the
  database).</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := cts:search(collection(), "dog")
return
(cts:remainder($x[1]), $x)

=&gt; Returns the estimated number of items in the search
   for "dog" followed by the results of the search.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const s = cts.search("dog");
const results = new Array();
const clone = s.clone();
for (const x of fn.subsequence(s, 1, 1) ) {
  results.push(cts.remainder(x));
};
results.push(clone);
results;

=&gt; Returns the estimated number of items in the search
   for "dog" followed by the results of the search.
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
for $x in cts:search(collection(),"my test")
return cts:remainder($x)
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Assume a document exist as follows:
// declareUpdate();
// xdmp.documentInsert("/test.json", {"a":"my test"});

for (const x of fn.subsequence(cts.search("my test"), 1, 1) ) {
  cts.remainder(x);
};
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for $a in cts:search(collection(),"my test")
where $a[cts:remainder() eq 1]
return xdmp:node-uri($a)
=&gt; /test.xml
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for (const a of cts.search("my test")) {
 if (cts.remainder(a) == 1) {
   xdmp.nodeUri(a);
 };
};

=&gt; /test.json
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="tokenize" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Tokenizes text into words, punctuation, and spaces.  Returns output in
  the type <code xmlns="http://www.w3.org/1999/xhtml">cts:token</code>, which has subtypes
  <code xmlns="http://www.w3.org/1999/xhtml">cts:word</code>, <code xmlns="http://www.w3.org/1999/xhtml">cts:punctuation</code>, and
  <code xmlns="http://www.w3.org/1999/xhtml">cts:space</code>, all of which are subtypes of
  <code xmlns="http://www.w3.org/1999/xhtml">xs:string</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string">
    A word or phrase to tokenize.
  </apidoc:param>
      <apidoc:param name="language" type="xs:string?" optional="true">
    A language to use for tokenization.  If not supplied, it uses the
    database default language.
  </apidoc:param>
      <apidoc:param name="field" type="xs:string?" optional="true">
    A field to use for tokenization. If the field has custom tokenization rules,
    they will be used. If no field is supplied or the field has no custom
    tokenization rules, the default tokenization rules are used.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:token*</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml"> When you tokenize a string with <code>cts:tokenize</code>, each word is
  represented by an instance of
  <code>cts:word</code>, each punctuation character
  is represented by an instance of <code>cts:punctuation</code>,
  each set of adjacent spaces is represented by an instance of
  <code>cts:space</code>, and each set of adjacent line breaks
  is represented by an instance of <code>cts:space</code>.</p>
<p xmlns="http://www.w3.org/1999/xhtml">
   Unlike the standard XQuery function <code>fn:tokenize</code>,
   <code>cts:tokenize</code> returns words, punctuation, and spaces
   as different types. You can therefore use a typeswitch to handle each type
   differently. For example, you can use <code>cts:tokenize</code> to remove
   all punctuation from a string, or create logic to test for the type and
   return different things for different types, as shown in the first
   two examples below.
</p><p xmlns="http://www.w3.org/1999/xhtml">
   You can use <code>xdmp:describe</code> to show how a given string will be
   tokenized. When run on the results of <code>cts:tokenize</code>, the
   <code>xdmp:describe</code> function returns the types and the values
   for each token. For a sample of this pattern, see the third example below.
</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Remove all punctuation :)
let $string := "The red, blue, green, and orange
                balloons were launched!"
let $noPunctuation :=
  for $token in cts:tokenize($string)
  return
    typeswitch ($token)
     case $token as cts:punctuation return ""
     case $token as cts:word return $token
     case $token as cts:space return $token
     default return ()
return string-join($noPunctuation, "")
  <br/>
 =&gt; The red blue green and orange
    balloons were launched
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Remove all punctuation, normalize space
const string = "The red, blue, green, and orange \
                balloons were launched!";
const noPunctuation = new Array();
for (const token of cts.tokenize(string)) {
      if (fn.deepEqual(sc.name(sc.type(token)),
              fn.QName("http://marklogic.com/cts", "punctuation"))) { }
      else if (fn.deepEqual(sc.name(sc.type(token)),
              fn.QName("http://marklogic.com/cts", "word"))) {
        noPunctuation.push(token); }
      else if (fn.deepEqual(sc.name(sc.type(token)),
              fn.QName("http://marklogic.com/cts", "space"))) { }
      else {  };
      };
noPunctuation.join(" ");

=&gt; The red blue green and orange balloons were launched
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Insert the string "XX" before and after
   all punctuation tokens :)
let $string := "The red, blue, green, and orange
                 balloons were launched!"
let $tokens := cts:tokenize($string)
return string-join(
for $x in $tokens
return if ($x instance of cts:punctuation)
       then (concat("XX",
                     $x, "XX"))
       else ($x) , "")
=&gt; The redXX,XX blueXX,XX greenXX,XX and orange
    balloons were launchedXX!XX

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Insert the string "XX" before and after
//   all punctuation tokens
const str = "The red, blue, green, and orange \
                 balloons were launched!" ;
const tokens = cts.tokenize(str);
const res = new Array();
for (const x of tokens) {
  if ( fn.deepEqual(sc.name(sc.type(x)),
              fn.QName("http://marklogic.com/cts", "punctuation")))  {
       res.push(fn.concat("XX", x, "XX")); }
       else { res.push(x); };
};
fn.normalizeSpace(res.join(" "));

=&gt; The redXX,XX blueXX,XX greenXX,XX and orange balloons were launchedXX!XX

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: show the types and tokens for a string :)
xdmp:describe(cts:tokenize("blue, green"))

=&gt; (cts:word("blue"), cts:punctuation(","),
    cts:space(" "), cts:word("green"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// show the types and tokens for a string
xdmp.describe(cts.tokenize("blue, green"), 20)

=&gt; Sequence("blue", ",", " ", "green")

// the same example, iterating over the Sequence results
const res = new Array();
for (const x of cts.tokenize("blue, green")) {
	res.push(sc.name(sc.type(cts.tokenize(x)))); };
res;

=&gt; ["cts:word","cts:punctuation","cts:space","cts:word"]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="stem" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the stem(s) for a word.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string">
    A word or phrase to stem.
  </apidoc:param>
      <apidoc:param name="language" type="xs:string?" optional="true">
    A language to use for stemming.  If not supplied, it uses the
    database default language.
  </apidoc:param>
      <apidoc:param name="partOfSpeech" type="xs:string?" optional="true">
   A part of speech to use for stemming. The default is the unspecified
   part of speech. This parameter is for testing custom stemmers.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">In general, you should pass a word into
<code class="xquery">cts:stem</code><code class="javascript">cts.stem</code>;
if you enter a phrase, it will stem the phrase, which will normally stem to
itself.</p>
<p xmlns="http://www.w3.org/1999/xhtml">When you stem a word through
<code class="xquery">cts:stem</code><code class="javascript">cts.stem</code>,
it returns all of the stems for the word, including decompounding and multiple
stems, regardless of the database stemming setting.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:stem("ran","en")
=&gt; "run"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.stem("ran","en")
=&gt; "run"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="part-of-speech" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Returns the part of speech for a <code xmlns="http://www.w3.org/1999/xhtml">cts:token</code>, if any.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="token" type="cts:token">
  A token, as returned from <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:tokenize</code><code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.tokenize</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">This function is useful for testing custom tokenizers. Built in tokenizers do not use parts of speech and will return an empty string for the part of speech.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:part-of-speech(cts:tokenize("an example","en"))
=&gt; ("","","")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const res = new Array();
for (const x of cts.tokenize("an example","en")) {
  res.push(cts.partOfSpeech(x))
};
res
=&gt; ["","",""]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching all of the specified queries, where
  the matches occur within the specified distance from each other.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*">
    A sequence of queries to match.
  </apidoc:param>
      <apidoc:param name="distance" type="xs:double?" optional="true">
    A distance, in number of words, between any two matching queries.
    The results match if two queries match and the distance between the
    two matches is equal to or less than the specified distance. A
    distance of 0 matches when the text is the exact same text or when
    there is overlapping text (see the third example below). A negative
    distance is treated as 0.  The default value is 10.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default value is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ordered"</dt>
        <dd>Any near-query matches must occur in the order of
            the specified sub-queries.</dd>
        <dt>"unordered"</dt>
        <dd>Any near-query matches will satisfy the query,
        regardless of the order they were specified.  </dd>
        <dt>"minimum-distance"</dt>
        <dd>The minimum distance between two matching queries. The results
        match if the two queries match and the minimum distance between the two
        matches is greater than or equal to the specified minimum distance. The
        default value is zero. A negative distance is treated as 0. </dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="distance-weight" type="xs:double?" optional="true">
    A weight attributed to the distance for this query.  Higher
    weights add to the importance of distance (as opposed to term matches)
    when the relevance order is calculated.  The default value is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.  This parameter has no effect if the <code xmlns="http://www.w3.org/1999/xhtml">word positions</code>
    index is not enabled.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:near-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If the options parameter contains neither "ordered" nor "unordered",
  then the default is "unordered".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The <code>word positions</code> index will speed the performance of
  queries that use <code>cts:near-query</code>. The <code>element word
  positions</code> index will speed the performance of element-queries
  that use <code>cts:near-query</code>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with a field, the distance
  specified is the distance in the whole document, not the distance
  in the field. For example, if the distance between two words is 20 in
  the document, but the distance is 10 if you look at a view of the document
  that only includes the elements in a field, a <code>cts:near-query</code>
  must have a distance of 20 or more to match; a distance of 10 would not
  match. The same applies to minimum distance as well.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with
  <code>cts:field-word-query</code>, the distance supplied in the near query
  applies to the whole document, not just to the field. This too applies to the
  minimum distance as well. For details, see
  <a href="#cts:field-word-query"><code>cts:field-word-query</code></a>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Expressions using the <code>ordered</code> option are more efficient
  than those using the <code>unordered</code> option, especially if they
  specify many queries to match.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Minimum-distance and distances apply to each near-query match. Therefore, if
  minimum-distance is greater than distance there can be no matches.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 The following query searches for paragraphs containing
 both "MarkLogic" and "Server" within 3 words of each
 other, given the following paragraphs in a database:

  &lt;p&gt;MarkLogic Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;
  &lt;p&gt;MarkLogic is an excellent XML Content Server.&lt;/p&gt;

  cts:search(//p,
    cts:near-query(
      (cts:word-query("MarkLogic"),
      cts:word-query("Server")),
      3))

  =&gt;
  &lt;p&gt;MarkLogic Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// The following query searches for paragraphs containing
// both "MarkLogic" and "Server" within 3 words of each
// other, given the following document in a database:

// { "text": "MarkLogic Server is an enterprise-class database."}

cts.search(cts.nearQuery(
    [cts.wordQuery("MarkLogic"),
     cts.wordQuery("Server")],
     3))

=&gt; A Sequence containing the document

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"),
                    3, "ordered"))

=&gt; false because "discontent" comes after "winter"

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"),
                    3, "unordered"))

=&gt; true because the query specifies "unordered",
        and it is still a match even though
        "discontent" comes after "winter"

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["discontent", "winter"],
                    3, "ordered"))

=&gt; false because "discontent" comes after "winter"

const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["discontent", "winter"],
                    3, "unordered"))

=&gt; true because the query specifies "unordered",
        and it is still a match even though
        "discontent" comes after "winter"

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "winter of"),
                    0))

=&gt; true because the phrases overlap

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "of our"),
                    0))

=&gt; false because the phrases do not overlap
         (they have 1 word distance, not 0)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["is the winter", "winter of"],
                    0))

=&gt; true because the phrases overlap

const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["is the winter", "of our"],
                    0))

=&gt; false because the phrases do not overlap
         (they have 1 word distance, not 0)

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("winter", "discontent"),
                    5, ("ordered", "minimum-distance=4")))

=&gt; false because the distance between the queries is greater than the minimum
distance

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("winter", "discontent"),
                    5, ("ordered", "minimum-distance=3")))

=&gt; true because the distance between the queries is less than or equal to the
minimum distance

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["winter", "discontent"],
                    5, ("ordered", "minimum-distance=4")))

=&gt; false because the distance between the queries is greater than the minimum
distance

const x = xdmp.unquote('&lt;p&gt;Now is the winter of our discontent&lt;/p&gt;');
cts.contains(x, cts.nearQuery(
                    ["winter", "discontent"],
                    5, ("ordered", "minimum-distance=3")))

=&gt; true because the distance between the queries is less than or equal to the
minimum distance

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query sequence used to construct the near query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:near-query-queries($query)
  =&gt; ... a sequence of the queries used to
            construct this query
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.nearQueryQueries(query)
  =&gt; ... a Sequence of the queries used to
            construct this query
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query :=
  cts:near-query((
    cts:word-query("to be or"),
    cts:word-query("or not to be")))
return cts:near-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1)
         cts:word-query("or not to be", (), 1))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query =
  cts.nearQuery([
    cts.wordQuery("to be or"),
    cts.wordQuery("or not to be")]);
const res = new Array();
for (const x of cts.nearQueryQueries(query)) {
  res.push(x);
};
res;

=&gt; [{"wordQuery":{"text":["to be or"],"options":["lang=en"]}},
    {"wordQuery":{"text":["or not to be"],"options":["lang=en"]}}]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the distance used to construct the near query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"),
                 12)
return cts:near-query-distance($query)
=&gt; 12
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.nearQuery(
                 [cts.wordQuery("wanted"),
                 cts.wordQuery("unwanted")],
                 12);
cts.nearQueryDistance(query);
=&gt; 12
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 (cts:word-query("wanted"),
                 cts:word-query("unwanted")),
                 12,
                 "ordered")
return
  cts:near-query-options($query)
  =&gt; "ordered"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.nearQuery(
                 [cts.wordQuery("wanted"),
                 cts.wordQuery("unwanted")],
                 12,
                 "ordered");
cts.nearQueryOptions(query);
  =&gt; "ordered"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 (cts:word-query("wanted"),
                 cts:word-query("unwanted")),
                 12, "ordered", 5.0)
return
  cts:near-query-weight($query)
  =&gt; 5.0
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.nearQuery(
                 [cts.wordQuery("wanted"),
                 cts.wordQuery("unwanted")],
                 12, "ordered", 5.0);
cts.nearQueryWeight(query);
  =&gt; 5.0
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-in-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching the first subquery, where those matches do not
  occur within 0 distance of the other query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="positive-query" type="cts:query">
    A positive query, specifying the search results
    filtered in.
  </apidoc:param>
      <apidoc:param name="negative-query" type="cts:query">
    A negative query, specifying the search results
    to filter out.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:not-in-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Positions are required to accurately resolve this query from the indexes.
    If you do not enable position indexes appropriate to the type of the
    sub-queries, then you may get surprising results in unfiltered searches.
    For example, if the sub queries are <code>cts:word-query</code>, then
    you should enable word positions in the database.
  </p><p xmlns="http://www.w3.org/1999/xhtml">
    False positives can occur if there are no positions available, such as
    when position are not enabled. Filtered searches always have access to
    positions, but unfiltered searches do not.
  </p><p xmlns="http://www.w3.org/1999/xhtml">
    Some query types are intrinsically positionless, such as
    <code>cts:collection-query</code> or <code>cts:directory-query</code>.
    Matches to such a query are considered to occur at every position and
    causes the overall query to behave like <code>cst:and-not-query</code>.
    If no position can be determined, such as when positions are not enabled,
    then every match to <code>$positive-query</code> is a match for the
    whole query.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//PLAY,
  cts:not-in-query(
    cts:word-query("nettles"),
    cts:word-query("stinging nettles")))
=&gt; A sequence of 'PLAY' elements containing some text node
   with the word 'nettles' where that occurrence is not in the
   phrase 'stinging nettles'.This sequence may be (in fact is) non-empty,
   but certainly does not contain the PLAY element with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second"

   since, while this play does contain 'nettles', it is only in the
   phrase 'stinging nettles'. On the other hand, this play
   will match the query:

     cts:search(//PLAY,
       cts:not-in-query(
         cts:word-query("summer"),
         cts:word-query("summer corn")))

   since, while the play does contain 'summer corn', it also contains 'summer'
   in other contexts as well.

   If word positions are not enabled, then an unfiltered search returns
   all documents containing "nettles".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.notInQuery(
    cts.wordQuery("nettles"),
    cts.wordQuery("stinging nettles")))

=&gt; A sequence of documents containing some text node
   with the word 'nettles' where that occurrence is not in the
   phrase 'stinging nettles'.This sequence may be (in fact is) non-empty,
   but certainly does not contain the PLAY element with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second"

   since, while this play does contain 'nettles', it is only in the
   phrase 'stinging nettles'. On the other hand, this play
   will match the query:

     cts.search(cts.notInQuery(
         cts.wordQuery("summer"),
         cts.wordQuery("summer corn")))

   since, while the play does contain 'summer corn', it also contains 'summer'
   in other contexts as well.

   If word positions are not enabled, then an unfiltered search returns
   all documents containing "nettles".
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//PLAY,
  cts:not-in-query(
    cts:word-query("nettles"),
    cts:collection-query("TRAGEDY")))
=&gt; A sequence of 'PLAY' elements containing some text node with
   the word "nettles", excluding occurrences in documents in the
   "TRAGEDY" collection. The collection query is intrinsically,
   positionless, so the negative query matches overlap with every
   match of the positive query.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.notInQuery(
    cts.wordQuery("nettles"),
    cts.collectionQuery("TRAGEDY")))
=&gt; A sequence of 'PLAY' elements containing some text node with
   the word "nettles", excluding occurrences in documents in the
   "TRAGEDY" collection. The collection query is intrinsically,
   positionless, so the negative query matches overlap with every
   match of the positive query.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-in-query-positive-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the positive (first parameter) query used to construct the
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:not-in-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:not-in-query(
                 cts:word-query("wanted"),
                 cts:word-query("not wanted"))
return cts:not-in-query-positive-query($query)

  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.notInQuery(
                 cts.wordQuery("wanted"),
                 cts.wordQuery("not wanted"));
cts.notInQueryPositiveQuery(query);

  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-in-query-negative-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the negative (second parameter) query used to construct the
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:not-in-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:not-in-query(
                 cts:word-query("wanted"),
                 cts:word-query("not wanted"))
return cts:not-in-query-negative-query($query)

  =&gt; cts:word-query("not wanted", (), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.notInQuery(
                 cts.wordQuery("wanted"),
                 cts.wordQuery("not wanted"));
cts.notInQueryNegativeQuery(query);

  =&gt; cts:word-query("not wanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name
  with the content constrained by the given <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> in the
  second parameter.
  Searches for matches in the specified element and all of its descendants.
  If the specified query in the second parameter has any
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-attribute-*-query</code> constructors, it will search
  attributes directly on the specified element and attributes on any
  descendant elements (see the <a href="#eq2" class="xquery" xmlns="http://www.w3.org/1999/xhtml">second example</a>
  <a href="#eq2js" class="javascript" xmlns="http://www.w3.org/1999/xhtml">second example</a> below).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query">
    A query for the element to match.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Enabling both the word position and element position indexes
  ("word position" and "element word position" in the database configuration
  screen of the Admin Interface) will speed up query performance for many
  queries that use <code>cts:element-query</code>. The  position indexes
  enable MarkLogic Server to eliminate many false-positive results, which can
  reduce disk I/O and processing, thereby speeding the performance of many
  queries.  The amount of benefit will vary depending on your data.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">You can query for the existence of an element by specifying an empty
  <a href="#cts:and-query" class="xquery"><code>cts:and-query</code></a>
  <a href="#cts.andQuery" class="javascript"><code>cts.andQuery</code></a> as
  the second parameter. For example, the following will match any instance
  of the specified element:</p>
  <blockquote class="xquery" xmlns="http://www.w3.org/1999/xhtml">
  <pre xml:space="preserve">
  cts:element-query(xs:QName("my-element"),
    cts:and-query( () ))
  </pre></blockquote>
  <blockquote class="javascript" xmlns="http://www.w3.org/1999/xhtml">
  <pre xml:space="preserve">
  cts.elementQuery(xs.QName("my-element"),
    cts.andQuery( [] ))
  </pre></blockquote>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(cts.elementQuery(
      xs.QName("function"),
      "MarkLogic Corporation"))

  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</pre></apidoc:example>
    <apidoc:example class="xquery"><a id="eq2" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;a attr="something"&gt;hello&lt;/a&gt;
return
cts:contains($x, cts:element-query(xs:QName("a"),
   cts:and-query((
     cts:element-attribute-word-query(xs:QName("a"),
         xs:QName("attr"), "something"),
     cts:word-query("hello")))))
(: returns true :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><a id="eq2js" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">

const x = xdmp.unquote('&lt;a attr="something"&gt;hello&lt;/a&gt;');
cts.contains(x, cts.elementQuery(xs.QName("a"),
   cts.andQuery((
     cts.elementAttributeWordQuery(xs.QName("a"),
         xs.QName("attr"), "something"),
     cts.wordQuery("hello")))));
// returns true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementQuery(
              xs.QName("function"),
              "MarkLogic Corporation");
cts.elementQueryElementName(query);

  =&gt; fn:QName("", "function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the element query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-query(xs:QName("help"),
                 cts:word-query("wanted"))
return cts:element-query-query($query)

  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.elementQuery(xs.QName("help"),
                 cts.wordQuery("wanted"));
cts.elementQueryQuery(query);

  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-scope-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching JSON properties by name
  with the content constrained by the given <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> in the
  second parameter.
  Searches for matches in the specified property and all of its descendants.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query">
    A query for the property to match.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-scope-query</apidoc:return>
    <apidoc:usage>
  Enabling both the word position and element word position indexes will
  speed up query performance for many queries that use
  <code xmlns="http://www.w3.org/1999/xhtml">cts:json-property-scope-query</code>. The  position indexes enable MarkLogic
  Server to eliminate many false-positive results, which can reduce
  disk I/O and processing, thereby speeding the performance of many queries.
  The amount of benefit will vary depending on your data.
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
Given a database that has a JSON document as follows:
{"a":"aa","new":["array","content"],"b":["aa","bb"]}
:)
  cts:search(doc(),
    cts:json-property-scope-query(
      "a",
      "aa"))

  =&gt; .. relevance-ordered sequence of JSON documents (including
     the above document) with a property named "a" having a
     value of "aa".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Given a database that has a JSON document as follows:
//  {"a":"aa","new":["array","content"],"b":["aa","bb"]}

cts.search(cts.jsonPropertyScopeQuery( 'a', 'aa'))

// Returns a relevance-ordered sequence of JSON documents (including
// the above document) with a property named "a" having a
// value of "aa".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-scope-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the JSON property name used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-scope-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-scope-query(
              "function",
              "MarkLogic Corporation")
return cts:json-property-scope-query-property-name($query)

  =&gt; "function"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyScopeQuery(
              "function",
              "MarkLogic Corporation");
cts.jsonPropertyScopeQueryPropertyName(query);

  =&gt; "function"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-scope-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the property scope query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-scope-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-scope-query(
                 "help",
                 cts:word-query("wanted"))
return cts:json-property-scope-query-query($query)

  =&gt; cts:word-query("wanted", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.jsonPropertyScopeQuery(
              "help",
              cts.wordQuery("wanted");
cts.jsonPropertyScopeQueryQuery(query);

  =&gt; cts:word-query("wanted", ("lang=en"), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching documents with the given URIs.  It will match both
  documents and properties documents with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*">
    One or more document URIs.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:document-query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:document-query("/reports.xml"))

  =&gt; .. relevance-ordered sequence of 'function' elements
  in the document "/reports.xml".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for (const x of cts.search(cts.documentQuery("/reports.xml"))) {
  x.xpath("//function"); };

  =&gt; .. a sequence of 'function' elements in the document "/reports.xml".
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//function, cts:and-query(("repair",
  cts:document-query(("/reports.xml", "/analysis.xml")))))

  =&gt; .. relevance ordered sequence of 'function' elements in
     any document that both contains the word "repair" and is
     in either the document "/reports.xml" or in the document
     "/analysis.xml".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.andQuery(["repair",
  cts.documentQuery(["/reports.xml", "/analysis.xml"])]))

  =&gt; .. relevance ordered sequence of documents that both contains
     the word "repair" and is in either the document "/reports.xml"
     or in the document "/analysis.xml".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:document-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:document-query-uris($query)
  =&gt; ("/reports.xml", "/analysis.xml")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.documentQuery(["/reports.xml", "/analysis.xml"]);
cts.documentQueryUris(query);
  =&gt; ("/reports.xml", "/analysis.xml")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching documents in the collections with the given URIs.
  It will match both documents and properties documents in the collections
  with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*">
    One or more collection URIs.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:collection-query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:collection-query(("reports", "analysis")))

  =&gt; .. a sequence of 'function' elements in any document in the
     collection "reports" or in the collection "analysis".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.andQuery([cts.wordQuery("repair"),
    cts.collectionQuery(["reports", "analysis"])]));

  =&gt; .. relevance ordered sequence of documents that both
     contains the word "repair" and is in either the
     collection "reports" or in the collection "analysis".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:collection-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:collection-query(("reports", "analysis"))
return
cts:collection-query-uris($query)
  =&gt; ("reports", "analysis")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.collectionQuery(["reports", "analysis"]);
cts.collectionQueryUris(query);
  =&gt; ("reports", "analysis")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching documents in the directories with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*">
    One or more directory URIs.
  </apidoc:param>
      <apidoc:param name="depth" type="xs:string?" optional="true">
    "1" for immediate children, "infinity" for all.  If not supplied,
    depth is "1".
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:directory-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The directory URI should always have a trailing slash.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:directory-query(("/reports/","/analysis/"),"1"))

  =&gt; .. a sequence of 'function' elements in any document
     in the directory "/reports/" or the directory "/analysis/".
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(cts.andQuery(["repair",
  cts.directoryQuery(["/reports/", "/analysis/"], "1")]))

  =&gt; .. relevance ordered sequence of documents that both
     contains the word "repair" and is in either the
     directory "/reports/" or in the directory "/analysis/".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:directory-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:directory-query(("/reports/", "/analysis/"))
return
cts:directory-query-uris($query)
  =&gt; ("/reports/", "/analysis/")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.directoryQuery(["/reports/", "/analysis/"]);
cts.directoryQueryUris(query);
  =&gt; ("/reports/", "/analysis/")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query-depth" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the depth used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:directory-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:directory-query(("/reports/", "/analysis/"))
return
cts:directory-query-depth($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.directoryQuery(["/reports/", "/analysis/"]);
cts.directoryQueryDepth(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="register" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Register a query for later use.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query">
    A query to register.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:unsignedLong</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:register(cts:collection-query("mycollection"))

  =&gt; 12345678901234567
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.register(cts.collectionQuery("mycollection"));

// returns the ID of the registered query
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="deregister" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Deregister a registered query, explicitly releasing the associated
  resources.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="id" type="xs:unsignedLong">
    A registered query identifier.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>empty-sequence()</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:deregister(xs:unsignedLong("12345678901234567"))

=&gt; ()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const q = cts.jsonPropertyWordQuery("my-property", "hello");
const reg = cts.register(q);
cts.deregister(reg);

// this registers and then deregisters a query, returning empty
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query matching fragments specified by previously registered
  queries (see <a href="#cts:register" xmlns="http://www.w3.org/1999/xhtml"><code>cts:register</code></a>).  If
  the database is not empty and a registered query with the specified ID(s)
  is not found, then a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation with an invalid
  <code xmlns="http://www.w3.org/1999/xhtml">cts:registered-query</code> throws an XDMP-UNREGISTERED exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="ids" type="xs:unsignedLong*">
    Some registered query identifiers.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"filtered"</dt>
        <dd>A filtered query (the default). Filtered queries
        eliminate any false-positive results and properly resolve
        cases where there are multiple candidate matches within the same
        fragment, thereby guaranteeing
        that the results fully satisfy the original <code>cts:query</code>
        item that was registered.  This option is not currently available.</dd>
        <dt>"unfiltered"</dt>
        <dd>An unfiltered query.  Unfiltered registered queries
        select fragments from the indexes that are candidates to satisfy
        the <code>cts:query</code>.
        Depending on the original <code>cts:query</code>, the
        structure of the documents in the database, and the configuration
        of the database,
        unfiltered registered queries may result in false-positive results
        or in incorrect matches when there are multiple candidate matches
        within the same fragment.
        To avoid these problems, you should only use unfiltered queries
        on top-level XPath expressions (for example, document nodes,
        collections, directories) or on fragment roots. Using unfiltered
        queries on complex XPath expressions or on XPath expressions that
        traverse below a fragment root can result in unexpected results.
        This option is required in the current release.
        </dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The
    weight should be between 64 and -16.
    Weights greater than 64 will have the same effect as a
    weight of 64.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:registered-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">Searches that use registered queries will generate results with 
 different scores than the equivalent searches using non-registered queries. 
 This is because registered queries are treated as a single term in 
 relevance calculations.</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the options parameter does not contain "unfiltered",
then an error is returned, as the "unfiltered" option is required.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Registered queries are persisted as a soft state only; they can
become unregistered through an explicit direction (using
<a href="#cts:deregister"><code>cts:deregister</code></a>),
as a result of the cache growing too large, or because of a server restart.
Consequently, either your XQuery code or your middleware layer should handle
the case when an XDMP-UNREGISTERED exception occurs (for example, you can
wrap your <code>cts:registered-query</code> code in a try/catch block
or your Java or .NET code can catch and handle the exception).</p>
<p xmlns="http://www.w3.org/1999/xhtml">Unfiltered queries, including registered queries, do not match in
 <span class="xquery"><a href="#cts:walk">cts:walk</a> or
 <a href="#cts:highlight">cts:highlight</a></span><span class="javascript">
 <a href="#cts.walk">cts.walk</a> or
 <a href="#cts.highlight">cts.highlight</a></span>.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:registered-query(1234567890123456,"unfiltered"))

  =&gt; .. relevance-ordered sequence of 'function' elements
  in any document that also matches the registered query
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.search(
    cts.registeredQuery(1234567890123456,"unfiltered"))

  =&gt; .. relevance-ordered sequence of documents
     that also matches the registered query
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: wrap the registered query in a try/catch :)
try {
cts:search(fn:doc(),cts:registered-query(995175721241192518,"unfiltered"))
} catch ($e) {
  if ($e/err:code = "XDMP-UNREGISTERED")
  then ("Retry this query with the following registered query ID: ",
        cts:register(cts:word-query("hello*world","wildcarded")))
  else $e }
}
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// wrap the registered query in a try/catch
try {
cts.search(cts.registeredQuery(995175721241192518,"unfiltered"))
} catch (e) {
  if (e.name == "XDMP-UNREGISTERED") {
    fn.concat("Retry this query with the following registered query ID: ",
        xdmp.eval('cts.register(cts.wordQuery("hello*world","wildcarded"))')) }
  else { e; }
}

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-ids" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the registered query identifiers used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:unsignedLong*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:registered-query(1234567890123456,"unfiltered")
return
cts:registered-query-ids($query)
  =&gt; 1234567890123456
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.registeredQuery(1234567890123456,"unfiltered");
cts.registeredQueryIds(query);
  =&gt; 1234567890123456
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:registered-query(1234567890123456,"unfiltered")
return
cts:registered-query-options($query)
  =&gt; "unfiltered"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.registeredQuery(1234567890123456,"unfiltered");
cts.registeredQueryOptions(query);
  =&gt; unfiltered
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:registered-query(1234567890123456,"unfiltered")
return
cts:registered-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.registeredQuery(1234567890123456,"unfiltered");
cts.registeredQueryWeight(query);
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the word lexicon.  This function requires the word
  lexicon to be enabled. If the word lexicon is not enabled, an
  exception is thrown.  The words are returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
   a word lexicon must exist in the query's collation
   otherwise this will throw XDMP-WORDLXCNNOTFOUND
:)
  cts:words("aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// a word lexicon must exist in the query's collation
// otherwise this will throw XDMP-WORDLXCNNOTFOUND

  cts.words("aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the word lexicon that match the wildcard pattern.
  This function requires the word lexicon to be enabled. If the word
  lexicon is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string">
    A wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
   a word lexicon must exist in the query's collation
   otherwise this will throw XDMP-WORDLXCNNOTFOUND
:)
  cts:word-match("aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// a word lexicon must exist in the query's collation
// otherwise this will throw XDMP-WORDLXCNNOTFOUND

cts.wordMatch("aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified element word lexicon.  This function
  requires an element word lexicon for each of the element specified in the
  function.  If there is not an element word lexicon configured for any
  of the specified elements, an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with element-word-query are included.
  That is, only words present in immediate text node children of the
  specified element as well as any text node children of child elements
  defined in the Admin Interface as element-word-query-throughs or
  phrase-throughs. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When run without a $query parameter and as a user with the admin role,
  the word lexicon functions return results that might include words from
  deleted fragments. However, when run as a user with the admin role and
  without a $query parameter, the word lexicon functions run faster (because
  they do not need to look up where each word comes from). It is therefore
  faster to run word lexicon functions as an admin user without passing a
  $query parameter.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
 an element word lexicon must exist on "animal" or
 this example throws XDMP-ELEMLXCNNOTFOUND
:)
  cts:element-words(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// an element word lexicon must exist on "animal" or
// this example throws XDMP-ELEMLXCNNOTFOUND

  cts.elementWords(xs.QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified JSON property word lexicon.  This function
  requires a property word lexicon for each of the property specified in the
  function.  If there is not a property word lexicon configured for any
  of the specified properties, an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-names" type="xs:string*">
    One or more property names.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with json-property-word-query are
  included.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When run without a $query parameter and as a user with the admin role,
  the word lexicon functions return results that might include words from
  deleted fragments. However, when run as a user with the admin role and
  without a $query parameter, the word lexicon functions run faster (because
  they do not need to look up where each word comes from). It is therefore
  faster to run word lexicon functions as an admin user without passing a
  $query parameter.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
 an element word lexicon must exist on "animal" or
 this example throws XDMP-ELEMLXCNNOTFOUND
:)
  cts:json-property-words("animal","aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// an element word lexicon must exist on "animal" or
// this example throws XDMP-ELEMLXCNNOTFOUND

  cts.jsonPropertyWords("animal","aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified element word lexicon(s) that match
  a wildcard pattern.   This function requires an element word lexicon
  configured for each of the specified elements in the function.  If there
  is not an element word lexicon configured for any of the specified
  elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string?">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with element-word-query are included.
  That is, only words present in immediate text node children of the
  specified element as well as any text node children of child elements
  defined in the Admin Interface as element-word-query-throughs or
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
 an element word lexicon must exist on "animal" or
 this example throws XDMP-ELEMLXCNNOTFOUND
:)
  cts:element-word-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// an element word lexicon must exist on "animal" or
// this example throws XDMP-ELEMLXCNNOTFOUND

  cts.elementWordMatch(xs.QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified JSON property word lexicon(s) that match
  a wildcard pattern.   This function requires a property word lexicon
  configured for each of the specified properties in the function.  If there
  is not a property word lexicon configured for any of the specified
  properties, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-names" type="xs:string*">
    One or more property names.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string?">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after skip
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with json-property-word-query are
  included.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
 an element word lexicon must exist on "animal" or
 this example throws XDMP-ELEMLXCNNOTFOUND
:)
  cts:json-property-word-match("animal","aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// an element word lexicon must exist on "animal" or
// this example throws XDMP-ELEMLXCNNOTFOUND

  cts.jsonPropertyWordMatch("animal","aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the specified element value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires an element range index for each element specified
  in the function.  If there is not a range index configured for each
  of the specified elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames. If you specify multiple lexicons, they
    must all be over the same value type (string, int, etc.).
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
	     value instead of as an xs:anyAtomicType* sequence</span>
	     <span class="javascript">a JavaScript Object instead of as
	     a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
  an element range index must exist on "animal" or
  this example throws XDMP-ELEMRIDXNOTFOUND
:)
  cts:element-values(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// an element range index must exist on "animal" or
// this example throws XDMP-ELEMRIDXNOTFOUND

  cts.elementValues(xs.QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the specified field value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires an field range index for each field specified
  in the function.  If there is not a range index configured for each
  of the specified fields, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: If a field range index does not exist on "my_field", then
 :  this example throws XDMP-FIELDRIDXNOTFOUND :)

  cts:field-values("my_field","John Goldings")

(: Returns output similar to the following:
 :   ("John Goldings","Ooi Fu",...)  :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// If a field range index does not exist on "my_field", then
// this example throws XDMP-FIELDRIDXNOTFOUND

  cts.fieldValues('my_field','John Goldings')

// Returns output similar to the following:
// ("John Goldings","Ooi Fu",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the specified value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires a range index for each of the $range-indexes specified
  in the function.  If there is not a range index configured for each
  of the specified range indexes, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-indexes" type="cts:reference*">
     A sequence of references to range indexes.
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
  Assuming that there are path namespaces defined with the following prefixes:
  my: http://aaa.com
  his: http://bbb.com

  Further assuming that a path index is defined using the above namespaces,
  '/my:a[@his:b="B1"]/my:c'.
:)
  xquery version "1.0-ml";

  declare namespace my = "http://aaa.com";
  declare namespace his = "http://bbb.com";

  xdmp:document-insert("/abc1.xml",&lt;my:a his:b="B1"&gt;&lt;my:c&gt;C1&lt;/my:c&gt;&lt;/my:a&gt;),
  xdmp:document-insert("/abc2.xml",&lt;my:a his:b="B2"&gt;&lt;my:c&gt;C2&lt;/my:c&gt;&lt;/my:a&gt;)

  (: The following is based on the above setup :)
  xquery version "1.0-ml";

  declare namespace my = "http://aaa.com";
  declare namespace his = "http://bbb.com";

  cts:values(cts:path-reference('/my:a[@his:b="B1"]/my:c'))
  =&gt;
    C1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//  Assuming that there are path namespaces defined with the following prefixes:
//  my: http://aaa.com
//  his: http://bbb.com
//
//  Further assuming that a string path index is defined using the
//  above namespaces, in the codepoint collation, with the following path:
//  '/my:a[@his:b="B1"]/my:c'.

// load documents
declareUpdate();

xdmp.documentInsert("/abc1.xml", fn.head(xdmp.unquote(
   '&lt;my:a his:b="B1" xmlns:my="http://aaa.com" \n\
 	  xmlns:his="http://bbb.com"&gt;&lt;my:c&gt;C1&lt;/my:c&gt;&lt;/my:a&gt;')));
xdmp.documentInsert("/abc2.xml",  fn.head(xdmp.unquote(
   '&lt;my:a his:b="B2" xmlns:my="http://aaa.com" \n\
 	  xmlns:his="http://bbb.com"&gt;&lt;my:c&gt;C2&lt;/my:c&gt;&lt;/my:a&gt;')));
******

// The following requires the prefix "my" and "his" to be bound
// to the "http://aaa.com" and "http://bbb.com" namespaces
// in the Group configuration (for example,
// Groups =&gt; group_name =&gt; Namespaces in the Admin Interface).

cts.values(cts.pathReference('/my:a[@his:b="B1"]/my:c'));
  =&gt;
    C1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triples" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the triple index. If subject, predicate, and object are
  given, then only triples with those given component values are returned. Triples can be
  returned in any of the sort orders present in the triple index.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="subject" type="xs:anyAtomicType*" optional="true">
     The subjects to look up. When multiple values are specified, the query matches if any value matches. When the empty sequence is specified, then triples with any subject are matched.
  </apidoc:param>
      <apidoc:param name="predicate" type="xs:anyAtomicType*" optional="true">
     The predicates to look up. When multiple values are specified, the query matches if any value matches. When the empty sequence is specified, then triples with any subject are matched.
  </apidoc:param>
      <apidoc:param name="object" type="xs:anyAtomicType*" optional="true">
     The objects to look up. When multiple values are specified, the query matches if any value matches. When the empty sequence is specified, then triples with any subject are matched.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string*" optional="true">
    If a single string is provided it is treated as the operator for the $object values. If a sequence
    of three strings are provided, they give the operators for $subject, $predicate and $object in turn.
    The default operator is "=".
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"sameTerm"</dt>
        <dd>Match triple index values which are the same RDF term as $value.
        This compares aspects of values that are ignored in XML Schema comparison semantics,
        like timezone and derived type of $value.</dd>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"order-pso"</dt>
        <dd>Return results ordered by predicate, then subject, then object.</dd>
        <dt>"order-sop"</dt>
        <dd>Return results ordered by subject, then object, then predicate.</dd>
        <dt>"order-ops"</dt>
        <dd>Return results ordered by object, then predicate, then subject.</dd>
        <dt>"quads"</dt>
        <dd>Return quads that include values for the named graph that the
        triples are in. Requires the collection lexicon enabled.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.
        </dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform work concurrently whilst returning triples from the index -
        buffering some results into memory.
        This usually takes the shortest time when returning a complete
        result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first triple from the index, and most of the work
        sequentially while iterating through the rest of the triples.
        This usually takes the shortest time when returning a partial result.
        </dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>sem:triple*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "order-pso", "order-sop", or "order-ops"
  options may be specified in the options parameter.
  If none is specified, then the default is chosen to most efficiently retrieve
  the required values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:triples(sem:iri("http://subject"), sem:iri("http://predicate"), "object")
=&gt;
 The triples with the given subject, predicate, and object.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.triples(sem.iri("http://subject"), sem.iri("http://predicate"), "object");
=&gt;
 The triples with the given subject, predicate, and object.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="triple-value-statistics" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns statistics from the triple index for the values given.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="values" type="xs:anyAtomicType*" optional="true">
     The values to look up.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return class="xquery">element(triple-value-statistics)*</apidoc:return>
    <apidoc:return class="javascript">Sequence</apidoc:return>
    <apidoc:usage schema="triple-value-statistics.xsd" camel-case="true">
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:triple-value-statistics((
  sem:iri("http://www.w3.org/2000/01/rdf-schema#subClassOf"),
  sem:iri("http://swat.cse.lehigh.edu/onto/univ-bench.owl#worksFor")
))
=&gt;
&lt;triple-value-statistics count="1104552010" unique-subjects="190980967" unique-predicates="587" unique-objects="280592619" xmlns="cts:triple-value-statistics"&gt;
  &lt;triple-value-entries&gt;
    &lt;triple-value-entry count="86"&gt;
      &lt;triple-value&gt;http://www.w3.org/2000/01/rdf-schema#subClassOf&lt;/triple-value&gt;
      &lt;subject-statistics count="0" unique-predicates="0" unique-objects="0"/&gt;
      &lt;predicate-statistics count="86" unique-subjects="81" unique-objects="51"/&gt;
      &lt;object-statistics count="0" unique-subjects="0" unique-predicates="0"/&gt;
    &lt;/triple-value-entry&gt;
    &lt;triple-value-entry count="5754107"&gt;
      &lt;triple-value&gt;http://swat.cse.lehigh.edu/onto/univ-bench.owl#worksFor&lt;/triple-value&gt;
      &lt;subject-statistics count="3" unique-predicates="3" unique-objects="3"/&gt;
      &lt;predicate-statistics count="5754099" unique-subjects="5754099" unique-objects="856163"/&gt;
      &lt;object-statistics count="4" unique-subjects="4" unique-predicates="4"/&gt;
    &lt;/triple-value-entry&gt;
  &lt;/triple-value-entries&gt;
&lt;/triple-value-statistics&gt;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.tripleValueStatistics([
  sem.iri("http://www.w3.org/2000/01/rdf-schema#subClassOf"),
  sem.iri("http://swat.cse.lehigh.edu/onto/univ-bench.owl#worksFor")
])
=&gt;
{
    "count": 1104552010,
    "uniqueSubjects": 190980967,
    "uniquePredicates": 587,
    "uniqueObjects": 280592619,
    "tripleValueEntries": [
        {
            "tripleValue": "http://www.w3.org/2000/01/rdf-schema#subClassOf",
            "count": 86,
            "subjectStatistics": {
                "count": 0,
                "uniquePredicates": 0,
                "uniqueObjects": 0
            },
            "predicateStatistics": {
                "count": 86,
                "uniqueSubjects": 81,
                "uniqueObjects": 51
            },
            "objectStatistics": {
                "count": 0,
                "uniqueSubjects": 0,
                "uniquePredicates": 0
            }
        },
        {
            "tripleValue": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#worksFor",
            "count": 5754107,
            "subjectStatistics": {
                "count": 3,
                "uniquePredicates": 3,
                "uniqueObjects": 3
            },
            "predicateStatistics": {
                "count": 5754099,
                "uniqueSubjects": 5754099,
                "uniqueObjects": 856163
            },
            "objectStatistics": {
                "count": 4,
                "uniqueSubjects": 4,
                "uniquePredicates": 4
            }
        }
    ]
}
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the specified element value lexicon(s)
   that match the specified wildcard pattern.  Element value lexicons
   are implemented using range indexes; consequently this function
   requires an element range index for each element specified in the
   function.  If there is not a range index configured for each of the
   specified elements, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used.  If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-value-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementValueMatch(xs.QName("animal"),"aardvark*");
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns value co-occurrences (that is, pairs of values, both of which appear
  in the same fragment) from the specified element value lexicon(s).  The
  values are returned as <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">an XML element</span>
  <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">an ArrayNode</span> with two children, each child
  containing one of the co-occurring values.  You can use
  <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code><code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.frequency</code>
  on each item returned to find how many times the pair occurs.
  Value lexicons are implemented using range indexes; consequently
  this function requires an element range index for each element specified
  in the function.  If there is not a range index configured for each
  of the specified elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="element-name-2" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For both lexicons, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-1=<em>type</em>"</dt>
        <dd>For the first lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the second lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For both lexicons, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-1=<em>URI</em>"</dt>
        <dd>For the first lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-2=<em>URI</em>"</dt>
        <dd>For the second lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an element(cts:co-occurrence)* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use lexicons configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use lexicons configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the co-occurrences returned by this 
  function, use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on occurrences. A fragment 
  matched by query might contain multiple occurrences or no occurrences. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered co-occurrences list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (:
     This query has the database fragmented on SPEECH and
     finds the first 3 SPEAKERs that co-occur in a SPEECH
     in the play Hamlet.
     Requires an element range index on SPEAKER with range
     value positions enabled on the range index.
  :)
  cts:element-value-co-occurrences(
    xs:QName("SPEAKER"),xs:QName("SPEAKER"),
    ("frequency-order","ordered"),
    cts:document-query("/shakespeare/plays/hamlet.xml"))[1 to 3]
  =&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;BERNARDO&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;GUILDENSTERN&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;HORATIO&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//     This query has the database fragmented on SPEECH and
//     finds the first 3 SPEAKERs that co-occur in a SPEECH
//     in the play Hamlet.
//     Requires an element range index on SPEAKER with range
//     value positions enabled on the range index.

fn.subsequence(
  cts.elementValueCoOccurrences(
    xs.QName("SPEAKER"), xs.QName("SPEAKER"),
    ["frequency-order","ordered"],
    cts.documentQuery("/shakespeare/plays/hamlet.xml")), 1, 3);
  =&gt;
["MARCELLUS", "BERNARDO"]
["ROSENCRANTZ", "GUILDENSTERN"]
["HORATIO", "MARCELLUS"]

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (:
     this query has the database fragmented on SPEECH and
     finds SPEAKERs that co-occur in a SPEECH in the play Hamlet,
     returned as a map
  :)
  cts:element-value-co-occurrences(
    xs:QName("SPEAKER"),xs:QName("SPEAKER"),
    ("frequency-order","ordered", "map"),
    cts:document-query("/shakespeare/plays/hamlet.xml"))
  =&gt;
  map:map(
   &lt;map:map xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:map="http://marklogic.com/xdmp/map"&gt;
     &lt;map:entry key="HORATIO"&gt;
       &lt;map:value xsi:type="xs:string"&gt;MARCELLUS&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="CORNELIUS"&gt;
         &lt;map:value xsi:type="xs:string"&gt;VOLTIMAND&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="MARCELLUS"&gt;
         &lt;map:value xsi:type="xs:string"&gt;BERNARDO&lt;/map:value&gt;
         &lt;map:value xsi:type="xs:string"&gt;HORATIO&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="ROSENCRANTZ"&gt;
       &lt;map:value xsi:type="xs:string"&gt;GUILDENSTERN&lt;/map:value&gt;
     &lt;/map:entry&gt;
   &lt;/map:map&gt;)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//     this query has the database fragmented on SPEECH and
//     finds SPEAKERs that co-occur in a SPEECH in the play Hamlet,
//     returned as a map

cts.elementValueCoOccurrences(
    xs.QName("SPEAKER"), xs.QName("SPEAKER"),
    ["frequency-order","ordered", "map"],
    cts.documentQuery("/shakespeare/plays/hamlet.xml"))

  =&gt;
{
	"HORATIO":"MARCELLUS",
	"CORNELIUS":"VOLTIMAND",
	"MARCELLUS":
		["BERNARDO", "HORATIO"],
	"ROSENCRANTZ":"GUILDENSTERN"
}

</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
(:
This example uses the co-occurrences between the URI lexicon
and an element range index to effectively join documents together.
:)
(: Load sample data :)
xdmp:document-insert("/test1.xml",
  &lt;test1&gt;&lt;hello&gt;this is a value&lt;/hello&gt;&lt;/test1&gt;),
xdmp:document-insert("/test2.xml",
  &lt;test2&gt;&lt;hello&gt;this is a value&lt;/hello&gt;&lt;/test2&gt;),
xdmp:document-insert("/test3.xml",
  &lt;test3&gt;&lt;hello&gt;this is a different value&lt;/hello&gt;&lt;/test3&gt;);
(:
Requires an element range index on 'hello' and the URI lexicon.
This query finds 'hello' elements that occur in more than one document.
It is an effecient way to join documents using range indexes.
:)
let $x :=
  cts:element-value-co-occurrences(
  (: note the special xdmp:document QName for the URI lexicon :)
    xs:QName("hello"),xs:QName("xdmp:document"),
    ("frequency-order", "map",
     "collation-1=http://marklogic.com/collation/",
     "collation-2=http://marklogic.com/collation/codepoint"))
for $key in map:keys($x)
where fn:count(map:get($x, $key)) gt 1
return
&lt;result&gt;
  &lt;key&gt;{$key}&lt;/key&gt;
  &lt;value&gt;{for $uri in map:get($x, $key)
          return &lt;uri&gt;{$uri}&lt;/uri&gt;}&lt;/value&gt;
&lt;/result&gt;

(: returns the values that occur in more than one document (URI) :)

=&gt;
&lt;result&gt;
  &lt;key&gt;this is a value&lt;/key&gt;
  &lt;value&gt;
    &lt;uri&gt;/test1.xml&lt;/uri&gt;
    &lt;uri&gt;/test2.xml&lt;/uri&gt;
  &lt;/value&gt;
&lt;/result&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// This example uses the co-occurrences between the URI lexicon
// and an element range index to effectively join documents together.

// Load sample data
declareUpdate();
xdmp.documentInsert("/test1.xml", fn.head(xdmp.unquote(
'  &lt;test1&gt;&lt;hello&gt;this is a value&lt;/hello&gt;&lt;/test1&gt;')));
xdmp.documentInsert("/test2.xml", fn.head(xdmp.unquote(
'  &lt;test2&gt;&lt;hello&gt;this is a value&lt;/hello&gt;&lt;/test2&gt;')));
xdmp.documentInsert("/test3.xml", fn.head(xdmp.unquote(
'  &lt;test3&gt;&lt;hello&gt;this is a different value&lt;/hello&gt;&lt;/test3&gt;')));

**********
// Requires an element range index on 'hello' and the URI lexicon.
// This query finds 'hello' element values that occur in more than one
// document. It is an effecient way to join documents using range indexes.

const x =
  cts.elementValueCoOccurrences(
  // note the special xdmp:document QName for the URI lexicon
    xs.QName("hello"), xs.QName("xdmp:document"),
  // uses the "map" option, so returns the results as a JavaScript object
    ["frequency-order", "map",
     "collation-1=http://marklogic.com/collation/",
     "collation-2=http://marklogic.com/collation/codepoint"]);
const res = new Array();
// Iterate through each property and return the ones that have
// 2 or more values.
for (y in x) {
  if (x[y].length &gt; 1) {
    const o = new Object();
    o[y] = x[y];
    res.push(o);}
};
res;

// returns the values that occur in more than one document (URI)

=&gt;
[{"this is a value":["/test1.xml", "/test2.xml"]}]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns value co-occurrences from the specified element or element-attribute
  value lexicon(s).
  Value lexicons are implemented using range indexes;
  consequently this function requires a range index for each element/attribute
  pairs specified in the function.
  If there is not a range index configured for each of the specified
  element or element/attribute pairs, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="attribute-name-1" type="xs:QName?">
    An attribute QName or empty sequence.
    The empty sequence specifies an element lexicon.
  </apidoc:param>
      <apidoc:param name="element-name-2" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="attribute-name-2" type="xs:QName?">
    An attribute QName or empty sequence.
    The empty sequence specifies an element lexicon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For both lexicons, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-1=<em>type</em>"</dt>
        <dd>For the first lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the second lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For both lexicons, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-1=<em>URI</em>"</dt>
        <dd>For the first lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-2=<em>URI</em>"</dt>
        <dd>For the second lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an element(cts:co-occurrence)* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the co-occurrences returned by this 
  function, use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on occurrences. A fragment 
  matched by query might contain multiple occurrences or no occurrences. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered co-occurrences list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (:
     This query requires attribute range indexes with positions enabled
     on the following attributes:

        value/@attr1
        value/@attr2
  :)

  (: load documents :)
xdmp:document-insert("/eaco1.xml",
&lt;root&gt;
  &lt;value attr1="value1"&gt;text&lt;/value&gt;
  &lt;value attr2="value2"&gt;other text&lt;/value&gt;
&lt;/root&gt;),
xdmp:document-insert("/eaco2.xml",
&lt;root&gt;
  &lt;value attr1="value3"&gt;text&lt;/value&gt;
  &lt;value attr2="value4"&gt;other text&lt;/value&gt;
&lt;/root&gt;);

  (: run co-occurrences query :)
 cts:element-attribute-value-co-occurrences(
    xs:QName("value"),xs:QName("attr1"),
    xs:QName("value"),xs:QName("attr2"),
    ("frequency-order","ordered"))

  =&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;value1&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;value2&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;value3&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;value4&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;


</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query requires attribute range indexes with positions enabled
//   on the following attributes:
//
//        value/@attr1
//        value/@attr2

// load the documents

declareUpdate();
xdmp.documentInsert("/eaco1.xml", fn.head(xdmp.unquote(
'&lt;root&gt;\n\
  &lt;value attr1="value1"&gt;text&lt;/value&gt;\n\
  &lt;value attr2="value2"&gt;other text&lt;/value&gt;\n\
&lt;/root&gt;')));
xdmp.documentInsert("/eaco2.xml", fn.head(xdmp.unquote(
'&lt;root&gt;\n\
  &lt;value attr1="value3"&gt;text&lt;/value&gt;\n\
  &lt;value attr2="value4"&gt;other text&lt;/value&gt;\n\
&lt;/root&gt;')));

*******
// run the co-occurrences query

cts.elementAttributeValueCoOccurrences(
    xs.QName("value"), xs.QName("attr1"),
    xs.QName("value"), xs.QName("attr2"),
    ["frequency-order","ordered"]);

  =&gt;
["value1", "value2"]
["value3", "value4"]


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the specified value lexicon(s)
   that match the specified wildcard pattern.  Value lexicons
   are implemented using range indexes; consequently this function
   requires a range index for each index reference specified in the
   function.  If there is not a range index configured for each of the
   specified references, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-indexes" type="cts:reference*">
    A sequence of references to range indexes.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match. The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used.  If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
  Assuming that there are path namespaces defined with the following prefixes:
  my: http://aaa.com
  his: http://bbb.com

  Further assuming that a path index is defined using the above namespaces,
  '/my:a[@his:b="B1"]/my:c'.
:)
  xquery version "1.0-ml";

  declare namespace my = "http://aaa.com";
  declare namespace his = "http://bbb.com";

  xdmp:document-insert("/abc1.xml",&lt;my:a his:b="B1"&gt;&lt;my:c&gt;C1&lt;/my:c&gt;&lt;/my:a&gt;),
  xdmp:document-insert("/abc2.xml",&lt;my:a his:b="B1"&gt;&lt;my:c&gt;C2&lt;/my:c&gt;&lt;/my:a&gt;),
  xdmp:document-insert("/abc3.xml",&lt;my:a his:b="B1"&gt;&lt;my:c&gt;C3&lt;/my:c&gt;&lt;/my:a&gt;)

  (: The following is based on the above setup :)
  xquery version "1.0-ml";

  declare namespace my = "http://aaa.com";
  declare namespace his = "http://bbb.com";

  cts:value-match(cts:path-reference('/my:a[@his:b="B1"]/my:c'), "?3")
  =&gt;
    C3
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//  Assuming that there are path namespaces defined with the following prefixes:
//  my: http://aaa.com
//  his: http://bbb.com
//
//  Further assuming that a string path index is defined using the
//  above namespaces, in the codepoint collation, with the following path:
//  '/my:a[@his:b="B1"]/my:c'.

// load documents
declareUpdate();

xdmp.documentInsert("/abc1.xml", fn.head(xdmp.unquote(
   '&lt;my:a his:b="B1" xmlns:my="http://aaa.com" \n\
 	  xmlns:his="http://bbb.com"&gt;&lt;my:c&gt;C1&lt;/my:c&gt;&lt;/my:a&gt;')));
xdmp.documentInsert("/abc2.xml",  fn.head(xdmp.unquote(
   '&lt;my:a his:b="B1" xmlns:my="http://aaa.com" \n\
 	  xmlns:his="http://bbb.com"&gt;&lt;my:c&gt;C2&lt;/my:c&gt;&lt;/my:a&gt;')));
xdmp.documentInsert("/abc3.xml",  fn.head(xdmp.unquote(
   '&lt;my:a his:b="B1" xmlns:my="http://aaa.com" \n\
 	  xmlns:his="http://bbb.com"&gt;&lt;my:c&gt;C3&lt;/my:c&gt;&lt;/my:a&gt;')));

******

// The following requires the prefix "my" and "his" to be bound
// to the "http://aaa.com" and "http://bbb.com" namespaces
// in the Group configuration (for example,
// Groups =&gt; group_name =&gt; Namespaces in the Admin Interface).

cts.valueMatch(cts.pathReference('/my:a[@his:b="B1"]/my:c'), "?3");
  =&gt;
    C3
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns value co-occurrences (that is, pairs of values, both of which appear
  in the same fragment) from the specified value lexicon(s).  The
  values are returned as <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">an XML element</span>
  <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">an ArrayNode</span> with two children, each child
  containing one of the co-occurring values.  You can use
  <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code><code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.frequency</code>
  on each item returned to find how many times the pair occurs.
  Value lexicons are implemented using range indexes; consequently
  this function requires a range index for each input index reference.
  If an index or lexicon is not configured for any of the input references,
  an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index-1" type="cts:reference">
    A reference to a range index.
  </apidoc:param>
      <apidoc:param name="range-index-2" type="cts:reference">
    A reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>,
        bit do not affect frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an element(cts:co-occurrence)* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the co-occurrences returned by this 
  function, use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on occurrences. A fragment 
  matched by query might contain multiple occurrences or no occurrences. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered co-occurrences list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Suppose we have a document with many news items in the database. :)

xdmp:document-insert("/news.xml",
&lt;news&gt;
  &lt;sale&gt;
   &lt;sold-item&gt;Bike&lt;/sold-item&gt;
    &lt;name&gt;
      &lt;first&gt;John&lt;/first&gt;&lt;last&gt;Griffith&lt;/last&gt;
    &lt;/name&gt;
    &lt;city&gt;Reno&lt;/city&gt;
    &lt;text&gt;...&lt;/text&gt;
  &lt;/sale&gt;
  &lt;sale&gt;
   &lt;sold-item&gt;Car&lt;/sold-item&gt;
    &lt;name&gt;
      &lt;first&gt;Will&lt;/first&gt;&lt;last&gt;Shields&lt;/last&gt;
    &lt;/name&gt;
    &lt;city&gt;Lexington&lt;/city&gt;
    &lt;text&gt;...&lt;/text&gt;
  &lt;/sale&gt;
  &lt;theft&gt;
    &lt;stolen-item&gt;Bike&lt;/stolen-item&gt;
    &lt;reporter&gt;
      &lt;first&gt;John&lt;/first&gt;&lt;last&gt;Smith&lt;/last&gt;
    &lt;/reporter&gt;
    &lt;city&gt;Las Vegas&lt;/city&gt;
    &lt;text&gt;...&lt;/text&gt;
  &lt;/theft&gt;
  &lt;theft&gt;
    &lt;stolen-item&gt;Car&lt;/stolen-item&gt;
    &lt;reporter&gt;
      &lt;first&gt;Will&lt;/first&gt;&lt;last&gt;Shields&lt;/last&gt;
    &lt;/reporter&gt;
    &lt;city&gt;Indianapolis&lt;/city&gt;
    &lt;text&gt;...&lt;/text&gt;
  &lt;/theft&gt;
&lt;/news&gt;);


(: Now suppose we have two path range indexes defined.
     Index1: /news/sale/sold-item string type
     Index2: /news/sale/city  string type

   We can find co-occurrence of items sold and the city it was sold in.
:)

  cts:value-co-occurrences(cts:path-reference("/news/sale/sold-item"),
                           cts:path-reference("/news/sale/city"))
=&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Bike&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Lexington&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Bike&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Reno&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Car&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Lexington&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Car&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Reno&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Suppose we have a document with many news items in the database.

declareUpdate();
xdmp.documentInsert("/news.json",
{news:{
  sale:[
  {soldItem:"Bike",
   name:{first:"John", last:"Griffith"},
   city:"Reno",
   text:"some text..."},
  {soldItem:"Car",
   name:{first:"Will", last:"Shields"},
   city:"Lexington",
   text:"some differnet text..."}
   ],
  theft:
  {stolenItem:"Bike",
   reporter:{first:"John", last:"Smith"},
   city:"Las Vegas",
   text:"still other text..."},
   stolenItem:"Car",
   reporter:{first:"Will", last:"Shields"},
   city:"Indianapolis",
   text:"even more text..."}
});

******

//   Now suppose we have two path range indexes defined.
//     Index1: /news/sale/soldItem string type
//     Index2: /news/sale/city  string type

//   We can find co-occurrence of items sold and the city it was sold in.

cts.valueCoOccurrences(cts.pathReference("/news/sale/soldItem"),
                           cts.pathReference("/news/sale/city"));
=&gt;
["Bike", "Lexington"]
["Bike", "Reno"]
["Car", "Lexington"]
["Car", "Reno"]


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires a range index for each element specified
  in the function.  If there is not an index or lexicon configured for
  one of the specified references, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket.
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:value-ranges(cts:path-reference("/name/fname"), ("f", "m"))</pre>
  <pre class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.valueRanges(cts.pathReference("/name/fname"), ["f", "m"])</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
  <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, an ObjectNode is returned.
  Each ObjectNode has a <code>minimum</code> property and a <code>maximum</code>
  property.  If a bucket is bounded, its ObjectNode will also have a
  <code>lowerBound</code> property if it is bounded from below, and
  a <code>upperBound</code> property if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-indexes" type="cts:reference*">
    A sequence of references to range indexes.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds.
    The types must match the lexicon type.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges
        will have no minimum or maximum value.  Only empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then ranges with all included values may be returned. If a
  <code>$query</code> parameter is not present, then "sample=<em>N</em>"
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered results list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have a string path range index on
   path /name/fname. :)
xquery version "1.0-ml";

xdmp:document-insert("/aname1.xml",
 &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname2.xml",
 &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname3.xml",
 &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname4.xml",
 &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname5.xml",
 &lt;name&gt;&lt;fname&gt;Anthony&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Flemings&lt;/lname&gt;
 &lt;/name&gt;),
xdmp:document-insert("/aname6.xml",
 &lt;name&gt;&lt;fname&gt;Charles&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Winter&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname7.xml",
 &lt;name&gt;&lt;fname&gt;Nancy&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Schmidt&lt;/lname&gt;&lt;/name&gt;),
xdmp:document-insert("/aname8.xml",
 &lt;name&gt;&lt;fname&gt;Robert&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Hanson&lt;/lname&gt;&lt;/name&gt;)

(: The following is based on the above setup :)

xquery version "1.0-ml";

cts:value-ranges(cts:path-reference("/name/fname"),("A","J","O"))
=&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:string"&gt;Anthony Flemings&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:string"&gt;Charles Winter&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:string"&gt;A&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:string"&gt;J&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:string"&gt;James Tod&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:string"&gt;Nancy Schmidt&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:string"&gt;J&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:string"&gt;O&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:string"&gt;Ooi Fu&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:string"&gt;Robert Hanson&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:string"&gt;O&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//  Run the following to load data for this example.
//  Make sure you have a string path range index on path:
//     /name/fname

declareUpdate();
xdmp.documentInsert("/aname1.json",
 {name:{fname:"John", mname:"Rob", lname:"Goldings"}});
xdmp.documentInsert("/aname2.json",
 {name:{fname:"Jim", mname:"Ken", lname:"Kurla"}});
xdmp.documentInsert("/aname3.json",
 {name:{fname:"Ooi", mname:"Ben", lname:"Fu"}});
xdmp.documentInsert("/aname4.json",
 {name:{fname:"James", mname:"Rick", lname:"Tod"}});
xdmp.documentInsert("/aname5.json",
 {name:{fname:"Anthony", mname:"Rob", lname:"Flemings"}});
xdmp.documentInsert("/aname6.json",
 {name:{fname:"Charles", mname:"Ken", lname:"Winter"}});
xdmp.documentInsert("/aname7.json",
 {name:{fname:"Nancy", mname:"Ben", lname:"Schmidt"}});
xdmp.documentInsert("/aname8.json",
 {name:{fname:"Robert", mname:"Rick", lname:"Hanson"}});

*******
// The following is based on the above setup

cts.valueRanges(cts.pathReference("/name/fname"),["A","J","O"]);
=&gt;
{"minimum":"Anthony", "maximum":"Charles", "lowerBound":"A", "upperBound":"J"}
{"minimum":"James", "maximum":"Nancy", "lowerBound":"J", "upperBound":"O"}
{"minimum":"Ooi", "maximum":"Robert", "lowerBound":"O"}

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reference-scalar-type" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Accessor for the scalar type of a reference to a value lexicon.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="index" type="cts:reference">
    The value lexicon reference, as created from cts:element-reference,
    for example.</apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:reference-scalar-type(cts:element-reference(xs:QName("TITLE")))
=&gt;
"string"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.referenceScalarType(cts.elementReference(xs.QName("TITLE")));
=&gt;
"string"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reference-nullable" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns true() if the reference is nullable, false() otherwise.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="reference" type="cts:reference">
    An index reference.</apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:reference-nullable(cts:element-reference("title","nullable"))
=&gt;
true()

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.referenceNullable(cts.elementReference("TITLE",["nullable"]))
=&gt;
true

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reference-collation" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Accessor for the collation of a reference to a string value lexicon.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="index" type="cts:reference">
    The value lexicon reference, as created from cts:element-reference,
    for example.</apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:reference-collation(cts:element-reference(xs:QName("TITLE")))
=&gt;
"http://marklogic.com/collation/"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.referenceCollation(cts.elementReference(xs.QName("TITLE")));
=&gt;
"http://marklogic.com/collation/"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reference-coordinate-system" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Accessor for the coordinate-system of a reference to a geospatial lexicon.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="index" type="cts:reference">
    The value lexicon reference, as created from cts:geospatial-element-reference,
    for example.</apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:reference-coordinate-system(cts:geospatial-element-reference(xs:QName("Point")))
=&gt;
"wgs84"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.referenceCoordinateSystem(cts.geospatialElementReference(xs.QName("Point")));
=&gt;
"wgs84"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="uri-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to the URI lexicon, for use as a parameter to
  cts:value-tuples.  This function requires the URI lexicon to be enabled,
  otherwise it throws an exception.
</apidoc:summary>
    <apidoc:params/>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:uri-reference()
=&gt;
cts:uri-reference()
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.uriReference();
=&gt;
cts.uriReference()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to the collection lexicon, for use as a parameter to
  cts:value-tuples.  Since lexicons are implemented with range indexes,
  this function will throw an exception if the specified range index does
  not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Do not check the definition against the context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:collection-reference()
=&gt;
cts:collection-reference(())
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.collectionReference();
=&gt;
cts.collectionReference([])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to an element value lexicon, for use as a parameter to
  <a href="#cts:value-tuples" class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>cts:value-tuples</code></a><a href="#cts.valueTuples" class="javascript" xmlns="http://www.w3.org/1999/xhtml"><code>cts.valueTuples</code></a>,
  <a href="#temporal:axis-create" class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>temporal:axis-create</code></a><a href="#temporal.axisCreate" class="javascript" xmlns="http://www.w3.org/1999/xhtml"><code>temporal.axisCreate</code></a>, or any
  other function that takes an index reference.  Since lexicons are
  implemented with range indexes, this function will throw an exception if
  the specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element QName.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, anyURI, point, or
        long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type, collation and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Create a reference to an index or lexicon based on the specified
         coordinate system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the index/lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Create a reference to an index or lexicon configured with the
         specified geospatial precision. Allowed values: <code>float</code>
         and <code>double</code>. Only applicable if the index/lexicon value
         type is <code>point</code> or <code>long-lat-point</code>. This
         value takes precedence over the precision implicit in the coordinate
         system name.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:element-reference(xs:QName("TITLE"))
=&gt;
cts:element-reference(fn:QName("", "TITLE"),
  ("type=string","collation=http://marklogic.com/collation/"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementReference(xs.QName("TITLE"));
=&gt;
cts.elementReference(fn.QName("","TITLE"),
  ["type=string","collation=http://marklogic.com/collation/"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to a JSON property value lexicon, for use as a parameter
  to cts:value-tuples.  Since lexicons are implemented with range indexes,
  this function will throw an exception if the specified range index does
  not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property" type="xs:string">
    A property name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, anyURI, point, or
        long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type, collation and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Create a reference to an index or lexicon based on the specified
         coordinate system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the index/lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Create a reference to an index or lexicon configured with the
         specified geospatial precision. Allowed values: <code>float</code>
         and <code>double</code>. Only applicable if the index/lexicon value
         type is <code>point</code> or <code>long-lat-point</code>. This
         value takes precedence over the precision implicit in the coordinate
         system name.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:json-property-reference("TITLE");
=&gt;
cts:json-property-reference("TITLE",("type=string","collation=http://marklogic.com/collation/"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.jsonPropertyReference("TITLE");
=&gt;
cts.jsonPropertyReference("TITLE",
  ["type=string","collation=http://marklogic.com/collation/"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to an element attribute value lexicon, for use as a
  parameter to cts:value-tuples.  Since lexicons are implemented with range
  indexes, this function will throw an exception if the specified range index
  does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element QName.</apidoc:param>
      <apidoc:param name="attribute" type="xs:QName">
    An attribute QName.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, anyURI, point, or
        long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type, collation and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Create a reference to an index or lexicon based on the specified
         coordinate system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the index/lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Create a reference to an index or lexicon configured with the
         specified geospatial precision. Allowed values: <code>float</code>
         and <code>double</code>. Only applicable if the index/lexicon value
         type is <code>point</code> or <code>long-lat-point</code>. This
         value takes precedence over the precision implicit in the coordinate
         system name.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:element-attribute-reference(xs:QName("SONG"), xs:QName("rating"));
=&gt;
cts:element-reference(fn:QName("", "SONG"), fn:QName("","rating"),
   ("type=int") )
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.elementAttributeReference(xs.QName("SONG"), xs.QName("rating"));
=&gt;
cts.elementAttributeReference(fn.QName("","SONG"),fn.QName("","rating"),
  ["type=int"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to a field value lexicon, for use as a
  parameter to 
  <a class="xquery" href="#cts:value-tuples" xmlns="http://www.w3.org/1999/xhtml">cts:value-tuples</a><a class="javascript" href="#cts.valueTuples" xmlns="http://www.w3.org/1999/xhtml">cts.valueTuples</a>.
  Since lexicons are implemented with range indexes, this function will 
  throw an exception if the specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field" type="xs:string">
    A field name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, anyURI, point, or
        long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type, collation and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Create a reference to an index or lexicon based on the specified
         coordinate system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the index/lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Create a reference to an index or lexicon configured with the
         specified geospatial precision. Allowed values: <code>float</code>
         and <code>double</code>. Only applicable if the index/lexicon value
         type is <code>point</code> or <code>long-lat-point</code>. This
         value takes precedence over the precision implicit in the coordinate
         system name.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:field-reference("authors",("collation=http://marklogic.com/collation/en"))
=&gt;
cts:field-reference("authors",
  ("type=string","collation=http://marklogic.com/collation/en"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.fieldReference("authors",["collation=http://marklogic.com/collation/en"]);
=&gt;
cts.fieldReference("authors",
  ["type=string","collation=http://marklogic.com/collation/en"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to a path value lexicon, for use as a
  parameter to cts:value-tuples.  Since lexicons are implemented with range
  indexes, this function will throw an exception if the specified range index
  does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="path-expression" type="xs:string">
    A path range index expression.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, anyURI, point, or
        long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type, collation and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Create a reference to an index or lexicon based on the specified
         coordinate system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the index/lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Create a reference to an index or lexicon configured with the
         specified geospatial precision. Allowed values: <code>float</code>
         and <code>double</code>. Only applicable if the index/lexicon value
         type is <code>point</code> or <code>long-lat-point</code>. This
         value takes precedence over the precision implicit in the coordinate
         system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="map" type="map:map" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the interpretation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:path-reference("/section/title", ())
=&gt;
cts:path-reference("/section/title",("type=string","collation=http://marklogic.com/collation/"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.pathReference("/section/title");
=&gt;
cts.pathReference("/section/title",
  ["type=string","collation=http://marklogic.com/collation/"])
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.pathReference("/a:section/b:title",
  ["type=string","collation=http://marklogic.com/collation/codepoint"],
  {a:"a-namespace", b:"b-namespace"});
=&gt;
cts.pathReference("/a:section/b:title",
  ["type=string","collation=http://marklogic.com/collation/codepoint"],
  {a:"a-namespace", b:"b-namespace"})
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="value-tuples" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns value co-occurrence tuples (that is, tuples of values, each of
  which appear in the same fragment) from the specified value lexicons.  The
  values are returned as <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">json:array values</span>
  <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">array nodes</span>, where each slot contains
  one of the co-occurring values.  You can use
  <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> on each item returned to find how many times
  the tuple occurs.
  Value lexicons are implemented using range indexes; consequently
  this function requires a range index for each lexicon specified
  in the function, and the range index must have range value positions
  set to true.  If there is not a range index configured for each
  of the specified elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-indexes" type="cts:reference*">
    A sequence of references to range indexes.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> tuples. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>json:array*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on tuples. A fragment 
  matched by query might contain multiple occurences or no occurences. 
  The number of fragments skipped does not correspond to the number of 
  occurrences. Also, the skip is applied to the relevance ordered query matches,
  not to the ordered tuples list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:value-tuples(
  (cts:uri-reference(),
   cts:element-reference(xs:QName("hello")))
   )
(:
  Returns zero or more json:arrays listing co-occurrences between
  URIs with values from the lexicon for the element "hello".
  Requires a URI lexicon and an element range index on "hello".
:)


</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.valueTuples(
  [cts.uriReference(),
   cts.elementReference(xs.QName("hello"))]
   );

//  Returns a Sequence containing zero or more array nodes listing
//  co-occurrences between URIs with values from the lexicon for
//  the element "hello".  Requires a URI lexicon and an element
//  range index on "hello".


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="aggregate" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Executes a user-defined extension aggregate function against
  a value lexicon or n-way co-occurence of multiple value lexicons.
  Value lexicons are implemented using range indexes; consequently
  this function requires a range index for each lexicon specified
  in the function. If a specified range index does not exist an error is raised.
  If the "ordered" or "proximity=" option is specified, the
  range index must have range value positions set to true, otherwise an
  error is raised.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="native-plugin" type="xs:string">
    The path to the native plugin library containing the implementation of the
    user-defined extension aggregate.
  </apidoc:param>
      <apidoc:param name="aggregate-name" type="xs:string">
    The name of an aggregate function in <code xmlns="http://www.w3.org/1999/xhtml">$native-plugin</code>.
  </apidoc:param>
      <apidoc:param name="range-indexes" type="cts:reference*">
    A sequence of references to range indexes.  The first range index specified in this or any other
    aggregate function cannot be of type "nullable".
  </apidoc:param>
      <apidoc:param name="argument" type="item()*" optional="true">
    A sequence containing the arguments for the aggregate function. A map
    can be used to pass in multiple sequences of arguments.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>item()*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/aggregate.xml%2353331'>Using Aggregate User-Defined Functions</a> in the <em>Search Developer's Guide</em>.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">

xquery version "1.0-ml";

  (:
     This query assumes an element range index is configured
     in the database for the 'Amount' element and that a plugin module
     installed under native/samplePlugin contains a UDF named "myAvg".
  :)

cts:aggregate("native/samplePlugin, "myAvg",
  cts:element-reference(xs:QName("Amount"), "type=decimal"),
  (),("fragment-frequency","concurrent"))

=&gt; 1410.23914666667
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//    This query assumes an element range index is configured
//    in the database for the 'Amount' element and that a plugin module
//    installed under native/samplePlugin contains a UDF named "myAvg".

cts.aggregate("native/samplePlugin, "myAvg",
  cts.elementReference(xs.QName("Amount"), "type=decimal"),
  null, ["fragment-frequency","concurrent"]);

=&gt; 1410.23914666667
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="count-aggregate" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the count of a value lexicon.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">cts:count</code> except it performs the
  counting in parallel in all data nodes then aggregates the values. It
  generally performs better than <code xmlns="http://www.w3.org/1999/xhtml">cts:count</code>, especially on
  large clusters.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:count-aggregate(cts:path-reference("/path/index"))
=&gt;
12
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.countAggregate(cts.pathReference("/path/index"));
=&gt;
12
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="min" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the minimal value given a value lexicon.
  This function performs the calculation in parallel in all data nodes then
  aggregates the values. It generally performs better than <code xmlns="http://www.w3.org/1999/xhtml">fn:min</code>,
  especially on large clusters.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

  (:
     This query assumes an element range index is configured
     in the database for the 'Amount' element.
  :)

cts:min(cts:element-reference(xs:QName("Amount")))

=&gt; 59.95000000000000125
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an element range index is configured
//   in the database for the 'Amount' element.

cts.min(cts.elementReference(xs.QName("Amount")))

=&gt; 59.95000000000000125
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="max" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the maximal value given a value lexicon.
  This function performs the calculation in parallel in all data nodes then
  aggregates the values. It generally performs better than <code xmlns="http://www.w3.org/1999/xhtml">fn:max</code>,
  especially on large clusters.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

  (:
     This query assumes an element range index is configured
     in the database for the 'Amount' element.
  :)

cts:max(cts:element-reference(xs:QName("Amount")))

=&gt; 162.9500000000000034
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an element range index is configured
//   in the database for the 'Amount' element.

cts.max(cts.elementReference(xs.QName("Amount")));

=&gt; 162.9500000000000034
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="sum-aggregate" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the sum of the values given a value lexicon.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">cts:sum</code> except it performs the
  calculation in parallel in all data nodes then aggregates the values.
  It generally performs better than <code xmlns="http://www.w3.org/1999/xhtml">cts:sum</code>, especially on
  large clusters.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

  (:
     This query assumes an element range index is configured
     in the database for the 'Amount' element.
  :)

cts:sum-aggregate(cts:element-reference(xs:QName("Amount")))

=&gt; 733.7600000000000128
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an element range index is configured
//   in the database for the 'Amount' element.

cts.sumAggregate(cts.elementReference(xs.QName("Amount")));

=&gt; 733.7600000000000128
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="avg-aggregate" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the average of the values given a value lexicon.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">cts:avg</code> except it performs the
  calculation in parallel in all data nodes then aggregates the values.
  It generally performs better than <code xmlns="http://www.w3.org/1999/xhtml">cts:avg</code>, especially on
  large clusters.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

  (:
     This query assumes an element range index is configured
     in the database for the 'Amount' element.
  :)

cts:avg-aggregate(cts:element-reference(xs:QName("Amount")))

=&gt; 122.2933333333333355
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an element range index is configured
//   in the database for the 'Amount' element.

cts.avgAggregate(cts.elementReference(xs.QName("Amount")));

=&gt; 122.2933333333333355
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="variance-p" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns a frequency-weighted variance of the population given a value lexicon.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">math:variance-p</code> except each item in the
  lexicon is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
  The function returns the empty sequence if the lexicon contains no value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);


cts:variance-p(
  cts:element-reference(xs:QName("int"),"type=int"),
    ("item-frequency","concurrent")),
cts:variance-p(
  cts:element-reference(xs:QName("int"),"type=int"),
    ("fragment-frequency","concurrent"))
=&gt;
6
8.25


</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an int range index
//   is configured in the database. It
//   generates some sample data and then
//   performs the aggregation in a separate
//   transaction.

declareUpdate();

for (x=1; x&lt;11; x++) {
  const o = new Object();
  o.int = [];
  for (y=x; y&lt;11; y++) {
    o.int.push(y);
  };
  xdmp.documentInsert((x + ".json"), o);
};

*******
// Then run the following (requires int range index on int):

const item = cts.varianceP(
  cts.jsonPropertyReference("int","type=int"),
    ["item-frequency","concurrent"]);
const frag = cts.varianceP(
  cts.jsonPropertyReference("int","type=int"),
    ["fragment-frequency","concurrent"]);
const res = new Array();
res.push(item);
res.push(frag);
res;
=&gt;
[6, 6]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="variance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns a frequency-weighted sample variance given a value lexicon. This
  function works like <code xmlns="http://www.w3.org/1999/xhtml">math:variance</code> except each item in the
  lexicon is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
  The function returns the empty sequence if the lexicon contains no value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);


cts:variance(
  cts:element-reference(xs:QName("int"),"type=int"),
       ("item-frequency","concurrent")),
cts:variance(
  cts:element-reference(xs:QName("int"),"type=int"),
       ("fragment-frequency","concurrent"))
=&gt;
6.11111111111111
9.16666666666667

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an int range index
//   is configured in the database. It
//   generates some sample data and then
//   performs the aggregation in a separate
//   transaction.

declareUpdate();

for (x=1; x&lt;11; x++) {
  const o = new Object();
  o.int = [];
  for (y=x; y&lt;11; y++) {
    o.int.push(y);
  };
  xdmp.documentInsert((x + ".json"), o);
};

*******
// Then run the following (requires int range index on int):

const item = cts.variance(
  cts.jsonPropertyReference("int","type=int"),
    ["item-frequency","concurrent"]);
const frag = cts.variance(
  cts.jsonPropertyReference("int","type=int"),
    ["fragment-frequency","concurrent"]);
const res = new Array();
res.push(item);
res.push(frag);
res;
=&gt;
[6.11111111111111, 6.11111111111111]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="stddev-p" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns a frequency-weighted standard deviation of the population given
  a value lexicon. This function works like <code xmlns="http://www.w3.org/1999/xhtml">math:stddev-p</code>
  except each item in the lexicon is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
  The function returns the empty sequence if the lexicon contains no value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);


cts:stddev-p(
   cts:element-reference(xs:QName("int"),"type=int"),
      ("item-frequency","concurrent")),
cts:stddev-p(
   cts:element-reference(xs:QName("int"),"type=int"),
      ("fragment-frequency","concurrent"))
=&gt;
2.44948974278318
2.87228132326901

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an int range index
//   is configured in the database. It
//   generates some sample data and then
//   performs the aggregation in a separate
//   transaction.

declareUpdate();

for (x=1; x&lt;11; x++) {
  const o = new Object();
  o.int = [];
  for (y=x; y&lt;11; y++) {
    o.int.push(y);
  };
  xdmp.documentInsert((x + ".json"), o);
};

*******
// Then run the following (requires int range index on int):

const item = cts.stddevP(
  cts.jsonPropertyReference("int","type=int"),
    ["item-frequency","concurrent"]);
const frag = cts.stddevP(
  cts.jsonPropertyReference("int","type=int"),
    ["fragment-frequency","concurrent"]);
const res = new Array();
res.push(item);
res.push(frag);
res;
=&gt;
[2.44948974278318, 2.44948974278318]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="stddev" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns a frequency-weighted sample standard deviation given a value lexicon.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">math:stddev</code> except each item in the
  lexicon is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
  The function returns the empty sequence if the lexicon contains no value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="range-index" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);


cts:stddev(
  cts:element-reference(xs:QName("int"),"type=int"),
    ("item-frequency","concurrent")),
cts:stddev(
  cts:element-reference(xs:QName("int"),"type=int"),
    ("fragment-frequency","concurrent"))
=&gt;
2.47206616236522
3.02765035409749

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes an int range index
//   is configured in the database. It
//   generates some sample data and then
//   performs the aggregation in a separate
//   transaction.

declareUpdate();

for (x=1; x&lt;11; x++) {
  const o = new Object();
  o.int = [];
  for (y=x; y&lt;11; y++) {
    o.int.push(y);
  };
  xdmp.documentInsert((x + ".json"), o);
};

*******
// Then run the following (requires int range index on int):

const item = cts.stddev(
  cts.jsonPropertyReference("int","type=int"),
    ["item-frequency","concurrent"]);
const frag = cts.stddev(
  cts.jsonPropertyReference("int","type=int"),
    ["fragment-frequency","concurrent"]);
const res = new Array();
res.push(item);
res.push(frag);
res;
=&gt;
[2.47206616236522, 2.47206616236522]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="covariance-p" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the frequency-weighted covariance of the population given a 2-way
  co-occurrence. The co-occurence is formed from the specified value lexicons.
  This function works like <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">math:covariance-p</code>
  <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">math.covarianceP</code> except each pair
  in the co-occurrence is counted <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>
  <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.frequency</code> times. This
  function performs the calculation in parallel in all data nodes then
  aggregates the values.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="value1" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="value2" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";

  (:
     This query assumes range indexes with positions are
     configured in the database for both xval and yval. It
     generates some sample data and then performs the
     aggregation in a separate transaction.
  :)
  for $i in 1 to 10
  let $j := 2 * $i
  return
    xdmp:document-insert(fn:concat($i, ".xml"),
      &lt;a&gt;&lt;xval&gt;{$i}&lt;/xval&gt;{
        for $a in 1 to $i
        return &lt;yval&gt;{$j}&lt;/yval&gt;
      }&lt;/a&gt;
    );

  cts:covariance-p(
    cts:element-reference(xs:QName("yval")),
    cts:element-reference(xs:QName("xval")),
    ("item-frequency"))

  =&gt; 12
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes range indexes with positions are
//   configured in the database for both xval and yval. It
//   generates some sample data and then performs the
//   aggregation in a separate transaction.

//  Generate data:
declareUpdate();

for (x=1; x&lt;11; x++) {
  const j = 2 * x;
  const o = new Object();
  o.xval = x;
  o.yval = [];
  for (y=0; y&lt;x; y++) {
    o.yval.push(j);
  };
  xdmp.documentInsert(("cov" + x + ".json"), o);
};

*******
// Run the query:
cts.covarianceP(
  cts.jsonPropertyReference("xval","type=int"),
  cts.jsonPropertyReference("yval","type=int"),
    ["item-frequency"]);
=&gt;
12
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="covariance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the frequency-weighted sample covariance given a 2-way co-occurrence.
  The co-occurence is formed from the specified value lexicons.
  This function works like <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">math:covariance</code>
  <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">math.covariance</code> except each pair
  in the co-occurrence is counted <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>
  <code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="value1" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="value2" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";

  (:
     This query assumes range indexes with positions are
     configured in the database for both xval and yval. It
     generates some sample data and then performs the
     aggregation in a separate transaction.
  :)
  for $i in 1 to 10
  let $j := 2 * $i
  return
    xdmp:document-insert(fn:concat($i, ".xml"),
      &lt;a&gt;&lt;xval&gt;{$i}&lt;/xval&gt;{
        for $a in 1 to $i
        return &lt;yval&gt;{$j}&lt;/yval&gt;
      }&lt;/a&gt;
    );

  cts:covariance(
    cts:element-reference(xs:QName("yval")),
    cts:element-reference(xs:QName("xval")),
    ("item-frequency"))

  =&gt; 12.2222222222222
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes range indexes with positions are
//   configured in the database for both xval and yval. It
//   generates some sample data and then performs the
//   aggregation in a separate transaction.

//  Generate data:
declareUpdate();

for (x=1; x&lt;11; x++) {
  const j = 2 * x;
  const o = new Object();
  o.xval = x;
  o.yval = [];
  for (y=0; y&lt;x; y++) {
    o.yval.push(j);
  };
  xdmp.documentInsert(("cov" + x + ".json"), o);
};

*******
// Run the query:
cts.covariance(
  cts.jsonPropertyReference("xval","type=int"),
  cts.jsonPropertyReference("yval","type=int"),
    ["item-frequency"]);
=&gt;
12.2222222222222
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="correlation" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns the frequency-weighted correlation given a 2-way co-occurrence.
  The co-occurence is formed from the specified value lexicons.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">math:correlation</code> except each pair
  in the input lexicons is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times. This
  function performs the calculation in parallel in all data nodes then
  aggregates the values.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="value1" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="value2" type="cts:reference">
    Reference to a range index. The type of the range index must be numeric.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <code xmlns="http://www.w3.org/1999/xhtml">cts:aggregate</code>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xquery version "1.0-ml";

  (:
     This query assumes range indexes with positions are
     configured in the database for both xval and yval. It
     generates some sample data and then performs the
     aggregation in a separate transaction.
  :)
  for $i in 1 to 10
  let $j := 2 * $i
  return
    xdmp:document-insert(fn:concat($i, ".xml"),
      &lt;a&gt;&lt;xval&gt;{$i}&lt;/xval&gt;{
        for $a in 1 to $i
        return &lt;yval&gt;{$j}&lt;/yval&gt;
      }&lt;/a&gt;
    );

  cts:correlation(
    cts:element-reference(xs:QName("yval")),
    cts:element-reference(xs:QName("xval")),
    ("item-frequency"))

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes range indexes with positions are
//   configured in the database for both xval and yval. It
//   generates some sample data and then performs the
//   aggregation in a separate transaction.

//  Generate data:
declareUpdate();

for (x=1; x&lt;11; x++) {
  const j = 2 * x;
  const o = new Object();
  o.xval = x;
  o.yval = [];
  for (y=0; y&lt;x; y++) {
    o.yval.push(j);
  };
  xdmp.documentInsert(("cov" + x + ".json"), o);
};

*******
// Run the query:
cts.correlation(
  cts.jsonPropertyReference("xval","type=int"),
  cts.jsonPropertyReference("yval","type=int"),
    ["item-frequency"]);
=&gt;
1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="linear-model" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon">
    <apidoc:summary>
  Returns a linear model that fits the frequency-weighted data set.
  The input data is a co-occurrence, formed from the specified value
  lexicons. The length of the input lexicon sequence should be 2, as
  currently only simple linear regression model is supported. The
  first lexicon should be the value of the dependent variable while
  the other lexicon should be the value of the independent variable.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">math:linear-model</code> except each
  pair in the input lexicons is counted <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> times.
  This function performs the calculation in parallel in all data nodes
  then aggregates the values.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="values" type="cts:reference*">
    References to two range indexes. The types of the range indexes must be
    numeric. If the size of this sequence is not 2, the function returns
    the empty sequence.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Same as the "options" parameter in <a href="#cts:aggregate" xmlns="http://www.w3.org/1999/xhtml"><code>cts:aggregate</code></a>.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
     Same as the "query" parameter in <a href="#cts:aggregate" xmlns="http://www.w3.org/1999/xhtml"><code>cts:aggregate</code></a>.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
     Same as the "forest-ids" parameter in <a href="#cts:aggregate" xmlns="http://www.w3.org/1999/xhtml"><code>cts:aggregate</code></a>.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>math:linear-model?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
  (:
     This query assumes range indexes of type unsignedLong
     with positions are configured in the database for both
     xval and yval. It generates some sample data and then
     performs the aggregation in a separate transaction.
  :)
for $i in (1 to 10)
let $j := 2*$i + 1
let $uri := concat($i, ".xml")
return
   xdmp:document-insert($uri, &lt;a&gt;&lt;xval&gt;{$i}&lt;/xval&gt;&lt;yval&gt;{$j}&lt;/yval&gt;&lt;/a&gt;);

cts:linear-model(
    (cts:element-reference(xs:QName("yval"), ("type=unsignedLong")),
    cts:element-reference(xs:QName("xval"), ("type=unsignedLong"))),
    "item-frequency")
=&gt;
math:linear-model(
  &lt;math:linear-model intercept="1" coefficients="2" rsquared="1"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:math="http://marklogic.com/xdmp/math"/&gt;)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   This query assumes range indexes of type unsignedLong
//   with positions are configured in the database for both
//   xval and yval. It generates some sample data and then
//   performs the aggregation in a separate transaction.

//  Generate data:
declareUpdate();

for (x=1; x&lt;11; x++) {
  const j = 2 * x + 1;
  const uri = fn.concat(x, ".json");
  const vals = {xval:x, yval:j}
  const obj = {a:vals};
  xdmp.documentInsert(uri, obj);
  };

*******
// Run the following query:

cts.linearModel(
    [cts.jsonPropertyReference("yval", ["type=unsignedLong"]),
     cts.jsonPropertyReference("xval", ["type=unsignedLong"])],
    "item-frequency");

=&gt;
math.linearModel(
  &lt;math:linear-model intercept="0.352941176470588"
      coefficients="1.97058823529412" rsquared="0.995196571090748"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:math="http://marklogic.com/xdmp/math"/&gt;)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified element value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires an element range index for each element specified
  in the function.  If there is not a range index configured for each
  of the specified elements, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket.
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))</pre>
  <pre class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.elementValueRanges(xs.QName("myElement"), ["f", "m"])</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
  <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, an ObjectNode is returned.
  Each ObjectNode has a <code>minimum</code> property and a <code>maximum</code>
  property.  If a bucket is bounded, its ObjectNode will also have a
  <code>lowerBound</code> property if it is bounded from below, and
  a <code>upperBound</code> property if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds.
    The types must match the lexicon type.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges
        will have no minimum or maximum value.  Only empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then ranges with all included values may be returned. If a
  <code>$query</code> parameter is not present, then "sample=<em>N</em>"
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered results list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have an int element range index on
   number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;number&gt;{$x}&lt;/number&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-value-ranges(xs:QName("number"),
  (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;

  
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Run the following to load data for this example.
// Make sure you have an int element range index on
// number.

declareUpdate();
for (x=1;x&lt;11;x++) {
  xdmp.documentInsert("/" + x + ".xml",
          fn.head(xdmp.unquote('&lt;root&gt;&lt;number&gt;' + x +
                       '&lt;/number&gt;&lt;/root&gt;')));
};
*********

// Now run the following:

cts.elementValueRanges(xs.QName("number"),
                             [5, 10, 15, 20], "empties")

=&gt;
{"minimum":1, "maximum":4, "upperBound":5}
{"minimum":5, "maximum":9, "lowerBound":5, "upperBound":10}
{"minimum":10, "maximum":10, "lowerBound":10, "upperBound":15}
{"lowerBound":15, "upperBound":20}
{"lowerBound":20}

  
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: this query has the database fragmented on SPEECH and
     finds four ranges of SPEAKERs :)
  cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"));
  =&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;All&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Danes&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;First Ambassador&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Messenger&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;OPHELIA&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;Second Clown&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;VOLTIMAND&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//  this query has the database fragmented on SPEECH and
//  finds four ranges of SPEAKERs, against the shakespeare database

cts.elementValueRanges(xs.QName("SPEAKER"), ["F","N","S"]);
=&gt;
{"minimum":"", "maximum":"EXTON", "upperBound":"F"}
{"minimum":"FABIAN", "maximum":"MYRMIDONS", "lowerBound":"F", "upperBound":"N"}
{"minimum":"NATHANIEL", "maximum":"RUTLAND", "lowerBound":"N", "upperBound":"S"}
{"minimum":"Sailor", "maximum":"YOUNG SIWARD", "lowerBound":"S"}

&lt;/pre&gt;&lt;/apidoc:example&gt;

&lt;apidoc:example class="xquery"&gt;&lt;pre xml:space="preserve"&gt;&lt;![CDATA[
  (: this is the same query as above, but it is getting the counts
     of the number of SPEAKERs for each bucket :)
  for $bucket in cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"))
  return cts:frequency($bucket);
  =&gt;
     9598
     11321
     5166
     4981

  
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// this is the same query as above, but it is getting the counts
// of the number of SPEAKERs for each bucket

const res = new Array();
for (const range of cts.elementValueRanges(xs.QName("SPEAKER"), ["F","N","S"]) )
{
  res.push(cts.frequency(range));
};
res;

=&gt;  [9598, 11321, 5166, 4981]
  
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the specified field value lexicon(s)
   that match the specified wildcard pattern.  Field value lexicons
   are implemented using range indexes; consequently this function
   requires a field range index for each field specified in the
   function.  If there is not a range index configured for each of the
   specified fields, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd class="xquery">Return results as <span class="xquery">a single
         map:map value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used.  If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 cts:field-value-match("aname","Jim *")
  =&gt; "Jim Kurla"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 cts.fieldValueMatch("aname","Jim *");
  =&gt; "Jim Kurla"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns value co-occurrences (that is, pairs of values, both of which appear
  in the same fragment) from the specified field value lexicon(s).  The
  values are returned as <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">an XML element</span>
  <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">an ArrayNode</span> with two children, each child
  containing one of the co-occurring values.  You can use
  <code class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code><code class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.frequency</code>
  on each item returned to find how many times the pair occurs.
  Value lexicons are implemented using range indexes; consequently
  this function requires an field range index for each field specified
  in the function.  If there is not a range index configured for each
  of the specified fields, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-name-1" type="xs:string">
    A string.
  </apidoc:param>
      <apidoc:param name="field-name-2" type="xs:string">
    A string.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For both lexicons, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-1=<em>type</em>"</dt>
        <dd>For the first lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the second lexicon, use the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For both lexicons, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-1=<em>URI</em>"</dt>
        <dd>For the first lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"collation-2=<em>URI</em>"</dt>
        <dd>For the second lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>,
        bit do not affect frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an element(cts:co-occurrence)* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the co-occurrences returned by this 
  function, use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on occurrences. A fragment 
  matched by query might contain multiple occurrences or no occurrences. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered co-occurrences list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: Suppose we insert these two documents in the database.

  Document 1:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;John&lt;/i11&gt;&lt;e12&gt;Smith&lt;/e12&gt;&lt;i13&gt;Griffith&lt;/i13&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;Will&lt;/i21&gt;&lt;e22&gt;Tim&lt;/e22&gt;&lt;i23&gt;Shields&lt;/i23&gt;
  &lt;/name2&gt;
 &lt;/doc&gt;

  Document 2:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;Will&lt;e12&gt;Frank&lt;/e12&gt;Shields&lt;/i11&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;John&lt;e22&gt;Tim&lt;/e22&gt;Griffith&lt;/i21&gt;
  &lt;/name2&gt;
&lt;/doc&gt;
:)

 (: Now suppose we have two fields aname1 and aname2 defined on the database.
    The field aname1 includes element "name1" and excludes "e12".
    The field aname2 includes element "name2" and excludes "e22".
    Both the fields have field range indexes configures with positions ON.
 :)

  cts:field-value-co-occurrences("aname1","aname2")
=&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Griffith&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Shields&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Griffith&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;


</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">

******
Suppose we insert these two documents in the database.

  Document 1:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;John&lt;/i11&gt;&lt;e12&gt;Smith&lt;/e12&gt;&lt;i13&gt;Griffith&lt;/i13&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;Will&lt;/i21&gt;&lt;e22&gt;Tim&lt;/e22&gt;&lt;i23&gt;Shields&lt;/i23&gt;
  &lt;/name2&gt;
 &lt;/doc&gt;

  Document 2:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;Will&lt;e12&gt;Frank&lt;/e12&gt;Shields&lt;/i11&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;John&lt;e22&gt;Tim&lt;/e22&gt;Griffith&lt;/i21&gt;
  &lt;/name2&gt;
&lt;/doc&gt;
*******

// Now suppose we have two fields aname1 and aname2 defined on the database.
// The field aname1 includes element "name1" and excludes "e12".
// The field aname2 includes element "name2" and excludes "e22".
// Both the fields have field range indexes configures with positions ON.

cts.fieldValueCoOccurrences("aname1","aname2");
=&gt;
["John Griffith", "Will Shields"]
["Will Shields", "John Griffith"]


</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: Here is another example that finds co-occurence between field value
     and an element-value using cts:element-value-co-occurences() API. :)

  (: Suppose we have the following document in the database. :)
&lt;doc&gt;
 &lt;person&gt;
  &lt;name&gt;
    &lt;first-name&gt;Will&lt;/first-name&gt;
    &lt;middle-name&gt;Frank&lt;/middle-name&gt;
    &lt;last-name&gt;Shields&lt;/last-name&gt;
  &lt;/name&gt;
  &lt;address&gt;
    &lt;ZIP&gt;92341&lt;/ZIP&gt;
  &lt;/address&gt;
  &lt;phoneNumber&gt;650-472-4444&lt;/phoneNumber&gt;
 &lt;/person&gt;
 &lt;person&gt;
  &lt;name&gt;
    &lt;first-name&gt;John&lt;/first-name&gt;
    &lt;middle-name&gt;Tim&lt;/middle-name&gt;
    &lt;last-name&gt;Hearst&lt;/last-name&gt;
  &lt;/name&gt;
  &lt;address&gt;
    &lt;ZIP&gt;96345&lt;/ZIP&gt;
  &lt;/address&gt;
  &lt;phoneNumber&gt;750-947-5555&lt;/phoneNumber&gt;
 &lt;/person&gt;
&lt;/doc&gt;
  (: This database has element range indexes defined on elements
     ZIP and phoneNumber. Positions are set true on the range indexes.

     There is a field, named "aname" defined on this database
     which excludes element middle-name.

     A string range index is configured on the field "aname".
     Position is set true on the database.

     In the following query we are using lexicons on field values of
     "aname" and element value "ZIP" to determine value co-occurences.
     However, notice the field is being treated as if it were an
     element with a MarkLogic predefined namespace
     "http://marklogic.com/fields".
  :)
declare namespace my="http://marklogic.com/fields";
cts:element-value-co-occurrences(xs:QName("ZIP"),xs:QName("my:aname"))
  =&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;68645&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Jill Tom Lawless&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;68645&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Nancy Smith Finkman&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;92341&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Tim Hearst&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;92341&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Frank Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;93452&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Jill Tom Lawless&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;93452&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Nancy Smith Finkman&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;96345&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Tim Hearst&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;96345&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Frank Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified field value lexicon(s).
  Value lexicons are implemented using range indexes; consequently this
  function requires a field range index for each element specified
  in the function.  If there is not a range index configured for each
  of the specified fields, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket.
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:field-value-ranges("myField", ("f", "m"))</pre>
  <pre class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.fieldValueRanges("myField", ["f", "m"])</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
  <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, an ObjectNode is returned.
  Each ObjectNode has a <code>minimum</code> property and a <code>maximum</code>
  property.  If a bucket is bounded, its ObjectNode will also have a
  <code>lowerBound</code> property if it is bounded from below, and
  a <code>upperBound</code> property if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds.
    The types must match the lexicon type.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges
        will have no minimum or maximum value.  Only empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then ranges with all included values may be returned. If a
  <code>$query</code> parameter is not present, then "sample=<em>N</em>"
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered results list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have a string field range index on
   field aname that includes name and excludes mname. :)

let $content1 := &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
let $content2 := &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
let $content3 := &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;
let $content4 := &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
let $content5 := &lt;name&gt;&lt;fname&gt;Anthony&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Flemings&lt;/lname&gt;&lt;/name&gt;
let $content6 := &lt;name&gt;&lt;fname&gt;Charles&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Winter&lt;/lname&gt;&lt;/name&gt;
let $content7 := &lt;name&gt;&lt;fname&gt;Nancy&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Schmidt&lt;/lname&gt;&lt;/name&gt;
let $content8 := &lt;name&gt;&lt;fname&gt;Robert&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Hanson&lt;/lname&gt;&lt;/name&gt;
return (
xdmp:document-insert("/aname1.xml",$content1),
xdmp:document-insert("/aname2.xml",$content2),
xdmp:document-insert("/aname3.xml",$content3),
xdmp:document-insert("/aname4.xml",$content4),
xdmp:document-insert("/aname5.xml",$content5),
xdmp:document-insert("/aname6.xml",$content6),
xdmp:document-insert("/aname7.xml",$content7),
xdmp:document-insert("/aname8.xml",$content8)
)

(: The following is based on the above setup :)
cts:field-value-ranges("aname",("A","J","O"));
=&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;Anthony Flemings&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Charles Winter&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;A&lt;/cts:lower-bound&gt;
&lt;cts:upper-bound xsi:type="xs:string"&gt;J&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;James Tod&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Nancy Schmidt&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;J&lt;/cts:lower-bound&gt;
&lt;cts:upper-bound xsi:type="xs:string"&gt;O&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;Ooi Fu&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Robert Hanson&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;O&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;

(: And you can call cts:frequency on each result item :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Run the following to load data for this example.
// Make sure you have a string field range index on
// field aname that includes name and excludes mname.

declareUpdate();
const content1 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;'));
const content2 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;'));
const content3 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;'));
const content4 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;'));
const content5 = fn.head(xdmp.unquote(
'&lt;name&gt;&lt;fname&gt;Anthony&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Flemings&lt;/lname&gt;&lt;/name&gt;')
);
const content6 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Charles&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Winter&lt;/lname&gt;&lt;/name&gt;')
  );
const content7 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Nancy&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Schmidt&lt;/lname&gt;&lt;/name&gt;'));
const content8 = fn.head(xdmp.unquote(
  '&lt;name&gt;&lt;fname&gt;Robert&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Hanson&lt;/lname&gt;&lt;/name&gt;')
  );
xdmp.documentInsert("/aname1.xml", content1);
xdmp.documentInsert("/aname2.xml", content2);
xdmp.documentInsert("/aname3.xml", content3);
xdmp.documentInsert("/aname4.xml", content4);
xdmp.documentInsert("/aname5.xml", content5);
xdmp.documentInsert("/aname6.xml", content6);
xdmp.documentInsert("/aname7.xml", content7);
xdmp.documentInsert("/aname8.xml", content8);

******
// The following is based on the above setup
cts.fieldValueRanges("aname", ["A","J","O"]);
=&gt;
{"minimum":"Anthony Flemings", "maximum":"Charles Winter",
	"lowerBound":"A", "upperBound":"J"}
{"minimum":"James Tod", "maximum":"Nancy Schmidt",
	"lowerBound":"J", "upperBound":"O"}
{"minimum":"Ooi Fu", "maximum":"Robert Hanson",
	"lowerBound":"O"}

// And you can call cts.frequency on each result item.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="frequency" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns an integer representing the number of times in which a particular
  value occurs in a value lexicon lookup (for example,
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-values</code>).  When using the
  <code xmlns="http://www.w3.org/1999/xhtml">fragment-frequency</code> lexicon option, <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>
  returns the number of fragments in which the lexicon value occurs. When
  using the <code xmlns="http://www.w3.org/1999/xhtml">item-frequency</code> lexicon option,
  <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> returns the total number of times
  in which the lexicon value occurs in each item.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="value" type="item()">
    A value from a value lexicon lookup.  The value should be one returned
   from the <a href="#cts:element-values" xmlns="http://www.w3.org/1999/xhtml"><code>cts:element-values</code></a>,
    <a href="#cts:element-attribute-values" xmlns="http://www.w3.org/1999/xhtml">
    <code>cts:element-attribute-values</code></a>, or the corresponding
    <code xmlns="http://www.w3.org/1999/xhtml">value-match</code> lexicon APIs.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">You must have a Range index configured to use the value lexicon APIs
 (<code>cts:element-values</code>, <code>cts:element-value-match</code>,
 <code>cts:element-attribute-values</code>, or
 <code>cts:element-attribute-value-match</code>).
 </p>
 <p xmlns="http://www.w3.org/1999/xhtml">If the value specified is not from a value lexicon lookup,
 <code>cts:frequency</code> returns a frequency of 0.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">The frequency returned from <code>cts:frequency</code> is fragment-based
 by default (using the default <code>fragment-frequency</code> option in the
 lexicon API).  If there are multiple occurences of the value in any given
 fragment, the frequency is still one per fragment when using
 <code>fragment-frequency</code>. Therefore, if the value
 returned is 13, it means that the value occurs in 13 fragments.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">If you want the total frequency instead of the fragment-based frequency
 (that is, the total number of occurences of the value in the items specified
 in the <code>cts:query</code> option of the lexicon API),
 you must specify the <code>item-frequency</code> option to the lexicon
 API value input to <code>cts:frequency</code>. For example, the second
 example below specifies an <code>item-frequency</code> and a
 <code>cts:document-query</code> in the lexicon
 API, so the item frequency is how many times each speaker speaks in the
 play (because the constraining query is a document query of hamlet.xml, which
 contains the whole play).</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),"",(),
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt;
  &lt;NUMBER-OF-SPEECHES&gt;{cts:frequency($speaker)}&lt;/NUMBER-OF-SPEECHES&gt;
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. If the
   play is fragmented at the SCENE level, then
   it returns the number of scenes in which each
   speaker speaks. 
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const arr = new Array();
const x = cts.elementValues(xs.QName("SPEAKER"),"", null,
  cts.documentQuery("/shakespeare/plays/hamlet.xml"));
for (const speaker of x) {
  arr.push([speaker, cts.frequency(speaker)]);
};
const obj = new Object();
obj.speakerSpeaks = arr;
obj;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. If the
   play is fragmented at the SCENE level, then
   it returns the number of scenes in which each
   speaker speaks. 
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),
  "", "item-frequency",
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt;
  &lt;NUMBER-OF-SPEECHES&gt;
    {cts:frequency($speaker)}
  &lt;/NUMBER-OF-SPEECHES&gt;
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. Returns
   the total times they speak, regardless
   of fragmentation. 
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="sum" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon" class="xquery">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">
  [DEPRECATED: use <a href="#cts:sum-aggregate"><code>cts:sum-aggregate</code></a>]
  </p>
  Returns a frequency-weighted sum of a sequence.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:sum</code> except each item in the
  sequence is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> before summing.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="xs:anyAtomicType*">
   The sequence of values to be summed.  The values should be the result of
   a lexicon lookup.
  </apidoc:param>
      <apidoc:param name="zero" type="xs:anyAtomicType?" optional="true">
   The value to return as zero if the input sequence is the empty sequence.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">The <code>cts:frequency</code> of the result is the sum of the
 frequencies of the sequence.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:sum(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:sum(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
385
55


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="count" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon" class="xquery">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">
  [DEPRECATED: use <a href="#cts:count-aggregate"><code>cts:count-aggregate</code></a>]
  </p>
  Returns a frequency-weighted count of a sequence.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:count</code> except the count
  of each item is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="item()*">
  The sequence of items to count.  The items should be the result of
   a lexicon lookup.
   <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">If you pass in a single value,
  it is treated as a Sequence with that single item; therefore, if you
  pass in an array, the function will return the array. If you mean to check
  the values of each item in the array, then you can call
  <a href="#xdmp.arrayValues">xdmp.arrayValues</a> on the array. </span>
  </apidoc:param>
      <apidoc:param name="maximum" type="xs:double" optional="true">
  The maximum value of the count to return. MarkLogic Server will stop
  counting when the $maximum value is reached and return
  the $maximum value.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:count(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:count(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
55
10


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="avg" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Math Lexicon" class="xquery">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">
  [DEPRECATED: use <a href="#cts:avg-aggregate"><code>cts:avg-aggregate</code></a>]
  </p>
  Returns a frequency-weighted average of a sequence.
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:avg</code> except each item in the
  sequence is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> before summing.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="xs:anyAtomicType*">
   The sequence of values to be averaged.  The values should be the result of
   a lexicon lookup.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:avg(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:avg(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
7
5.5


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the URI lexicon.
  This function requires the uri-lexicon database configuration
  parameter to be enabled. If the uri-lexicon database-configuration
  parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting value.  Return only this value and following values.  If
    the empty string, return all values.  If the parameter is not in
    the lexicon, then it returns the values beginning with the next
    value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        URIs from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included URIs.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then URIs from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:uris("http://foo.com/")
  =&gt; ("http://foo.com/", "http://foo.com/bar.html", ...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.uris("http://foo.com/")
  =&gt; ("http://foo.com/", "http://foo.com/bar.html", ...)
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:uris("", (), cts:word-query("word"))
  =&gt; all the URIs of documents that have the word "word" in them
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.uris("", null, cts.wordQuery("word"))
  // returns all the URIs of documents that have the word "word" in them
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="uri-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the URI lexicon
   that match the specified wildcard pattern.
   This function requires the uri-lexicon database configuration
   parameter to be enabled. If the uri-lexicon database-configuration
   parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        URIs from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included URIs.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then URIs from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.uri-match("http://foo.com*.html")
  =&gt; ("http://foo.com/bar.html", "http://foo.com/baz/bork.html", ...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.uriMatch("http://foo.com*.html")
  =&gt; ("http://foo.com/bar.html", "http://foo.com/baz/bork.html", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collections" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the collection lexicon.
  This function requires the collection-lexicon database configuration
  parameter to be enabled. If the collection-lexicon database-configuration
  parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting value.  Return only this value and following values.
    If the parameter is not in the lexicon, then it returns the values
    beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        URIs from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included URIs.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:collections("aardvark")
  =&gt; ("aardvark", "aardvarks", ...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.collections("aardvark")
  =&gt; ("aardvark", "aardvarks", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the collection lexicon
   that match the specified wildcard pattern.
   This function requires the collection-lexicon database configuration
   parameter to be enabled. If the collection lexicon database configuration
   parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        URIs from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included URIs.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then URIs from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:collection-match("collection*")
  =&gt; ("collection1", "collection2", ...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.collectionMatch("collection*");
  =&gt; ("collection1", "collection2", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified element-attribute word lexicon(s).
  This function requires an element-attribute word lexicon for each of the
  element/attribute pairs specified in the function.  If there is not an
  element/attribute word lexicon configured for any of the specified
  element/attribute pairs, then an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When run without a $query parameter and as a user with the admin role,
  the word lexicon functions return results that might include words from
  deleted fragments. However, when run as a user with the admin role and
  without a $query parameter, the word lexicon functions run faster (because
  they do not need to look up where each word comes from). It is therefore
  faster to run word lexicon functions as an admin user without passing a
  $query parameter.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-words(xs:QName("animal"),
                              xs:QName("name"),
                              "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementAttributeWords(xs.QName("animal"),
                              xs.QName("name"),
                              "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified element-attribute word lexicon(s) that
  match a wildcard pattern.   This function requires an element-attribute
  word lexicon for each of the element/attribute pairs specified in the
  function.  If there is not an element-attribute word lexicon
  configured for any of the specified element/attribute pairs, then
  an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-match(xs:QName("animals"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementWordMatch(xs.QName("animals"),"aardvark*");
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns values from the specified element-attribute value lexicon(s).
  Element-attribute value lexicons are implemented using indexes;
  consequently this function requires an attribute range index
  of for each of the element/attribute pairs specified in the function.
  If there is not a range index configured for each of the specified
  element/attribute pairs, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-values(xs:QName("animal"),
                               xs:QName("name"),
                               "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementAttributeValues(xs.QName("animal"),
                               xs.QName("name"),
                               "aardvark");
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
   Returns values from the specified element-attribute value lexicon(s)
   that match the specified pattern.  Element-attribute value lexicons are
   implemented using range indexes; consequently this function requires an
   attribute range index for each of the element/attribute pairs specified
   in the function.  If there is not a range index configured for each of the
   specified element/attribute pairs, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:anyAtomicType* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-value-match(xs:QName("animals"),
                     xs:QName("name"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementAttributeValueMatch(xs.QName("animals"),
                     xs.QName("name"),"aardvark*");
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified element-attribute value lexicon(s).
  Element-attribute value lexicons are implemented using indexes;
  consequently this function requires an attribute range index
  of for each of the element/attribute pairs specified in the function.
  If there is not a range index configured for each of the specified
  element/attribute pairs, then an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket.
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))</pre>
  <pre class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.elementValueRanges(xs.QName("myElement"), ["f", "m"])</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
  <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, an ObjectNode is returned.
  Each ObjectNode has a <code>minimum</code> property and a <code>maximum</code>
  property.  If a bucket is bounded, its ObjectNode will also have a
  <code>lowerBound</code> property if it is bounded from below, and
  a <code>upperBound</code> property if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds.
    The types must match the lexicon type.
    The values must be in strictly ascending order.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges
        will have no minimum or maximum value.  Only empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (int, unsignedInt, long, unsignedLong, float, double, decimal,
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option also affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning
        the first item from the indexes, and most of the work
        sequentiallya while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"coordinate-system=<em>name</em>"</dt>
        <dd>Use the lexicon that is configured with the specified coordinate
         system. Allowed values: "wgs84", "wgs84/double", "raw",
         "raw/double". Only applicable if the lexicon value type is
         <code>point</code> or <code>long-lat-point</code>.</dd>
        <dt>"precision=<em>value</em>"</dt>
        <dd>Use the lexicon that is configured with the specified precision.
         Allowed values: <code>float</code> and <code>double</code>.
         Only applicable if the lexicon value type is <code>point</code> or
         <code>long-lat-point</code>. This value takes precedence over the
         precision implicit in the coordinate system name.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties"
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then ranges with all included values may be returned. If a
  <code>$query</code> parameter is not present, then "sample=<em>N</em>"
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered results list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have an int element attribute
   range index on my-node/@number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;my-node number={$x}/&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-attribute-value-ranges(xs:QName("my-node"),
  xs:QName("number"), (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;

  
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Run the following to load data for this example.
// Make sure you have an int element attribute
// range index on my-node/@number.

declareUpdate();
for (x=1;x&lt;10;x++) {
xdmp.documentInsert("/doc" + x + ".xml",
 fn.head(xdmp.unquote('&lt;root&gt;&lt;my-node number="' + x + '"/&gt;&lt;/root&gt;'))) ;
};

******
// The following is based on the above setup
cts.elementAttributeValueRanges(xs.QName("my-node"),
  xs.QName("number"), [5, 10, 15, 20], "empties");
=&gt;
{"minimum":1, "maximum":4, "upperBound":5}
{"minimum":5, "maximum":9, "lowerBound":5, "upperBound":10}
{"lowerBound":10, "upperBound":15}
{"lowerBound":15, "upperBound":20}
{"lowerBound":20}

// you can also call cts.frequency on each item in the result
  
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified field word lexicon.  This function
  requires an field lexicon for each of the field specified in the
  function.  If there is not an field word lexicon configured for any
  of the specified fields, an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with field-word-query are included.
  That is, only words present in immediate text node children of the
  specified field as well as any text node children of child fields
  defined in the Admin Interface as field-word-query-throughs or
  phrase-throughs. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When run without a $query parameter and as a user with the admin role,
  the word lexicon functions return results that might include words from
  deleted fragments. However, when run as a user with the admin role and
  without a $query parameter, the word lexicon functions run faster (because
  they do not need to look up where each word comes from). It is therefore
  faster to run word lexicon functions as an admin user without passing a
  $query parameter. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function, 
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:field-words("animal","aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.fieldWords("animal","aardvark");
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Returns words from the specified field word lexicon(s) that match
  a wildcard pattern.   This function requires an field word lexicon
  configured for each of the specified fields in the function.  If there
  is not an field word lexicon configured for any of the specified
  fields, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words. You should not
        use this option with the "skip" option. Use "truncate" instead.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Words from skipped fragments are not included.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query,
        return an XDMP-TOOMANYPOSITIONS error,
        instead of accepting the document as a match.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
        <dd>Return results as <span class="xquery">a single map:map
         value instead of as an xs:string* sequence</span>
         <span class="javascript">a JavaScript Object instead of as
         a Sequence</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><a href="cts:search#unfiltered">
    "unfiltered" <code>cts:search</code></a></span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml"><a href="cts.search#unfiltered">
    "unfiltered" <code>cts.search</code></a></span>
    operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specified in the options parameter,
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specified in the options parameter,
  then words from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To incrementally fetch a subset of the values returned by this function,
  use <a class="xquery" href="#fn:subsequence">fn:subsequence</a>
  <a class="javascript" href="#fn.subsequence">fn.subsequence</a>
  on the output, rather than 
  the "skip" option. The "skip" option is based on fragments matching the 
  <code>query</code> parameter (if present), not on values. A fragment 
  matched by query might contain multiple values or no values. 
  The number of fragments skipped does not correspond to the number of 
  values. Also, the skip is applied to the relevance ordered query matches, 
  not to the ordered values list. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When using the "skip" option, use the "truncate" option rather than 
  the "limit" option to control the number of matching fragments from which 
  to draw values.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive"
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive"
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with field-word-query are included.
  That is, only words present in immediate text node children of the
  specified field as well as any text node children of child fields
  defined in the Admin Interface as field-word-query-throughs or
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:field-word-match("animal","aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.fieldWordMatch("animal","aardvark*");
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary class="xquery">
  Construct a query that matches serialized cts queries, based on a
  set of model input nodes. A serialized query matches if it would
  match the model nodes. Use with a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> or
  <code xmlns="http://www.w3.org/1999/xhtml">cts:contains</code> over serialized <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> nodes.
</apidoc:summary>
    <apidoc:summary class="javascript">
  Construct a query that matches serialized cts queries, based on a
  set of model input nodes. A serialized query matches if it would
  match the model nodes. Use with a <code xmlns="http://www.w3.org/1999/xhtml">cts.search</code> or
  <code xmlns="http://www.w3.org/1999/xhtml">cts.contains</code> over serialized <code xmlns="http://www.w3.org/1999/xhtml">cts.query</code> nodes.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*">
    Model nodes that must be matchable by queries matched by this
    reverse query. See the Usage Notes for more details.
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query. This parameter has no effect because a reverse
    query does not contribute to score. That is, the score is always 0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reverse-query</apidoc:return>
    <apidoc:usage>
   <p xmlns="http://www.w3.org/1999/xhtml">A reverse query matches serialized <code>cts:query</code> nodes.
    Construct a reverse query from nodes that model what that
    serialized query should match, rather than passing in the target query.
    For example, to match queries for the word "hello", specify a node
    containing the word "hello" as the <code>nodes</code> parameter.
    See the example, below. Reverse queries are useful for creating
    alerting applications.</p>
   <p class="xquery" xmlns="http://www.w3.org/1999/xhtml">When evaluating a <code>cts:reverse-query</code> on a
    set of nodes, the <code>cts:similar-query</code> or
    <code>cts:registered-query</code> components of any stored query will
    match all nodes.</p>
   <p class="javascript" xmlns="http://www.w3.org/1999/xhtml">When evaluating a <code>cts.reverseQuery</code> on a
    set of nodes, the <code>cts.similarQuery</code> or
    <code>cts.registeredQuery</code> components of any stored query will
    match all nodes.</p>
   <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">
   <p>You can create a node or document containing a serialized
    <code>cts:query</code> in XQuery by wrapping a <code>cts:query</code>
    constructor in an XML node. For example, the following snippet creates
    an XML element (foo) that contains a serialized word query:</p>
    <pre xml:space="preserve">
    &lt;foo&gt;{cts:word-query("my search")}&lt;/foo&gt;/element()
    </pre>
   </span><span class="javascript" xmlns="http://www.w3.org/1999/xhtml">
   <p>You can serialize a <code>cts.query</code> to an in-memory JSON string
    using <code>xdmp.toJsonString</code>. You can persist a serialized
    <code>cts.query</code> as JSON document by converting the query to a
    JavaScript object and passing the object to <code>xdmp.documentInsert</code>.
    For example:</p>
   <pre xml:space="preserve">
    // Convert to a JSON string
    xdmp.toJsonString(cts.wordQuery('hello'))

    // Convert to JavaScript object and save in the database. The JS object
    // is implicitly converted into a JSON object node by the call.
    xdmp.documentInsert('/my/query.json', cts.wordQuery('hello').toObject());
   </pre>
   </span>
   <p xmlns="http://www.w3.org/1999/xhtml">A reverse query can match both the XML and JSON representations of
    a serialized query.</p>
</apidoc:usage>
    <apidoc:see-also-list>
  <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/alerts.xml%2386523'>Creating Alerting Applications</a> in the <em>Search Developer's Guide</em>
  </apidoc:see-also>
</apidoc:see-also-list>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $content := &lt;query&gt;{cts:word-query("hello")}&lt;/query&gt;
let $model-node := &lt;bar&gt;hello&lt;/bar&gt;
return
cts:contains($content, cts:reverse-query($model-node))
(:
   Returns true because the content contains a cts:word-query
   for "hello", which would match the model node. Here, the content is
   an in-memory node, but it could also be a document (or node) in the
   database.
:)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const query = cts.wordQuery('hello');
const modelNode = xdmp.toJSON({bar:"hello"});
cts.contains(
  xdmp.toJSON(query.toObject()).root,
  cts.reverseQuery(modelNode)
);

// Returns true because the content contains a cts:word-query
// for "hello", which would match the model node. Here, the content is
// an in-memory node, but it could also be a document (or node) in the
// database.

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the nodes used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:reverse-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := &lt;query&gt;{cts:word-query("hello")}&lt;/query&gt;
let $x := &lt;bar&gt;hello&lt;/bar&gt;
let $rev := cts:reverse-query($x)
return cts:reverse-query-nodes($rev)

  =&gt; &lt;bar&gt;hello&lt;/bar&gt;
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const doc = xdmp.toJSON({prop: "hello"});
const query = cts.wordQuery("hello");
const obj = new Object();
obj.query = query;
const rev = cts.reverseQuery(doc);
cts.reverseQueryNodes(rev);

  =&gt; {"prop":"hello"}
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:reverse-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := &lt;query&gt;{cts:word-query("hello")}&lt;/query&gt;
let $x := &lt;bar&gt;hello&lt;/bar&gt;
let $rev := cts:reverse-query($x)
return cts:reverse-query-weight($rev)

  =&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
const doc = xdmp.toJSON({prop: "hello"});
const query = cts.wordQuery("hello");
const obj = new Object();
obj.query = query;
const rev = cts.reverseQuery(doc);
cts.reverseQueryWeight(rev);

  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-fragment-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  any document fragment.  When searching documents, document-properties, or
  document-locks, this function provides a
  convenient way to additionally constrain the search against any document
  fragment.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query">
    A query to be matched against any document fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:document-fragment-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">A document fragment query enables you to cross fragment boundaries in an 
AND query, as shown in the second example below.
</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
xdmp:document-properties(),
  cts:document-fragment-query(
    cts:word-query("hello")))

(: All properties documents whose corresponding document
 : (that is, the document at the same URI as the
 : proerties document) contain the word "hello". :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(
  cts.documentFragmentQuery(
    cts.wordQuery("hello")));

// All documents that contain the word "hello". 
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
(:
 Given a document with a fragment root of &lt;fragment&gt;
 created as follows:

xdmp:document-insert("fragmented.xml",
   &lt;root&gt;
     &lt;author&gt;bob&lt;/author&gt;
     &lt;fragment&gt;dog&lt;/fragment&gt;
     &lt;fragment&gt;cat&lt;/fragment&gt;
     &lt;fragment&gt;fish&lt;/fragment&gt;
  &lt;/root&gt;);
:)

cts:search(fn:doc("fragmented.xml"),
  cts:and-query((
    cts:document-fragment-query("bob"),
    "dog"
  ))
)

(: returns the fragmented.xml document :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Assume the database contains the following document with a fragment 
// root of &lt;fragment&gt; and URI "fragmented.xml":
//
//   &lt;root&gt;
//     &lt;author&gt;bob&lt;/author&gt;
//     &lt;fragment&gt;dog&lt;/fragment&gt;
//     &lt;fragment&gt;cat&lt;/fragment&gt;
//     &lt;fragment&gt;fish&lt;/fragment&gt;
//  &lt;/root&gt;

cts.search(
  cts.andQuery((
    cts.documentFragmentQuery('bob'),
    'dog'
  ))
);

// Matches the 'fragmented.xml' document.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-fragment-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:document-fragment-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:document-fragment-query-query(
     cts:document-fragment-query(cts:word-query("word")))
  =&gt; cts:word-query("word", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.documentFragmentQueryQuery(
     cts.documentFragmentQuery(cts.wordQuery("word")));
  =&gt; cts.wordQuery("word", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="properties-fragment-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  document-properties.  When searching documents or document-locks,
  this query type provides a convenient way to
  additionally constrain the search against document-properties fragments.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query">
    A query to be matched against the properties fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:properties-fragment-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
  fn:collection(),
  cts:properties-fragment-query(
    cts:element-range-query(
        xs:QName("prop:last-modified"),"&gt;;",
        current-dateTime() - xs:dayTimeDuration("P1D"))))

(:  All documents modified up to one day in the past.
 :  Note that this example requires a dateTime range index on:
 :  namespace: http://marklogic.com/xdmp/property
 :  local name: last-modified :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(
  cts.propertiesFragmentQuery(
    cts.elementRangeQuery(
        xs.QName('prop:last-modified'),'&gt;',
        fn.currentDateTime() - xs.dayTimeDuration('P1D'))));

//  All documents modified up to one day in the past.
//  Note that this example requires a dateTime range index on:
//  namespace: http://marklogic.com/xdmp/property
//  local name: last-modified
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="properties-fragment-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:properties-fragment-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:properties-fragment-query-query(
    cts:properties-fragment-query(cts:word-query("word")))
  =&gt; cts:word-query("word", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.propertiesFragmentQueryQuery(
    cts.propertiesFragmentQuery(cts.wordQuery("word")));
  =&gt; cts.wordQuery("word", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="locks-fragment-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  document-locks.  When searching documents or document-properties,
  <code xmlns="http://www.w3.org/1999/xhtml">cts:locks-fragment-query</code> provides a convenient way to
  additionally constrain the search against document-locks fragments.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query">
    A query to be matched against the locks fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:locks-fragment-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
  fn:collection(),
    cts:locks-fragment-query(cts:word-query("12345")))

=&gt;  All documents that have locks containg the word 12345.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.search(
    cts.locksFragmentQuery(cts.wordQuery("12345")));

=&gt;  All documents that have locks containg the word 12345.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="locks-fragment-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:locks-fragment-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:locks-fragment-query-query(
    cts:locks-fragment-query(cts:word-query("word")))
  =&gt; cts:word-query("word", ("lang=en"), 1)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.locksFragmentQueryQuery(
    cts.locksFragmentQuery(cts.wordQuery("word")));
  =&gt; cts.wordQuery("word", ["lang=en"], 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Creates a query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="node()">
    A query.</apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:query(
  &lt;cts:word-query xmlns:cts="http://marklogic.com/cts"&gt;
    &lt;cts:text&gt;word&lt;/cts:text&gt;
  &lt;/cts:word-query&gt;
)

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.query(fn.head(xdmp.unquote(
  '&lt;cts:word-query xmlns:cts="http://marklogic.com/cts"&gt;'
  +'  &lt;cts:text&gt;word&lt;/cts:text&gt;'
  +'&lt;/cts:word-query&gt;')).root)
=&gt;
cts.wordQuery("word", ["lang=en"], 1)

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="distinctive-terms" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search">
    <apidoc:summary>
  Return the most "relevant" terms in the model nodes (that is, the
  terms with the highest scores).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*">
    Some model nodes.
  </apidoc:param>
      <apidoc:param name="options" type="element()?" optional="true">
    <a id="db-term-options" xmlns="http://www.w3.org/1999/xhtml"></a>
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">An XML</span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">A JavaScript</span>
    representation of the options for defining which terms to
    generate and how to evaluate them.
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">
    The options node must be in the <code>cts:distinctive-terms</code>
    namespace.</span> The following is a sample options
    <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">node:
    <pre xml:space="preserve">
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt; </pre>
    </span>
    <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">object:
    <pre xml:space="preserve">
    {
      maxTerms: 20
    }
    </pre>
    </span>

    <p xmlns="http://www.w3.org/1999/xhtml">The
    <span class="xquery">
    <code>cts:distinctive-terms</code> options (which are also valid for
    <code>cts:similar-query</code>, <code>cts:train</code>,
    and <code>cts:cluster</code>)
    </span>
    <span class="javascript">
    <code>cts.distinctiveTerms</code> options (which are also valid for
    <code>cts.similarQuery</code>, <code>cts.train</code>,
    and <code>cts.cluster</code>)
    </span>
    include:</p>
    <dl xmlns="http://www.w3.org/1999/xhtml">
    <dt><p>
    <span class="xquery">&lt;<code>max-terms</code>&gt;</span>
    <span class="javascript"><code>maxTerms</code></span>
    </p></dt>
    <dd>An integer defining the maximum number of distinctive terms to list
    in the
    <span class="xquery"><code>cts:distinctive-terms</code></span>
    <span class="javascript"><code>cts.distinctiveTerms</code></span> output.
    The default is 16.
    </dd>
    <dt><p>
    <span class="xquery">&lt;<code>min-val</code>&gt;</span>
    <span class="javascript"><code>minVal</code></span>
    </p></dt>
    <dd>A double specifying the minimum value a term can
    have and still be considered a distinctive term. The default is 0.</dd>
    <dt><p>
    <span class="xquery">&lt;<code>min-weight</code>&gt;</span>
    <span class="javascript"><code>minWeight</code></span></p></dt>
    <dd>A number specifying the minimum weighted term frequency a term can
    have and still be considered a distinctive term.  In general this value
    will be either 0 (include unweighted terms) or 1 (don't include unweighted
    terms). The default is 1.</dd>
    <dt><p>
    <span class="xquery">&lt;<code>score</code>&gt;</span>
    <span class="javascript"><code>score</code></span></p></dt>
    <dd>A string defining which scoring method to use in comparing the values
    of the terms.
    The default is <code>logtfidf</code>.  See the description of scoring
    methods in the cts:search function for more details.
    Possible values are:
      <dl>
      <dt><p><code>logtfidf</code></p></dt>
      <dd>Compute scores using the logtfidf method.</dd>
      <dt><p><code>logtf</code></p></dt>
      <dd>Compute scores using the logtf method.</dd>
      <dt><p><code>simple</code></p></dt>
      <dd>Compute scores using the simple method.</dd>
      </dl>
    </dd>
    <dt><p>
    <span class="xquery">&lt;<code>complete</code>&gt;</span>
    <span class="javascript"><code>complete</code></span></p></dt>
    <dd>A boolean value indicating whether to return terms even if there is no
    query associated with them.  The default is <code>false</code>.</dd>
    </dl>
    <dt xmlns="http://www.w3.org/1999/xhtml"><p>
    <span class="xquery">&lt;<code>use-db-config</code>&gt;</span>
    <span class="javascript"><code>useDbConfig</code></span></p></dt>
    <dd xmlns="http://www.w3.org/1999/xhtml"> The options below may be used to easily target a small set of terms.
    <span class="xquery">&lt;<code>use-db-config</code>&gt;</span>
    <span class="javascript"><code>useDbConfig</code></span>
    is a boolean value indicating whether to use the currently configured DB options
    as defaults (overriding the built-in ones below) to determine the terms to
    generate.  This is <code>true</code> by default. When this is
    <code>false</code>, any options below not explicitly specified
    take their default values as listed; they do not take the database
    settings' values. Flags explicitly specified override defaults, whether
    built-in (listed below), or from the database configuration.
    Flags not specified in a field apply to all fields, unless the field
    has its own setting, which will be the final value. In other words
    it's a hierarchy, with each more-specific level overriding previous
    less-specific levels.
    </dd>
    <p xmlns="http://www.w3.org/1999/xhtml">
    <span class="xquery">
    The options element also includes indexing options in the
    <code>http://marklogic.com/xdmp/database</code> namespace.
    </span>
    <span class="javascript">
    The options element also includes database indexing options.
    </span>
    These control which terms to use. </p>
    <p xmlns="http://www.w3.org/1999/xhtml">These database options include the following
    <span class="xquery"> (shown here with a <code>db</code> prefix to
    denote the
    <code>http://marklogic.com/xdmp/database</code> namespace</span>.
    The default given below is the default value if
    <span class="xquery"><code>use-db-config</code></span>
    <span class="javascript"><code>useDbConfig</code></span> is set
    to <code>false</code>:
    </p>
    <dl xmlns="http://www.w3.org/1999/xhtml">
    <dt><p>
    <span class="xquery">&lt;<code>db:word-searches</code>&gt;</span>
    <span class="javascript"><code>wordSearches</code></span></p></dt>
    <dd>Include terms for the words in the node. The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:stemmed-searches</code>&gt;</span>
    <span class="javascript"><code>stemmedSearches</code></span></p></dt>
    <dd>Define whether to include terms for the stems in the node, and at
    what level of stemming: <code>off</code>, <code>basic</code>,
    <code>advanced</code>, or <code>decompounding</code>. The default is
    <code>basic</code>.
    </dd>
    <dt><p><span class="xquery">&lt;<code>db:word-positions</code>&gt;</span>
    <span class="javascript"><code>wordPositions</code></span></p></dt>
    <dd>Include terms for word positions in the node. The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-case-sensitive-searches</code>&gt;</span>
    <span class="javascript"><code>fastCaseSensitiveSearches</code></span></p></dt>
    <dd>Include terms for case-sensitive variations of the words in the
    node. The default is <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-diacritic-sensitive-searches</code>&gt;</span>
    <span class="javascript"><code>fastDiacriticSensitiveSearches</code></span></p></dt>
    <dd>Include terms for diacritic-sensitive variations of the words in
    the node.  The default is <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-phrase-searches</code>&gt;</span>
    <span class="javascript"><code>fastPhraseSearches</code></span></p></dt><dd>Include
    terms for two-word phrases in the node.  The default is
    <code>true</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:phrase-throughs</code>&gt;</span>
    <span class="javascript"><code>phraseThroughs</code></span></p></dt><dd>If phrase
    terms are included, include terms for phrases that cross the given
    elements.  The default is to have no such elements.<span class="xquery">
    Any number can be passed in a single string, separated by spaces.</span>
    <span class="javascript">This will accept either a single string or
    an array of strings.</span></dd>
    <dt><p><span class="xquery">&lt;<code>db:phrase-arounds</code>&gt;</span>
    <span class="javascript"><code>phraseArounds</code></span></p></dt><dd>If phrase
    terms are included, include terms for phrases that skip over the
    given elements.  The default is to have no such elements.<span class="xquery">
    Any number can be passed in a single string, separated by spaces.</span>
    <span class="javascript">This will accept either a single string or
    an array of strings.</span></dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-element-word-searches</code>&gt;</span>
    <span class="javascript"><code>fastElementWordSearches</code></span></p></dt>
    <dd>Include terms for words in particular elements.  The default is
    <code>true</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-element-phrase-searches</code>&gt;</span>
    <span class="javascript"><code>fastElementPhraseSearches</code></span></p></dt>
    <dd>Include terms for phrases in particular elements. The default is
    <code>true</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:element-word-positions</code>&gt;</span>
    <span class="javascript"><code>elementWordPositions</code></span></p></dt>
    <dd>Include terms for element word positions in the node. The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:element-word-query-throughs</code>&gt;</span>
    <span class="javascript"><code>elementWordQueryThroughs</code></span></p></dt>
    <dd>Include terms for words in sub-elements of the given elements. The
    default is to have no such elements. <span class="xquery">Any number can be
    passed in a single string, separated by spaces.</span>
    <span class="javascript">This will accept either a single string or
    an array of strings.</span></dd>
    <dt><p><span class="xquery">&lt;<code>db:fast-element-character-searches</code>&gt;</span>
    <span class="javascript"><code>fastElementCharacterSearches</code></span></p></dt>
    <dd>Include terms for characters in particular elements.  The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:range-element-indexes</code>&gt;</span>
    <span class="javascript"><code>rangeElementIndexes</code></span></p></dt>
    <dd>Include terms for data values in specific elements.  The default is
    to have no such indexes. <span class="javascript">Eg (a single element):
    <pre xml:space="preserve">
        "rangeElementIndexes": {
            "scalarType":"anyURI",
            "qname":"{http://example.com/somewhere}reporting",
            "collation":"http://marklogic.com/collation/codepoint",
            "rangeValuePositions": false,
            "invalidValues":"ignore"
        }
     </pre>
    </span>

</dd>
    <dt><p><span class="xquery">&lt;<code>db:range-field-indexes</code>&gt;</span>
    <span class="javascript"><code>rangeFieldIndexes</code></span></p></dt>
    <dd>Include terms for data values in specific fields.  The default is
    to have no such indexes.

<span class="javascript">Eg (a single element):
    <pre xml:space="preserve">
        "rangeFieldIndexes": {
            "scalarType":"anyURI",
            "fieldName":"{http://example.com/place}sales",
            "collation":"http://marklogic.com/collation/codepoint",
            "rangeValuePositions": false,
            "invalidValues":"ignore"
        }
     </pre>
    </span>

</dd>
    <dt><p><span class="xquery">&lt;<code>db:range-element-attribute-indexes</code>&gt;</span>
    <span class="javascript"><code>rangeElementAttributeIndexes</code></span></p></dt>
    <dd>Include terms for data values in specific attributes.  The default
    is to have no such indexes.
    <span class="javascript"> Eg (array form):
    <pre xml:space="preserve">
    "rangeElementAttributeIndexes": [
            {
                "scalarType": "decimal",
                "rangeValuePositions": true,
                "parentQname": "{http://organization.org/specs}/part",
                "qname": "{http://internet.net}/xyz"
            },
            {
                "scalarType": "anyURI",
                "collation":"http://marklogic.com/collation/",
                "rangeValuePositions": true,
                "parentQname": "{http://example.com}path",
                "qname": "{http://example.com/place}otherpath"
            },
            {
                "scalarType": "int",
                "rangeValuePositions": true,
                "parentQname": "{http://example.com}path",
                "qname": "{http://example.com/place}otherpath"
            }
        ]
     </pre>
     </span>

</dd>
    <dt><p><span class="xquery">&lt;<code>db:one-character-searches</code>&gt;</span>
    <span class="javascript"><code>oneCharacterSearches</code></span></p></dt>
    <dd>Include terms for single character.  The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:two-character-searches</code>&gt;</span>
    <span class="javascript"><code>twoCharacterSearches</code></span></p></dt>
    <dd>Include terms for two-character sequences. The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:three-character-searches</code>&gt;</span>
    <span class="javascript"><code>threeCharacterSearches</code></span></p></dt>
    <dd>Include terms three-character sequences.  The default is
    <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:trailing-wildcard-searches</code>&gt;</span>
    <span class="javascript"><code>trailingWildcardSearches</code></span></p></dt>
    <dd>Include terms for trailing wildcards. The default is
    <code>false</code>.</dd>
    <dt><p>
    <span class="xquery">&lt;<code>db:fast-element-trailing-wildcard-searches</code>&gt;</span>
    <span class="javascript"><code>fastElementTrailingWildcardSearches</code></span>
    </p></dt>
    <dd>If trailing wildcard terms are included, include terms for
    trailing wildcards by element.  The default is <code>false</code>.</dd>
    <dt><p><span class="xquery">&lt;<code>db:fields</code>&gt;</span>
    <span class="javascript"><code>fields</code></span></p></dt>
    <dd>Include terms for the defined fields.  The default is to have
    no fields.

    <span class="javascript">The JavaScript version of these options mostly
    follows the XQuery version, but there are differences. Any property
    that can take multiple items will accept either an array of that kind of item,
    or a single item, where that item might be a string or an object containing
    sub-options. Also, where in XQuery you specify namespace and localname separately
    for URIs, in JavaScript they are combined into a qname.<br/>

    The "fields" property takes an array with the following properties:
    <dl>
      <dt><code>fieldName</code></dt>
      <dd>The name of a field to look through.</dd>
      <dt><code>includeRoot</code></dt>
      <dd>A boolean, <code>true</code> by default. Whether to look
      through the field everywhere it appears in the XML document. Mutually
      exclusive with specifying <code>fieldPaths</code>.</dd>
      <dt><code>fieldPaths</code></dt>
      <dd>Lets you be selective about where the given field must appear
      in order to be searched through. Contains a path and how much weight
      to give items found in <code>fieldName</code>s at this path. Eg:
    <pre xml:space="preserve">
    "fieldPaths": [
      {
        "path":"/root/child/grandchild",
        "weight":3.4
      },
      {
        "path":"/other/location",
        "weight":2.6
      }
    ]
    </pre>
    Mutually exclusive with setting <code>includeRoot</code>.
      </dd>

      <dl>
      <dt>The following are same as the general options above, except
      restricted to this field. All are <code>false</code> by default:</dt>
      <dd><code>stemmedSearches</code></dd>
      <dd><code>wordSearches</code></dd>
      <dd><code>fastCaseSensitiveSearches</code></dd>
      <dd><code>fastDiacriticSensitiveSearches</code></dd>
      <dd><code>fastPhraseSearches</code></dd>
      <dd><code>trailingWildcardSearches</code></dd>
      <dd><code>trailingWildcardWordPositions</code></dd>
      <dd><code>oneCharacterSearches</code></dd>
      <dd><code>twoCharacterSearches</code></dd>
      <dd><code>threeCharacterSearches</code></dd>
      <dd><code>threeCharacterWordPositions</code></dd>
      </dl>

      <dt><code>wordLexicons</code></dt>
      <dd>A single string or array of strings containing the name(s)
      of lexicons to use.</dd>

      <dt><code>includedElements</code></dt>
      <dd>
    <pre xml:space="preserve">
      Eg:
      "includedElements": {
          "qname":"{http://organization.org}first/second",
          "attributeQname":"{http://somewhere.com}visibility",
          "attributeValue":"public",
          "weight":1.2
      }
    </pre>
      </dd>

      <dt><code>excludedElements</code></dt>
      <dd>
    <pre xml:space="preserve">
    Eg:
    "excludedElements": [
        {
            "qname":"{http://organization.org}first/second",
            "attributeQname":"{http://internet.net}importance",
            "attributeValue":"notimportant"
        },
        {
            "qname":"{http://company.com}first/second",
            "attributeQname":"{http://somewhere.com}visibility",
            "attributeValue":"internal"
        }
    ]
    </pre>
      </dd>
    </dl>
    </span>
    </dd>
  </dl>
</apidoc:param>
    </apidoc:params>
    <apidoc:return class="xquery">element(cts:class)</apidoc:return>
    <apidoc:return class="javascript">Object</apidoc:return>
    <apidoc:usage>
<a id="output_format" xmlns="http://www.w3.org/1999/xhtml"><b>Output Format</b></a>
The output of the function is a <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">
<code>cts:class</code> element</span> <span class="javascript" xmlns="http://www.w3.org/1999/xhtml">class object</span> containing
<span class="xquery" xmlns="http://www.w3.org/1999/xhtml">a sequence</span>
<span class="javascript" xmlns="http://www.w3.org/1999/xhtml">an array</span> of
<span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>cts:term</code> elements.</span>
<span class="javascript" xmlns="http://www.w3.org/1999/xhtml">term objects.</span> (This is the same as the weights form of a class for
the SVM classifier; see <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:train</span><span class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.train</span>.)  Each <span class="xquery" xmlns="http://www.w3.org/1999/xhtml"><code>cts:term</code> element</span>
<span class="javascript" xmlns="http://www.w3.org/1999/xhtml">term object</span> identifies the term ID as well
as a score, confidence, and fitness measure for the term, in addition
to a <span class="xquery" xmlns="http://www.w3.org/1999/xhtml">cts:query</span>
<span class="javascript" xmlns="http://www.w3.org/1999/xhtml">cts.query</span> that corresponds to
the term.  The correspondence of terms to queries is not precise:
queries typically make use of multiple terms, and not all terms
correspond to a query. However, a search using the query given for a
term will match the model node that gave rise to it.
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms( fn:doc("book.xml"),
   &lt;options xmlns="cts:distinctive-terms"&gt;&lt;max-terms&gt;3&lt;/max-terms&gt;&lt;/options&gt; )
== &gt;
&lt;cts:class name="dterms book.xml" offset="0" xmlns:cts="http://marklogic.com/cts"&gt;
  &lt;cts:term id="1230725848944963443" val="482" score="372" confidence="0.686441" fitness="0.781011"&gt;
    &lt;cts:element-word-query&gt;
      &lt;cts:element&gt;title&lt;/cts:element&gt;
      &lt;cts:text xml:lang="en"&gt;the&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:element-word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="2859044029148442125" val="435" score="662" confidence="0.922555" fitness="0.971371"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;text&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="17835615465481541363" val="221" score="237" confidence="0.65647" fitness="0.781263"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;of&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
&lt;/cts:class&gt;
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms(//title,
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)

=&gt; a cts:class element containing the 16 most distinctive query terms
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms(&lt;foo&gt;hello there you&lt;/foo&gt;,
    &lt;options xmlns="cts:distinctive-terms"
             xmlns:db="http://marklogic.com/xdmp/database"&gt;
            &lt;db:word-positions&gt;true&lt;/db:word-positions&gt;
    &lt;/options&gt;)

=&gt; a cts:class element containing the 16 most distinctive query terms
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.distinctiveTerms( fn.doc("/a.xml").toArray(),
{
  score: "logtfidf"
});
=&gt; a cts:class element
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.distinctiveTerms(
    [fn.doc('/shakespeare/plays/hamlet.xml')],
    {
        "maxTerms":2,
        "minVal": 6,
        "minWeight": 5,
        "score":"logtfidf",
        "useDbConfig":false,
        "complete":true,
        "elementWordPositions":true,
        "fastCaseSensitiveSearches":true,
        "fastDiacriticSensitiveSearches":true,
        "fastElementCharacterSearches":true,
        "fastElementPhraseSearches":true,
        "fastElementTrailingWildcardSearches":true,
        "fastElementWordSearches":true,
        "fastPhraseSearches":true,
        "fastReverseSearches":true,
        "language":"en",
        "oneCharacterSearches":false,
        "stemmedSearches":"decompounding",
        "threeCharacterSearches":false,
        "trailingWildcardSearches":false,
        "twoCharacterSearches":false,
        "wordPositions":true,
        "wordSearches":true,
        // array form
        "elementWordQueryThroughs": ["{http://foobar.com/quux}x",
                                     "i","b"],
        // single-element form
        "phraseArounds": "div",
        "phraseThroughs": "{http://example.com/stoneville}xavier",

        "fields":[
            {
                "fieldName": "dave",
                // "includeRoot":true,
                "fieldPaths": {
                    "path":"/root/child/grandchild",
                    "weight":3
                },
                "stemmedSearches":true,
                "wordSearches":true,
                "fastCaseSensitiveSearches":true,
                "fastDiacriticSensitiveSearches":true,
                "fastPhraseSearches":true,
                "trailingWildcardSearches":true,
                "trailingWildcardWordPositions":true,
                "oneCharacterSearches":true,
                "twoCharacterSearches":true,
                "threeCharacterSearches":true,
                "threeCharacterWordPositions":true,
                "wordLexicons":["http://marklogic.com/collation/codepoint"],
                "includedElements": {
                    "qname":"{http://marklogic.com}fish",
                    "attributeQname":"{http://marklogic.com}bill",
                    "attributeValue":'13',
                    "weight":17
                },
                "excludedElements": [{
                    "qname":"{http://marklogic.com}pete",
                    "attributeQname":"{http://marklogic.com}sam",
                    "attributeValue":'14',
                }]
            }
        ],
         // single-element form
        "rangeElementIndexes": {
            "scalarType":"anyURI",
            "qname":"{http://example.org/xyzzy}dave",
            "collation":"http://marklogic.com/collation/codepoint",
            "rangeValuePositions": false,
            "invalidValues":"ignore"
        },
        // array form
        "rangeElementAttributeIndexes": [
            {
                "scalarType": "decimal",
                "rangeValuePositions": true,
                "parentQname": "{http://marklogic.com/quux}brad",
                "qname": "{http://marklogic.com/stoneville}marble"
            },
            {
                "scalarType": "anyURI",
                "collation":"http://marklogic.com/collation/",
                "rangeValuePositions": true,
                "parentQname": "{http://marklogic.com/quux}brad",
                "qname": "{http://marklogic.com/stoneville}marble"
            },
            {
                "scalarType": "int",
                "rangeValuePositions": true,
                "parentQname": "{http://marklogic.com/quux}brad",
                "qname": "{http://marklogic.com/stoneville}marble"
            }
        ],
        // single-element array
        "rangeFieldIndexes": [{
            "scalarType":"anyURI",
            "fieldName":"{http://example.org/xyzzy}dave",
            "collation":"http://marklogic.com/collation/codepoint",
            "rangeValuePositions": false,
            "invalidValues":"ignore"
        }],
    }
);
==&gt;
{
  "name":"dterms /shakespeare/plays/hamlet.xml",
  "offset":0,
  "terms":[
    {
      "id":"17190342381662130619",
      "val":825,
      "score":1689600,
      "confidence":1,
      "fitness":0,
      "query":{
        "wordQuery":{
          "text":[
            "hamlet"
          ],
          "options":[
            "case-insensitive",
            "diacritic-insensitive",
            "stemmed",
            "unwildcarded",
            "lang=en"
          ]
        }
      }
    },
    {
      "id":"14936670113463358967",
      "val":791,
      "score":202496,
      "confidence":1,
      "fitness":1,
      "query":{
        "elementValueQuery":{
          "element":[
            "SPEAKER"
          ],
          "text":[
            "HAMLET"
          ],
          "options":[
            "diacritic-insensitive",
            "stemmed",
            "unwildcarded",
            "lang=en"
          ]
        }
      }
    }
  ]
}
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="period" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Temporal">
    <apidoc:summary>
  Creates a period value, for use as a parameter to cts:period-range-query
  or cts:period-compare-query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:dateTime">
    The dateTime value indicating start of the period.
  </apidoc:param>
      <apidoc:param name="end" type="xs:dateTime">
    The dateTime value indicating end of the period.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:period</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:period( xs:dateTime("1990-01-01T00:00:00Z"),
            xs:dateTime("2000-01-01T00:00:00Z"))

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.period( xs.dateTime("1990-01-01T00:00:00Z"),
            xs.dateTime("2000-01-01T00:00:00Z"));

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reference-parse" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon">
    <apidoc:summary>
  Creates a reference to a value lexicon by parsing its XML or JSON
  representation, for use as a parameter to cts:value-tuples.  Since
  lexicons are implemented with range indexes, this function will
  throw an exception if the specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="reference" type="node()">
    A reference to a range index.</apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:reference-parse(
  &lt;cts:element-reference xmlns:cts="http://marklogic.com/cts"&gt;
    &lt;cts:namespace-uri&gt;http://example.com/namespace&lt;/cts:namespace-uri&gt;
    &lt;cts:localname&gt;title&lt;/cts:localname&gt;
  &lt;/cts:element-reference&gt;
)
=&gt;
cts:element-reference(
  fn:QName("http://example.com/namespace","title"),("type=unknown"))

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.referenceParse(fn.head(xdmp.unquote(
   '&lt;cts:element-reference xmlns:cts="http://marklogic.com/cts"&gt;'
  +'  &lt;cts:namespace-uri&gt;http://example.com/namespace&lt;/cts:namespace-uri&gt;'
  +'  &lt;cts:localname&gt;title&lt;/cts:localname&gt;'
  +'&lt;/cts:element-reference&gt;')).root
)
=&gt;
cts.elementReference(
  fn.QName("http://example.com/namespace","title"),["type=unknown"])

</pre></apidoc:example>
  </apidoc:function></apidoc:module>