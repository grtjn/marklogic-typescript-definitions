<apidoc:module name="entity-services" category="Entity Services" lib="es" bucket="XQuery Library Modules"
  xmlns:apidoc="http://marklogic.com/xdmp/apidoc"
  xmlns="http://www.w3.org/1999/xhtml"
>
<apidoc:summary category="Entity Services" bucket="XQuery Library Modules">
  <p>
   This module contains the Entity Services API, which enables you to 
   define logical entity-relationship models and instantiate them for use
   in your applications. For details, see the 
   <em>Entity Services Developer's Guide</em>.
  </p>
  <span class="javascript">
   <p>To use the <code>es</code> module in your JavaScript code, include a
   <code>require</code> statement similar to the following in your code: </p>
   <p><code>const es = require('/MarkLogic/entity-services/entity-services');</code></p>
  </span>
  <span class="xquery">
   <p>To use the <code>es</code> module as part of your own XQuery module, 
    include the following line in your XQuery prolog: </p>
   <p><code>import module namespace es = "http://marklogic.com/entity-services"
         at "/MarkLogic/entity-services/entity-services.xqy";</code></p>
  </span>
  <p>The library namespace prefix <code>es</code> is <em>not</em> predefined 
   in the server.  </p>
</apidoc:summary>

<apidoc:summary category="Entity Services" subcategory="Entity Services API"
                bucket="XQuery Library Modules">
  <p>
   The Entity Services API is a set of functions that enable you to 
   define logical entity-relationship models and instantiate them for
   use in your application. Use these functions to create Entity 
   Services models, generate supporting code and configuration artifacts, 
   and manage entity instances. For details, see the 
   <em>Entity Services Developer's Guide</em>.
  </p>
  <span class="javascript">
   <p>To use the <code>es</code> module in your JavaScript code, include a
   <code>require</code> statement similar to the following in your code: </p>
   <p><code>const es = require('/MarkLogic/entity-services/entity-services');</code></p>
  </span>
  <span class="xquery">
   <p>To use the <code>es</code> module as part of your own XQuery module, 
    include the following line in your XQuery prolog: </p>
   <p><code>import module namespace es = "http://marklogic.com/entity-services"
         at "/MarkLogic/entity-services/entity-services.xqy";</code></p>
  </span>
  <p>The library namespace prefix <code>es</code> is <em>not</em> predefined 
   in the server.  </p>
</apidoc:summary>
<apidoc:summary category="Entity Services" subcategory="Helper Functions"
                bucket="XQuery Library Modules">
   The following functions are helper functions used in code generated
   by the Entity Services API. You will not usually call them in any other
   context. These functions are documented to help you understand and
   customize the generated code. The best usage examples can be found in
   the code generated from your Entity Services model.
</apidoc:summary>

<apidoc:function name="model-validate" lib="es" category="Entity Services"
    subcategory="Entity Services API" bucket="XQuery Library Modules">
  <apidoc:summary>
    Validates an entity services model descriptor. If the descriptor is valid,
    returns an in-memory version of the basic model; otherwise, an exception
    is raised.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model-descriptor" type="node()">
      A document or node containing a model descriptor, or a 
      <code class="xquery">map:map</code><span class="javascript">JavaScript object</span> representing a model descriptor.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
   <p>
    Use this function as an entry point to the Entity Services API code
    generation functions. You can pass in either an in-memory JSON or XML
    model descriptor or a document that contains a JSON or XML model descriptor.
   </p><p>
    If the input descriptor is valid, then this function returns a
    validated basic model. If the model descriptor is invalid, this function 
    throws an <code>ES-MODEL-INVALID</code> exception. The error message
    includes details about the validation failure(s).
   </p><p>
    Note that a JSON model descriptor looks the same as the default
    serialization of a validated basic model, so the input and output
    will be identical if the input is a valid JSON descriptor.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2342314'>Validating a Model Descriptor</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Validate an in-memory XML model descriptor :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
es:model-validate(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>1.0.0</es:version>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <middle><es:datatype>string</es:datatype></middle>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
    </es:definitions>
  </es:model>
)

(:
==> The basic model, as a <json:object/>. You can inspect the contents using
    map:map functions, as well as passing the basic model to any Entity 
    Services functions that expect a basic model as input. The map:map
    contents are equivalent to the following JSON serialization:
    
{ "info": {
    "title": "Example",
    "version": "1.0.0"
  },
  "definitions": {
    "Name": {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": [ "first", "last" ]
    }
  }
}
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Validate a descriptor in the db and use it as a map:map :)
(: Refer to the previous example for the descriptor contents :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $model-desc := fn:doc("/descriptors/name.xml")
let $basic-model := es:model-validate($model-desc)
return map:get($basic-model, "info")

(:
==> The value of the "info" property of the basic model. The value is a
    <json:object/>. The JSON serialization appears as follows:

{"title":"Example", "version":"1.0.0"}
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Validate an in-memory model descriptor
const es = require('/MarkLogic/entity-services/entity-services');

es.modelValidate(
  { "info": {
      "title": "Example",
      "version": "1.0.0"
    },
    "definitions": {
      "Name": {
        "properties": {
          "first": { "datatype": "string" },
          "middle": { "datatype": "string" },
          "last": { "datatype": "string" }
        },
        "required": [ "first", "last" ]
      }
    }
  }
);

// Result: The basic model, as an Object. You can pass the result to any
// Entity Services functions that expect a basic model as input. The output
// basic model is the same as the input descriptor, when working with JSON.
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Validate a model descriptor stored in the database as XML
const es = require('/MarkLogic/entity-services/entity-services');

// Assume /descriptors/name.xml contains the XML equiv to the descriptor
// in the previous example.
const modelDesc = fn.doc('/descriptors/name.xml');
es.modelValidate(modelDesc).info;

// Validation returns the basic model, as an Object. The info property
// contains the following:
//
// {"title":"Example", "version":"1.0.0"}
  ]]></pre></apidoc:example>
</apidoc:function>


<apidoc:function name="model-to-xml" lib="es" category="Entity Services"
    subcategory="Entity Services API" bucket="XQuery Library Modules">
  <apidoc:summary>
    Serialize a basic model as an XML element.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element(es:model)</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Round trip an XML model descriptor to a basic model and back to XML :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
es:model-to-xml(
  es:model-validate(
    <es:model xmlns:es="http://marklogic.com/entity-services">
      <es:info>
        <es:title>Example</es:title>
        <es:version>1.0.0</es:version>
      </es:info>
      <es:definitions>
        <Name>
          <es:properties>
            <first><es:datatype>string</es:datatype></first>
            <middle><es:datatype>string</es:datatype></middle>
            <last><es:datatype>string</es:datatype></last>
          </es:properties>
          <es:required>first</es:required>
          <es:required>last</es:required>
        </Name>
      </es:definitions>
    </es:model>
))

(: ==> The same XML model descriptor as used for input to es:model-validate :)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Serialize a model stored in the database. :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $model-desc := fn:doc("/models/name.json")
return es:model-to-xml($model-desc)

(: ==> The model descriptor, serialized as XML. For an example, see the input
 :     to es:model-validate in the previous example. :)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Serialize an in-memory model descriptor to XML.
const es = require('/MarkLogic/entity-services/entity-services');

const model = es.modelValidate(
  { "info": { 
    "title": "Example", 
    "description": "ES Examples",
    "version": "1.0.0",
  },
  "definitions": {
    "Name" : {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": ["first", "last"]
    }
  }}
);
es.modelToXml(model);

/* The model descriptor, serialized as XML. You should get output similar
 * to the following:

<es:model xmlns:es="http://marklogic.com/entity-services">
  <es:info>
    <es:title>Example</es:title>
    <es:version>1.0.0</es:version>
    <es:description>ES Examples</es:description>
  </es:info>
  <es:definitions>
    <Name>
      <es:properties>
        <first><es:datatype>string</es:datatype></first>
        <middle><es:datatype>string</es:datatype></middle>
        <last><es:datatype>string</es:datatype></last>
      </es:properties>
      <es:required>first</es:required>
      <es:required>last</es:required>
    </Name>
  </es:definitions>
</es:model>
 */
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Serialize a model stored in the database.
const es = require('/MarkLogic/entity-services/entity-services');

const modelDesc = fn.doc('/models/name.json');
es.modelToXml(modelDesc);

/* Result: The model descriptor, serialized as XML. For example, assuming
 * /models/name.json contains the model from the previous example, you should
 * see output similar to the following:

<es:model xmlns:es="http://marklogic.com/entity-services">
  <es:info>
    <es:title>Example</es:title>
    <es:version>1.0.0</es:version>
    <es:description>ES Examples</es:description>
  </es:info>
  <es:definitions>
    <Name>
      <es:properties>
        <first><es:datatype>string</es:datatype></first>
        <middle><es:datatype>string</es:datatype></middle>
        <last><es:datatype>string</es:datatype></last>
      </es:properties>
      <es:required>first</es:required>
      <es:required>last</es:required>
    </Name>
  </es:definitions>
</es:model>
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="model-from-xml" lib="es" category="Entity Services"
    subcategory="Entity Services API" bucket="XQuery Library Modules">
  <apidoc:summary>
    Create a basic model from an XML model descriptor, without validating
    the input descriptor for correctness.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="node()">
      A valid XML model descriptor, as an <code>es:model</code> element or
      as a document with an <code>es:model</code> element as its root.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    This function converts the XML representation of a model descriptor
    into the in-memory representation of a basic model. This function does 
    <em>not</em> validate the XML, so it is best suited for faster conversion
    of a descriptor known to be valid. If you supply an invalid model
    descriptor, the resulting basic model will also be invalid and may result
    in problems when you try to use other Entity Services APIs on the model.
   <p>
    Use <a href="#es:model-validate" class="xquery">es:model-validate</a>
    <a href="#es.modelValidate" class="javascript">es.modelValidate</a>
    to validate the descriptor while creating a basic model
   </p><p>
    There is no equivalent to this function for JSON because the JSON
    representation of a valid model descriptor is identical to the 
    corresponding basic model.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2373385'>Model Descriptor Basics</a> in the <em>Entity Services Developer's Guide</em>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2335779'>Working With an XML Model Descriptor</a> in the <em>Entity Services Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Create a basic model from an XML model descriptor :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
es:model-from-xml(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>1.0.0</es:version>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <middle><es:datatype>string</es:datatype></middle>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
    </es:definitions>
  </es:model>
)

(: ==> A basic model, as a <json:object/>. You can inspect the contents using
       map:map functions, as well as passing the basic model to any Entity 
       Services functions that expect a basic model as input. The JSON
       serialization is equivalent to the following:
    
{ "info": {
    "title": "Example",
    "version": "1.0.0"
  },
  "definitions": {
    "Name": {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": [ "first", "last" ]
    }
  }
}

:)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Create a basic model from an XML model descriptor stored in the database,
 : and use it as a map:map. Refer to the previous example for the descriptor 
 : contents. :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $model-desc := fn:doc("/descriptors/name.xml")
let $basic-model := es:model-from-xml($model-desc)
return map:get($basic-model, "info")

(: ==> The value of the "info" property of the basic model. The value is a
       <json:object/>. The JSON serialization appears as follows:

{"title":"Example", "version":"1.0.0"}

:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Create basic model from an XML model descriptor stored in the database.
const es = require('/MarkLogic/entity-services/entity-services');

const modelDesc = fn.doc('/descriptors/name.xml');
es.modelFromXml(modelDesc);

/* Result: A basic model, as an Object. For example:
{ "info": {
    "title": "Example",
    "version": "1.0.0"
  },
  "definitions": {
    "Name": {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": [ "first", "last" ]
    }
  }
}
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="model-get-test-instances" 
    subcategory="Entity Services API" lib="es" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate entity instances of each entity type in a basic model.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element()*</apidoc:return>
  <apidoc:usage>
   <p>
    This function is useful for examining what entity instances will
    look like by default and for testing code that manipulates entities.
   </p><p>
    A single test entity instance is generated for each entity type
    defined by the input basic model. Each instance is an XML element
    that is a valid representation of the entity type, although it might
    not be exactly what an implementation your application requires.
   </p><p>
    For each property in an entity type, this function emits an element 
    containing a dummy value of the property's type. If a property is a
    reference to an entity type that can be resolved local to this model,
    then an instance of the referenced type is embedded within the referring
    instance. If a property is an array, only one element of the array item
    type is generated, but it has a <code>datatype</code> attribute that 
    indicates it is an array. See the example below.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/instances.xml%2335897'>Generating Test Entity Instances</a> in the <em>Entity Services Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

es:model-get-test-instances(
  es:model-validate(
    <es:model xmlns:es="http://marklogic.com/entity-services">
      <es:info>
        <es:title>Example</es:title>
        <es:version>1.0.0</es:version>
        <es:description>ES Examples</es:description>
      </es:info>
      <es:definitions>
        <Name>
          <es:properties>
            <first><es:datatype>string</es:datatype></first>
            <middle><es:datatype>string</es:datatype></middle>
            <last><es:datatype>string</es:datatype></last>
          </es:properties>
          <es:required>first</es:required>
          <es:required>last</es:required>
        </Name>
        <Person>
          <es:properties>
            <id><es:datatype>int</es:datatype></id>
            <name><es:ref>#/definitions/Name</es:ref></name>
            <bio><es:datatype>string</es:datatype></bio>
            <rating><es:datatype>float</es:datatype></rating>
            <phone>
              <es:datatype>array</es:datatype>
              <es:items><es:datatype>string</es:datatype></es:items>
            </phone>
          </es:properties>
          <es:primary-key>id</es:primary-key>
          <es:required>id</es:required>
          <es:required>name</es:required>
        </Person>
      </es:definitions>
    </es:model>
))

(: ==> Two test instances, one for Name and one for Person. MarkLogic
       produces output similar to the following.

<Name>
  <first>some string</first>
  <middle>some string</middle>
  <last>some string</last>
</Name>

<Person>
  <id>123</id>
  <name>
    <Name>
      <first>some string</first>
      <middle>some string</middle>
      <last>some string</last>
    </Name>
  </name>
  <bio>some string</bio>
  <rating>123</rating>
  <phone datatype="array">some string</phone>
</Person>
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const es = require('/MarkLogic/entity-services/entity-services');

es.modelGetTestInstances(
  es.modelValidate(
    { "info": {
        "title": "Example",
        "version": "1.0.0",
        "description": "ES Examples"
      },
      "definitions": {
        "Name": {
          "properties": {
            "first": { "datatype": "string" },
            "middle": { "datatype": "string" },
            "last": { "datatype": "string" }
          },
          "required": [ "first", "last" ]
        },
        "Person": {
          "properties": {
            "id": { "datatype": "int" },
            "name": { "$ref": "#/definitions/Name" },
            "bio": { "datatype": "string" },
            "rating": { "datatype": "float" },
            "phone": {
              "datatype": "array",
              "items": { "datatype": "string" }
            }
          },
          "primaryKey": "id",
          "required": [ "id", "name" ]
    } } }
));

/* ==> Two test instances, one for Name and one for Person. MarkLogic
       produces a Sequence of XML element nodes similar to the following.

<Name>
  <first>some string</first>
  <middle>some string</middle>
  <last>some string</last>
</Name>

<Person>
  <id>123</id>
  <name>
    <Name>
      <first>some string</first>
      <middle>some string</middle>
      <last>some string</last>
    </Name>
  </name>
  <bio>some string</bio>
  <rating>123</rating>
  <phone datatype="array">some string</phone>
</Person>
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="instance-converter-generate" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate an XQuery library module containing stub code for converting 
    source data to entity instances.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic entity model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>document-node()</apidoc:return>
  <apidoc:usage>
   <p>
    The output of this function is an XQuery library module containing
    boilerplate code you can customize for ingestion scenarios. You must
    insert the generated module into your modules database to use it.
   </p><p>
    The generated module contains code to get you started on a data 
    integration pipeline. The module also contains comments
    that explain the default code and provide tips for customization.
   </p><p>
    The generated code is runnable out-of-the-box, but the default
    implementation is suitable for only those entity instances that 
    already conform to the canonical representation. Any transform from 
    source systems should be implemented by customizing the generated functions.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2393910'>Creating an Instance Converter Module</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

es:instance-converter-generate(
  es:model-from-xml(
    <es:model xmlns:es="http://marklogic.com/entity-services">
      <es:info>
        <es:title>Example</es:title>
        <es:version>1.0.0</es:version>
        <es:description>ES Examples</es:description>
      </es:info>
      <es:definitions>
        <Name>
          <es:properties>
            <first><es:datatype>string</es:datatype></first>
            <middle><es:datatype>string</es:datatype></middle>
            <last><es:datatype>string</es:datatype></last>
          </es:properties>
          <es:required>first</es:required>
          <es:required>last</es:required>
        </Name>
        <Person>
          <es:properties>
            <id><es:datatype>int</es:datatype></id>
            <name><es:ref>#/definitions/Name</es:ref></name>
            <bio><es:datatype>string</es:datatype></bio>
            <rating><es:datatype>float</es:datatype></rating>
            <phone>
              <es:datatype>array</es:datatype>
              <es:items><es:datatype>string</es:datatype></es:items>
            </phone>
          </es:properties>
          <es:primary-key>id</es:primary-key>
          <es:required>id</es:required>
          <es:required>name</es:required>
        </Person>
      </es:definitions>
    </es:model>
))

(: ==> An XQuery library module containing functions such as
 :     example:extract-instance-Name, example:extract-instance-Person,
 :     example:instance-to-canonical-xml, and example:instance-to-envelope. :)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const es = require('/MarkLogic/entity-services/entity-services');

es.instanceConverterGenerate(
  es.modelValidate(
    { "info": {
        "title": "Example",
        "version": "1.0.0",
        "description": "ES Examples"
      },
      "definitions": {
        "Name": {
          "properties": {
            "first": { "datatype": "string" },
            "middle": { "datatype": "string" },
            "last": { "datatype": "string" }
          },
          "required": [ "first", "last" ]
        },
        "Person": {
          "properties": {
            "id": { "datatype": "int" },
            "name": { "$ref": "#/definitions/Name" },
            "bio": { "datatype": "string" },
            "rating": { "datatype": "float" },
            "phone": {
              "datatype": "array",
              "items": { "datatype": "string" }
            }
          },
          "primaryKey": "id",
          "required": [ "id", "name" ]
    } } }
));

// ==> An XQuery library module containing functions such as
//     example:extract-instance-Name, example:extract-instance-Person,
//     example:instance-to-canonical-xml, and example:instance-to-envelope.
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="extraction-template-generate" lib="es" 
    category="Entity Services" subcategory="Entity Services API" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate a Template Driven Extraction (TDE) template you can use to
    render entity instance data into rows for querying with the Optic API or 
    SQL.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic entity model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element(tde:template)</apidoc:return>
  <apidoc:usage>
    Use this function to generate an extraction template. The template 
    enables SQL and Optic API use with instance data. You can use the template
    as-is or customize it. You must install the template in your schemas
    database before you can use it.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2341002'>Generating a TDE Template</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/dev_guide/TDE.xml%2345703'>Template Driven Extraction (TDE)</a> in the <em>Application Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

es:extraction-template-generate(
  es:model-from-xml(
    <es:model xmlns:es="http://marklogic.com/entity-services">
      <es:info>
        <es:title>Example</es:title>
        <es:version>1.0.0</es:version>
        <es:description>ES Examples</es:description>
      </es:info>
      <es:definitions>
        <Name>
          <es:properties>
            <first><es:datatype>string</es:datatype></first>
            <middle><es:datatype>string</es:datatype></middle>
            <last><es:datatype>string</es:datatype></last>
          </es:properties>
          <es:required>first</es:required>
          <es:required>last</es:required>
        </Name>
        <Person>
          <es:properties>
            <id><es:datatype>int</es:datatype></id>
            <name><es:ref>#/definitions/Name</es:ref></name>
            <bio><es:datatype>string</es:datatype></bio>
            <rating><es:datatype>float</es:datatype></rating>
            <phone>
              <es:datatype>array</es:datatype>
              <es:items><es:datatype>string</es:datatype></es:items>
            </phone>
          </es:properties>
          <es:primary-key>id</es:primary-key>
          <es:required>id</es:required>
          <es:required>name</es:required>
        </Person>
      </es:definitions>
    </es:model>
))

(: ==> A TDE template that defines how to express your entity instances
 :     as rows. :)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const es = require('/MarkLogic/entity-services/entity-services');

es.extractionTemplateGenerate(
  es.modelValidate(
    { "info": {
        "title": "Example",
        "version": "1.0.0",
        "description": "ES Examples"
      },
      "definitions": {
        "Name": {
          "properties": {
            "first": { "datatype": "string" },
            "middle": { "datatype": "string" },
            "last": { "datatype": "string" }
          },
          "required": [ "first", "last" ]
        },
        "Person": {
          "properties": {
            "id": { "datatype": "int" },
            "name": { "$ref": "#/definitions/Name" },
            "bio": { "datatype": "string" },
            "rating": { "datatype": "float" },
            "phone": {
              "datatype": "array",
              "items": { "datatype": "string" }
            }
          },
          "primaryKey": "id",
          "required": [ "id", "name" ]
    } } }
));

// Result: A TDE template (XML) that defines how to express your entity 
// instances as rows.
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="search-options-generate" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate a set of query options that can be used to query your entity
    instances using several MarkLogic server-side and client APIs.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic entity model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element(search:options)</apidoc:return>
  <apidoc:usage>
   <p>
    The generated query options can be used to query your entity
    instances using the XQuery Search API, the Server-Side JavaScript
    JSearch API, or the REST, Java, or Node.js Client APIs. 
    For example, you can use the output of this function 
    <span class="xquery">as the second argument to the 
    <a href="#search:search">search:search</a> function or </span>
    in a combined query passed through the REST, Java, or Node.js Client APIs.
   </p><p>
    You can use the options as-is or customize them. 
    As-is, the options include several constraints and potentially 
    useful default behavior. For example, the options include a constraint 
    named <em>entity-type</em> that differentiates among the various entity
    types in the model. The options also leverage lexicon and range index 
    definitions in the basic model. The options include the following:
    <ul>
     <li>A range constraint for each property with a range index specification</li>
     <li>A word constraint for each propert with a word lexicon specification</li>
     <li>A <code>tuples</code> option encompassing all the range indexes</li>
     <li>A <code>values</code> option for URIs</li>
     <li>An <code>additional-query</code> option that limits searches
       to just entity instances.</li>
     <li>An <code>extract-document-data</code> option to return just
       entity instance data, without snippets or other metadata.</li>
    </ul>
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2376237'>Generating Query Options for Searching Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/search.xml%2345359'>Querying a Model or Entity Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/appendixa.xml%2338093'>Appendix: Query Options Reference</a> in the <em>Search Developer's Guide</em>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

es:search-options-generate( es:model-from-xml(
<es:model xmlns:es="http://marklogic.com/entity-services">
  <es:info>
    <es:title>Example</es:title>
    <es:version>1.0.0</es:version>
    <es:description>ES Examples</es:description>
  </es:info>
  <es:definitions>
    <Name>
      <es:properties>
        <first><es:datatype>string</es:datatype></first>
        <middle><es:datatype>string</es:datatype></middle>
        <last><es:datatype>string</es:datatype></last>
      </es:properties>
      <es:required>first</es:required>
      <es:required>last</es:required>
    </Name>
    <Person>
      <es:properties>
        <id><es:datatype>int</es:datatype></id>
        <name><es:ref>#/definitions/Name</es:ref></name>
        <bio><es:datatype>string</es:datatype></bio>
        <rating><es:datatype>float</es:datatype></rating>
        <phone>
          <es:datatype>array</es:datatype>
          <es:items><es:datatype>string</es:datatype></es:items>
        </phone>
        <friend>
          <es:datatype>array</es:datatype>
          <es:items><es:ref>#/definitions/Person</es:ref></es:items>
        </friend>
      </es:properties>
      <es:primary-key>id</es:primary-key>
      <es:required>id</es:required>
      <es:required>name</es:required>
      <es:range-index>rating</es:range-index>
      <es:word-lexicon>bio</es:word-lexicon>
    </Person>
  </es:definitions>
</es:model>
))

(: ==> Search options similar to the following:

<search:options xmlns:search="http://marklogic.com/appservices/search">
  <search:constraint name="entity-type">
    <search:value>
      <search:element ns="http://marklogic.com/entity-services" name="title"/>
    </search:value>
  </search:constraint>
  <search:constraint name="id">
    <search:value>
      <search:element ns="" name="id"/>
    </search:value>
  </search:constraint>
  <search:constraint name="rating">
    <search:range type="xs:float" facet="true">
      <search:path-index xmlns:es="http://marklogic.com/entity-services">
        //es:instance/Person/rating
      </search:path-index>
    </search:range>
  </search:constraint>
  <search:constraint name="bio">
    <search:word>
      <search:element ns="" name="bio"/>
    </search:word>
  </search:constraint>
  <search:tuples name="Person">
    <search:range type="xs:float" facet="true">
      <search:path-index xmlns:es="http://marklogic.com/entity-services">
        //es:instance/Person/rating
      </search:path-index>
    </search:range>
  </search:tuples>
  <!--Uncomment to return no results for a blank search, rather than the default of all results
  <search:term xmlns:search="http://marklogic.com/appservices/search">
    <search:empty apply="no-results"/>
  </search:term> 
  -->
  <search:values name="uris">
    <search:uri/>
  </search:values>
  <!--Change to 'filtered' to exclude false-positives in certain searches-->
  <search:search-option>unfiltered</search:search-option>
  <!--Modify document extraction to change results returned-->
  <search:extract-document-data selected="include">
    <search:extract-path xmlns:es="http://marklogic.com/entity-services">
      //es:instance/(Name|Person)
    </search:extract-path>
  </search:extract-document-data>
  <!--Change or remove this additional-query to broaden search beyond entity instance documents-->
  <search:additional-query>
    <cts:element-query xmlns:cts="http://marklogic.com/cts">
      <cts:element xmlns:es="http://marklogic.com/entity-services">
        es:instance
      </cts:element>
      <cts:true-query/>
    </cts:element-query>
  </search:additional-query>
  <!--To return facets, change this option to 'true' and edit constraints-->
  <search:return-facets>false</search:return-facets>
  <!--To return snippets, comment out or remove this option-->
  <search:transform-results apply="empty-snippet"/>
</search:options>
 :)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";
import module namespace search = "http://marklogic.com/appservices/search" 
    at "/MarkLogic/appservices/search/search.xqy";

(: Assume the model shown in the previous example, and that the 
 : database is configured with a range index on the rating property. :)
let $basic-model := fn:doc("/models/full.json")
let $options := es:search-options-generate($basic-model)
return search:search("entity-type:Person AND id:kc124 AND rating:5", $options)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Generate query options from a basic model.
const es = require('/MarkLogic/entity-services/entity-services');
es.searchOptionsGenerate( es.modelValidate(
{ "info": { 
    "title": "Example", 
    "description": "ES Examples",
    "version": "1.0.0",
  },
  "definitions": {
    "Name" : {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": ["first", "last"]
    },
    "Person": {
      "properties": {
        "id": { "datatype": "int" },
        "name": { 
          "$ref": "#/definitions/Name", 
        },
        "bio": { "datatype": "string" },
        "rating": { "datatype": "float" },
        "phone": {
          "datatype": "array",
          "items": { "datatype": "string"}
        },
        "friend": {
          "datatype" : "array",
          "items": { "$ref" : "#/definitions/Person" }
        }
      },
      "required": ["id", "name"],
      "primaryKey" : "id",
      "rangeIndex": ["rating"],
      "wordLexicon": ["bio"]
    }
}}
));

/* Result: XML Query options similar to the following, usable with the 
 * XQuery Search API and the REST, Node.js, and Java Client APIs.
 
<search:options xmlns:search="http://marklogic.com/appservices/search">
  <search:constraint name="entity-type">
    <search:value>
      <search:element ns="http://marklogic.com/entity-services" name="title"/>
    </search:value>
  </search:constraint>
  <search:constraint name="id">
    <search:value>
      <search:element ns="" name="id"/>
    </search:value>
  </search:constraint>
  <search:constraint name="rating">
    <search:range type="xs:float" facet="true">
      <search:path-index xmlns:es="http://marklogic.com/entity-services">
        //es:instance/Person/rating
      </search:path-index>
    </search:range>
  </search:constraint>
  <search:constraint name="bio">
    <search:word>
      <search:element ns="" name="bio"/>
    </search:word>
  </search:constraint>
  <search:tuples name="Person">
    <search:range type="xs:float" facet="true">
      <search:path-index xmlns:es="http://marklogic.com/entity-services">
        //es:instance/Person/rating
      </search:path-index>
    </search:range>
  </search:tuples>
  <!--Uncomment to return no results for a blank search, rather than the default of all results
  <search:term xmlns:search="http://marklogic.com/appservices/search">
    <search:empty apply="no-results"/>
  </search:term> 
  -->
  <search:values name="uris">
    <search:uri/>
  </search:values>
  <!--Change to 'filtered' to exclude false-positives in certain searches-->
  <search:search-option>unfiltered</search:search-option>
  <!--Modify document extraction to change results returned-->
  <search:extract-document-data selected="include">
    <search:extract-path xmlns:es="http://marklogic.com/entity-services">
      //es:instance/(Name|Person)
    </search:extract-path>
  </search:extract-document-data>
  <!--Change or remove this additional-query to broaden search beyond entity instance documents-->
  <search:additional-query>
    <cts:element-query xmlns:cts="http://marklogic.com/cts">
      <cts:element xmlns:es="http://marklogic.com/entity-services">
        es:instance
      </cts:element>
      <cts:true-query/>
    </cts:element-query>
  </search:additional-query>
  <!--To return facets, change this option to 'true' and edit constraints-->
  <search:return-facets>false</search:return-facets>
  <!--To return snippets, comment out or remove this option-->
  <search:transform-results apply="empty-snippet"/>
</search:options>
 */
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="schema-generate" lib="es" category="Entity Services"
    subcategory="Entity Services API" bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate an XSD schema that can be used to validate instance data.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic entity model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element(xsd:schema)*</apidoc:return>
  <apidoc:usage>
    Use this function to generate an XSD schema you can use to validate your 
    instance data. As generated, the schema can be used to validate instance 
    data that conforms to the Entity Services canonical XML. You can customize
    the schema as needed. You must install the schema in the schemas database
    to use it for validation.
   <p>
    If the source model includes multiple entity type definitions and the
    entity types define different entity instance namespace URIs, then this
    function generates a schema for each namespace. 
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2350553'>Generating an Entity Instance Schema</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Generate a schema from a model and save it to a file. :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $basic-model := fn:doc("/es-ex/models/name.json")
let $schema := es:schema-generate($basic-model)[1]
return xdmp:save("/somewhere/name.xsd", $schema);

(: Customize schemas as needed, then deploy it to the schemas database.
 : You can use the deployed schema as follows: 
 :)

let $instance-data := fn:doc("/instances/names/some-instance.xml")
return xdmp:validate($instance-data, "strict")
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Generate a schema from a model :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
  
es:schema-generate( es:model-validate(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>1.0.0</es:version>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <middle><es:datatype>string</es:datatype></middle>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
    </es:definitions>
  </es:model>
))

(: ==> A schema similar to the following:

<xs:schema elementFormDefault="qualified" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:sem="http://marklogic.com/semantics" 
    xmlns:es="http://marklogic.com/entity-services">
  <xs:element name="first" type="xs:string"/>
  <xs:element name="middle" type="xs:string"/>
  <xs:element name="last" type="xs:string"/>
  <xs:complexType name="NameType" mixed="true">
    <xs:sequence minOccurs="0">
      <xs:element ref="first"/>
      <xs:element minOccurs="0" ref="middle"/>
      <xs:element ref="last"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="Name" type="NameType"/>
</xs:schema>
 :)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Generate a schema from a basic model and then save it to a file.
const es = require('/MarkLogic/entity-services/entity-services');

const basicModel = fn.doc("/es-ex/models/name.json");
const schema = fn.head(es.schemaGenerate(basicModel));
xdmp.save("/somewhere/name.xsd", schema);


// Customize the schema as needed, then deploy it to the schemas database.
// Once deployed, you can use the schema to validate instance data,
// similar to the following example:

const instanceData = cts.doc('/instances/name/some-instance.xml');
xdmp.validate(instanceData, 'strict');
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Generate a schema from a model.
const es = require('/MarkLogic/entity-services/entity-services');

fn.head( es.schemaGenerate(
  { "info": {
      "title": "Example",
      "version": "1.0.0"
    },
    "definitions": {
      "Name": {
        "properties": {
          "first": { "datatype": "string" },
          "middle": { "datatype": "string" },
          "last": { "datatype": "string" }
        },
        "required": [ "first", "last" ]
      }
    }
  }
));

/* Result: A schema similar to the following.

<xs:schema elementFormDefault="qualified" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:sem="http://marklogic.com/semantics" 
    xmlns:es="http://marklogic.com/entity-services">
  <xs:element name="first" type="xs:string"/>
  <xs:element name="middle" type="xs:string"/>
  <xs:element name="last" type="xs:string"/>
  <xs:complexType name="NameType" mixed="true">
    <xs:sequence minOccurs="0">
      <xs:element ref="first"/>
      <xs:element minOccurs="0" ref="middle"/>
      <xs:element ref="last"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="Name" type="NameType"/>
</xs:schema>

 */
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="database-properties-generate" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate a database configuration artifact from a basic model.
    This data facilitates creating range indexes and lexicons required
    for searching instance data.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="model" type="map:map">
      A valid basic entity model.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>object-node()</apidoc:return>
  <apidoc:usage>
   <p>
    This function produces JSON database configuration properties that
    you can use to configure a MarkLogic database. You can use the
    generated artifact as-is in an 
    <a href="https://developer.marklogic.com/code/ml-gradle">ml-gradle</a> 
    project, or customize it
    slightly for use with the REST Management API. 
   </p><p>
    The configuration data includes a range index definition for each
    entity type property specified in a <span class="xquery"><code>es:range-index</code>
    element</span><span class="javascript"><code>rangeIndex</code> 
    property</span> in the input model. Similarly, the configuration data
    includes a word lexicon definition for each property specified in a 
    <span class="xquery"><code>es:word-lexicon</code> 
    element</span><span class="javascript"><code>wordLexicon</code> 
    property</span> in the input model. These indexes and lexicon
    definitions are compatible with the query options you can generate
    using <a class="xquery" href="#es:search-options-generate">es:search-options-generate</a>
    <a class="javascript" href="#es.searchOptionsGenerate">es.searchOptionsGenerate</a> 
    function.
   </p><p>
    Your application might require additional database configuration. You can 
    use the output of this function as a starting place from which to expand.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2381351'>Generating a Database Configuration Artifact</a> in the <em>Entity Services Developer's Guide</em>
    </apidoc:see-also>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/monitoring/monitoringAPI.xml%2332500'>Using the Management API</a> in the <em>Monitoring MarkLogic Guide</em>
    </apidoc:see-also>
    <apidoc:see-also>
      <a class="xquery" href="#es:search-options-generate">es:search-options-generate</a><a class="javascript" href="#es.searchOptionsGenerate">es.searchOptionsGenerate</a>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

es:database-properties-generate( es:model-validate(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>1.0.0</es:version>
      <es:description>ES Examples</es:description>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <middle><es:datatype>string</es:datatype></middle>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
      <Person>
        <es:properties>
          <id><es:datatype>int</es:datatype></id>
          <name><es:ref>#/definitions/Name</es:ref></name>
          <bio><es:datatype>string</es:datatype></bio>
          <rating><es:datatype>float</es:datatype></rating>
          <phone>
            <es:datatype>array</es:datatype>
            <es:items><es:datatype>string</es:datatype></es:items>
          </phone>
          <friend>
            <es:datatype>array</es:datatype>
            <es:items><es:ref>#/definitions/Person</es:ref></es:items>
          </friend>
        </es:properties>
        <es:primary-key>id</es:primary-key>
        <es:required>id</es:required>
        <es:required>name</es:required>
        <es:range-index>rating</es:range-index>
        <es:word-lexicon>bio</es:word-lexicon>
      </Person>
    </es:definitions>
  </es:model>
))

(: ==> A database configuration artifact similar to the following, as
 :     a JSON object node. You can use it as-is in an ml-gradle project,
 :     or set the values of the "database-name" and "schema-database"
 :     properties and use it with POST /manage/LATEST/databases to create
 :     a new database with this configuration.

{ "database-name": "%%DATABASE%%",
  "schema-database": "%%SCHEMAS_DATABASE%%",
  "path-namespace": [ {
      "prefix": "es",
      "namespace-uri": "http://marklogic.com/entity-services"
  } ],
  "element-word-lexicon": [ {
      "collation": "http://marklogic.com/collation/en",
      "localname": "bio",
      "namespace-uri": ""
  } ],
  "range-path-index": [ {
      "collation": "http://marklogic.com/collation/en",
      "invalid-values": "reject",
      "path-expression": "//es:instance/Person/rating",
      "range-value-positions": false,
      "scalar-type": "float"
  } ],
  "triple-index": true,
  "collection-lexicon": true
}
 :)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
const es = require('/MarkLogic/entity-services/entity-services');

es.databasePropertiesGenerate( es.modelValidate(
{ "info": { 
    "title": "Example", 
    "description": "ES Examples",
    "version": "1.0.0",
  },
  "definitions": {
    "Name" : {
      "properties": {
        "first": { "datatype": "string" },
        "middle": { "datatype": "string" },
        "last": { "datatype": "string" }
      },
      "required": ["first", "last"]
    },
    "Person": {
      "properties": {
        "id": { "datatype": "int" },
        "name": { 
          "$ref": "#/definitions/Name", 
        },
        "bio": { "datatype": "string" },
        "rating": { "datatype": "float" },
        "phone": {
          "datatype": "array",
          "items": { "datatype": "string"}
        },
        "friend": {
          "datatype" : "array",
          "items": { "$ref" : "#/definitions/Person" }
        }
      },
      "required": ["id", "name"],
      "primaryKey" : "id",
      "rangeIndex": ["rating"],
      "wordLexicon": ["bio"]
    }
}}
));

/*  A database configuration artifact similar to the following, as
 *  a JSON object node. You can use it as-is in an ml-gradle project,
 *  or set the values of the "database-name" and "schema-database"
 *  properties and use it with POST /manage/LATEST/databases to create
 *  a new database with this configuration.

{ "database-name": "%%DATABASE%%",
  "schema-database": "%%SCHEMAS_DATABASE%%",
  "path-namespace": [ {
      "prefix": "es",
      "namespace-uri": "http://marklogic.com/entity-services"
  } ],
  "element-word-lexicon": [ {
      "collation": "http://marklogic.com/collation/en",
      "localname": "bio",
      "namespace-uri": ""
  } ],
  "range-path-index": [ {
      "collation": "http://marklogic.com/collation/en",
      "invalid-values": "reject",
      "path-expression": "//es:instance/Person/rating",
      "range-value-positions": false,
      "scalar-type": "float"
  } ],
  "triple-index": true,
  "collection-lexicon": true
}
 */
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="version-translator-generate" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Generate a module that can be used to translate instances conforming to
    one version of a model into instances conforming to another version
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="source-model" type="map:map">
      The basic model for the "older" version of the model. This is the
      model to translate data from.
    </apidoc:param>
    <apidoc:param name="target-model" type="map:map">
      The basic model for the "newer" version of the model. This is the
      model to translate data to.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>xs:string</apidoc:return>
  <apidoc:usage>
   <p>
    This function compares two versions of a basic model and generates an
    XQuery library module you can use to transform instance data from one 
    version to the other. Use this function as part of managing a data
    model lifecycle. As the model for an entity type changes over time, you can
    use the output of this function as the basis for code that helps with
    migrating dependent services and transforms from source data systems.
   </p><p>
    The generated XQuery module contains one function per entity type in
    <code>target-model</code>. Each such function stubs out the conversion
    of one entity type to another. You can use these functions in concert
    with transform code to implement runtime versioning transforms.
   </p><p>
    You will typically need to install the generated module in your modules
    database before you can use it.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/codegen.xml%2338401'>Creating a Model Version Translator Module</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Generate a translator module between two versions of a basic model.
 : The models only differ in that the new version contains an additional
 : (optional) property named "middle" in the Name entity type. 
 :)
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

let $v1-model := es:model-from-xml(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>1.0.0</es:version>
      <es:description>ES Examples</es:description>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
    </es:definitions>
  </es:model>
)
let $v2-model := es:model-from-xml(
  <es:model xmlns:es="http://marklogic.com/entity-services">
    <es:info>
      <es:title>Example</es:title>
      <es:version>2.0.0</es:version>
      <es:description>ES Examples</es:description>
    </es:info>
    <es:definitions>
      <Name>
        <es:properties>
          <first><es:datatype>string</es:datatype></first>
          <middle><es:datatype>string</es:datatype></middle>
          <last><es:datatype>string</es:datatype></last>
        </es:properties>
        <es:required>first</es:required>
        <es:required>last</es:required>
      </Name>
    </es:definitions>
  </es:model>
)
return es:version-translator-generate($v1-model, $v2-model)

==> An XQuery library module similar to the following. Some of the
    comments in the generated module have been omitted for brevity.

xquery version "1.0-ml";
module namespace example-from-example
    = "http://example.org/Example-2.0.0-from-Example-1.0.0";

import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

declare option xdmp:mapping "false";

declare function example-from-example:convert-instance-Name(
    $source-node as node()
) as map:map
{
    json:object()
    (: The following line identifies the type of this instance.  Do not change it. :)
    =>map:with('$type', 'Name')
    (: The following lines are generated from the 'Name' entity type. :)
    =>   map:with('first',                  xs:string($source-node/Name/first))
    (: The following property was missing from the source type :)
    =>es:optional('middle',                 xs:string( () ))
    =>   map:with('last',                   xs:string($source-node/Name/last))

};
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
// Generate a translator module between two versions of a basic model.
// The models only differ in that the new version contains an additional
// (optional) property named "middle" in the Name entity type. 

const es = require('/MarkLogic/entity-services/entity-services');

const v1Model =
  { "info": {
      "title": "Example",
      "version": "1.0.0"
    },
    "definitions": {
      "Name": {
        "properties": {
          "first": { "datatype": "string" },
          "last": { "datatype": "string" }
        },
        "required": [ "first", "last" ]
  } } } ;
const v2Model =
  { "info": {
      "title": "Example",
      "version": "2.0.0"
    },
    "definitions": {
      "Name": {
        "properties": {
          "first": { "datatype": "string" },
          "middle": { "datatype": "string" },
          "last": { "datatype": "string" }
        },
        "required": [ "first", "last" ]
  } } };
es.versionTranslatorGenerate(v1Model, v2Model);

/* Result: An XQuery library module similar to the following. Some of the
 *  comments in the generated module have been omitted for brevity.

xquery version "1.0-ml";
module namespace example-from-example
    = "http://example.org/Example-2.0.0-from-Example-1.0.0";

import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

declare option xdmp:mapping "false";

declare function example-from-example:convert-instance-Name(
    $source-node as node()
) as map:map
{
    json:object()
    (: The following line identifies the type of this instance.  Do not change it. :)
    =>map:with('$type', 'Name')
    (: The following lines are generated from the 'Name' entity type. :)
    =>   map:with('first',                  xs:string($source-node/Name/first))
    (: The following property was missing from the source type :)
    =>es:optional('middle',                 xs:string( () ))
    =>   map:with('last',                   xs:string($source-node/Name/last))

};
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="instance-from-document" lib="es"
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Extract an in-memory entity instance from its envelope document
    as a <span class="xquery"><code>map:map</code> (<json-object/>)</span>
    <span class="javascript">JavaScript object</span>.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="entity-document" type="document-node()">
      An envelope document that contains a canonical entity instance(s).
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map*</apidoc:return>
  <apidoc:usage>
   <p>
    Use this function to get an in-memory instance representation from
    an envelope document that contains canonical instance data within
    <code>es:instance</code> elements. An envelope document is usually
    created using the extract instance function in an instance converter
    module created by the Entity Services API.
   </p><p>
    An in-memory instance contains
    nested objects if those objects were persisted as nested XML elements.
    This function returns a sequence of one or more instances, as 
    <span class="xquery"><code>map:map</code> values (json:object elements)
    </span><span class="javascript">JavaScript objects</span>.
   </p><p>
    To extract an entity from an envelope document as an XML node, use
    <a class="xquery" href="#es:instance-xml-from-document">es:instance-xml-from-document</a>
    <a class="javascript" href="#es.instanceXmlFromDocument">es.instanceXmlFromDocument</a> 
    instead. To extract an entity from an envelope document as a JSON object, use
    <a class="xquery" href="#es:instance-json-from-document">es:instance-json-from-document</a>
    <a class="javascript" href="#es.instanceJsonFromDocument">es.instanceJsonFromDocument</a>
    instead.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/instances.xml%2349233'>Managing Entity Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
    <a class="xquery" href="#es:instance-xml-from-document">es:instance-xml-from-document</a>
    <a class="javascript" href="#es.instanceXmlFromDocument">es.instanceXmlFromDocument</a> 
    </apidoc:see-also>
    <apidoc:see-also>
    <a class="xquery" href="#es:instance-json-from-document">es:instance-json-from-document</a>
    <a class="javascript" href="#es.instanceJsonFromDocument">es.instanceJsonFromDocument</a>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Assume /es-gs/env/1234.xml is an envelope document with
 : the following contents:
  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
:)

xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

es:instance-from-document(fn:doc('/es-gs/env/1234.xml'))

(: Returns a json:object (map:map) equivalent to the following JSON:

{ "$type": "Person",
  "id":1234, 
  "firstName":"George", 
  "lastName":"Washington", 
  "fullName":"George Washington"
}
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
/* Assume /es-gs/env/1234.xml is an envelope document with
 * the following contents:

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
*/

const es = require('/MarkLogic/entity-services/entity-services');
fn.head(
  es.instanceFromDocument(cts.doc('/es-gs/env/1234.xml'))
);

/* Returns the following, as a JavaScript object
  { "$type": "Person",
    "id":1234, 
    "firstName":"George", 
    "lastName":"Washington", 
    "fullName":"George Washington"
  }
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="instance-xml-from-document" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Extract a canonical entity instance from its envelope document, as XML.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="entity-document" type="document-node()">
      An envelope document that contains canonical entity instance(s).
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element()*</apidoc:return>
  <apidoc:usage>
    Use this function to extract the canonical XML instance
    data from an envelope document. This function returns a sequence of
    XML elements, one per instance in the envelope document. If no instances
    are found, an empty sequence is returned.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/instances.xml%2349233'>Managing Entity Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
      <a class="xquery" href="#es:instance-from-document">es:instance-from-document</a><a class="javascript" href="#es.instanceFromDocument">es.instanceFromDocument</a>
    </apidoc:see-also>
    <apidoc:see-also>
      <a class="xquery" href="#es:instance-json-from-document">es:instance-json-from-document</a><a class="javascript" href="#es.instanceJsonFromDocument">es.instanceJsonFromDocument</a>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Assume /es-gs/env/1234.xml is an envelope document with
 : the following contents:
  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
:)

xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

es:instance-xml-from-document(fn:doc('/es-gs/env/1234.xml'))

(: Returns a json:object (map:map) equivalent to the following JSON:

  <Person xmlns:es="http://marklogic.com/entity-services">
    <id>1234</id>
    <firstName>George</firstName>
    <lastName>Washington</lastName>
    <fullName>George Washington</fullName>
  </Person>
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
/* Assume /es-gs/env/1234.xml is an envelope document with
 * the following contents:

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
*/

const es = require('/MarkLogic/entity-services/entity-services');
fn.head(
  es.instanceXmlFromDocument(cts.doc('/es-gs/env/1234.xml'))
);

/* Returns the following, as an XML node
  <Person xmlns:es="http://marklogic.com/entity-services">
    <id>1234</id>
    <firstName>George</firstName>
    <lastName>Washington</lastName>
    <fullName>George Washington</fullName>
  </Person>
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="instance-json-from-document" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Extract an entity instance from its envelope document, as JSON.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="entity-document" type="document-node()">
      A document that contains canonical entity instance(s).
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>object-node()</apidoc:return>
  <apidoc:usage>
    Use this function to extract the canonical instance from
    an envelope document and return it as JSON.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/instances.xml%2349233'>Managing Entity Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
    <apidoc:see-also>
      <a class="xquery" href="#es:instance-from-document">es:instance-from-document</a><a class="javascript" href="#es.instanceFromDocument">es.instanceFromDocument</a>
    </apidoc:see-also>
    <apidoc:see-also>
      <a class="xquery" href="#es:instance-xml-from-document">es:instance-xml-from-document</a><a class="javascript" href="#es.instanceXmlFromDocument">es.instanceXmlFromDocument</a>
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Assume /es-gs/env/1234.xml is an envelope document with
 : the following contents:
  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
:)

xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

es:instance-json-from-document(fn:doc('/es-gs/env/1234.xml'))

(: Returns a JSON object node equivalent to the following:
  { "Person": {
      "id":1234, 
      "firstName":"George", 
      "lastName":"Washington", 
      "fullName":"George Washington"
  } }
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
/* Assume /es-gs/env/1234.xml is an envelope document with
 * the following contents:

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <first>George</first>
        <last>Washington</last>
      </person>
    </es:attachments>
  </es:envelope>
*/

const es = require('/MarkLogic/entity-services/entity-services');
fn.head(
  es.instanceJsonFromDocument(cts.doc('/es-gs/env/1234.xml'))
);

/* Returns the following, as a JSON object node:
  { "Person": {
      "id":1234, 
      "firstName":"George", 
      "lastName":"Washington", 
      "fullName":"George Washington"
  } }
*/
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="instance-get-attachments" lib="es" 
    subcategory="Entity Services API" category="Entity Services" 
    bucket="XQuery Library Modules">
  <apidoc:summary>
    Extract attachments from an entity service document.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="entity-document" type="document-node()">
      An envelope document that contains canonical entity instance(s). Data 
      must be stored within the envelope's attachments node.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>element()*</apidoc:return>
  <apidoc:usage>
   <p>
    Out of the box, Entity Services modules store the original source data 
    for an entity unchanged within the <code>es:attachments</code> element
    of the envelope document. This function returns just these source 
    attachments from the envelope.
   </p><p>
    If the original source is XML, then the attachments contain the source
    root node as a child element by default. If the original source is JSON,
    then the attachment contains the source serialized to text; you can use
    functions such as <span class="xquery">
    <a href="#xdmp:from-json-string">xdmp:from-json-string</a>
    or <a href="#xdmp:unquote">xdmp:unquote</a></span>
    <span class="xquery">
    <a href="#xdmp.fromJsonString">xdmp.fromJsonString</a>
    or <a href="#xdmp.unquote">xdmp.unquote</a></span> to convert the text
    to a JSON object.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/instances.xml%2349233'>Managing Entity Instances</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Assume /es-gs/env/1234.xml is an envelope document with
 : the following contents:
  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <given>George</given>
        <family>Washington</family>
      </person>
    </es:attachments>
  </es:envelope>
:)

xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

es:instance-get-attachments(fn:doc('/es-gs/env/1234.xml'))

(: Returns a the following XML node
  <person xmlns:es="http://marklogic.com/entity-services">
    <pid>1234</pid>
    <given>George</given>
    <family>Washington</family>
  </person>
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
(: Assume /es-gs/env/2345.xml is an envelope document with
 : the following contents. Note the attachment is serialized JSON.

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>2345</id>
        <firstName>Martha</firstName>
        <lastName>Washington</lastName>
        <fullName>Martha Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>{"pid":2345, "given":"Martha", "family":"Washington"}</es:attachments>
  </es:envelope>
:)

xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

xdmp:unquote(
  es:instance-get-attachments(fn:doc('/es-gs/env/2345.xml'))
)

(: Returns the following JSON object. If you do not call xdmp:unquote,
 : the result is a string containing the serialized JSON.

   {"pid":2345, "given":"Martha", "family":"Washington"}
:)
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
/* Assume /es-gs/env/1234.xml is an envelope document with
 * the following contents:

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>1234</id>
        <firstName>George</firstName>
        <lastName>Washington</lastName>
        <fullName>George Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>
      <person>
        <pid>1234</pid>
        <given>George</given>
        <family>Washington</family>
      </person>
    </es:attachments>
  </es:envelope>
*/

const es = require('/MarkLogic/entity-services/entity-services');
fn.head(
  es.instanceGetAttachments(cts.doc('/es-gs/env/1234.xml'))
);

/* Returns the following XML node
  <person xmlns:es="http://marklogic.com/entity-services">
    <id>1234</id>
    <given>George</given>
    <family>Washington</family>
  </person>
*/
  ]]></pre></apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
/* Assume /es-gs/env/1234.xml is an envelope document with
 * the following contents. Note the attachment is serialized JSON.

  <es:envelope xmlns:es="http://marklogic.com/entity-services">
    <es:instance>
      <es:info>
        <es:title>Person</es:title>
        <es:version>0.0.1</es:version>
      </es:info>
      <Person>
        <id>2345</id>
        <firstName>Martha</firstName>
        <lastName>Washington</lastName>
        <fullName>Martha Washington</fullName>
      </Person>
    </es:instance>
    <es:attachments>{"pid":2345, "given":"Martha", "family":"Washington"}</es:attachments>
  </es:envelope>
*/

const es = require('/MarkLogic/entity-services/entity-services');
xdmp.unquote(fn.head(
  es.instanceGetAttachments(cts.doc('/es-gs/env/2345.xml'))
));

// Returns the following JSON object. If you do not call xdmp.unquote,
// the result is a string containing the serialized JSON.
//
// {"pid":2345, "given":"Martha", "family":"Washington"}
  ]]></pre></apidoc:example>
</apidoc:function>

<!-- Make this XQuery only since it is only meant to be used in the
     generated code, which is XQuery only at this time. -->
<apidoc:function name="optional" lib="es" category="Entity Services"
    subcategory="Helper Functions" bucket="XQuery Library Modules" 
    class="xquery">
  <apidoc:summary>
    Add a key-value pair to a map, if the value exists, and return
    the modified input map. This function is meant for use in code 
    generated by Entity Services.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="instance" type="map:map">
      A map:map representation of an entity instance.
    </apidoc:param>
    <apidoc:param name="key-name" type="xs:string">
      A key name.
    </apidoc:param>
    <apidoc:param name="key-value" type="item()?">
      The value to which to set the key, if the value exists.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    <p>
     This function is included for use within the modules that Entity Services
     generates for manipulating instance data. It is identical to 
     <code class="xquery">map:with</code><code class="javascript">map.with</code> 
     except <code class="xquery">map:with</code><code class="javascript">map.with</code>
     inserts a key with a null value in the case of an empty value. This
     function leaves the map unmodified if there is no value.
    </p><p>
     This function returns the original <code>instance</code>, with
     the key-value pair added.
    </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

json:object() =>es:optional("a", "value")
              =>es:optional("missing", ())

(: returns an object with one key/value pair, {"a", "value"} :)
  ]]></pre></apidoc:example>
</apidoc:function>

<!-- Make this XQuery only since it is only meant to be used in the
     generated code, which is XQuery only at this time. -->
<apidoc:function name="extract-array" lib="es" category="Entity Services"
    subcategory="Helper Functions" bucket="XQuery Library Modules" 
    class="xquery">
  <apidoc:summary>
    Convert one or more source nodes into an array by invoking a function
    on each of the elements. This is a utility
    function used by the code generated by Entity Services.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="source-nodes" type="item()*">
      The nodes to be converted into array values.
    </apidoc:param>
    <apidoc:param name="fn" type="function(*)">
      A function reference. The function is applied to each value to be
      inserted into the array.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>json:array?</apidoc:return>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $nodes := (
  <data>1</data>,
  <data>2</data>
)
return es:extract-array($nodes, fn:data#1)

(: Returns the following JSON array: ["1", "2"] :)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="init-source" lib="es" category="Entity Services"
    subcategory="Helper Functions" bucket="XQuery Library Modules"
    class="xquery">
  <apidoc:summary>
    Return the root node of an entity instance or document.
    This function is meant for use in code generated by Entity Services.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="source-nodes" type="item()*">
      The nodes to be normalized. These can be XML element nodes,
      JSON object nodes, or document nodes.
    </apidoc:param>
    <apidoc:param name="entity-type-name" type="xs:string">
      The name of the entity type for which this function is to
      generated a source node.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>item()*</apidoc:return>
  <apidoc:usage>
    If an input node is already canonicalized, this function returns
    the contents of the canonicalized node. Otherwise, this function
    returns the node as-is. For example, if you pass in an XML element
    node or JSON object node, this function returns that node. If you
    pass in a document node, this function returns the XML element node
    or JSON object node that is the document root.
   <p>
    You will not usually call this function outside of code generated by
    Entity Services. The generated code uses this function to normalize
    references to incoming source data to simplify the code. For example,
    when you generate an instance converter module, the
    <code>extract-instance-T</code> function for some entity type
    <code>T</code> calls this function to normalize its input, which
    might be an XML element node, a JSON object node, or a document node.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";
    
let $node := fn:doc('/es-gs/raw/1234.xml')
return ($node, 
        xdmp:describe($node), $node, 
        xdmp:describe(es:init-source($node, 'Person')))

(: Assuming the input document node contains raw source to be used in
 : constructing a Person entity instance, this example returns the
 : following. Note that the input data type is a document node, but the
 : output data type is an element node.
 :  
 : ( <?xml version="1.0" encoding="UTF-8"?>
 :   <person>
 :     <pid>1234</pid>
 :     <given>George</given>
 :     <family>Washington</family>
 :   </person>,
 :   fn:doc("/es-gs/raw/1234.xml"), 
 :   fn:doc("/es-gs/raw/1234.xml")/person )
 :)
(: Returns the following JSON array: ["1", "2"] :)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="init-instance" lib="es" category="Entity Services"
    subcategory="Helper Functions" bucket="XQuery Library Modules"
    class="xquery">
  <apidoc:summary>
    A utility function used by generated code to initialize an instance
    data structure with data common across all entities of a given type,
    such as a type indicator.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="source-node" type="item()">
      The node to be initialized. This should be a source node of the
      form produced by <code>es:init-source</code> (XQuery) or
      <code>es.initSource</code> (JavaScript).
    </apidoc:param>
    <apidoc:param name="entity-type-name" type="xs:string">
      The entity type name expected by the caller.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    This function expects input in the form of a canonical instance, such
    as that produced by <span class="xquery"><code>es:init-source</code>.</span>
    <span class="javascript"><code>es.initSource</code></span> 
    You will not usually 
    call this function directly in your application code. It is used in
    code generated by Entity Services, such as an instance converter module.
   <p>
    You usually will not call this function outside of code generated by
    Entity Services. The generated code uses this function to add properties
    such as the <code>$type</code> property and, if appropriate, 
    <code>$ref</code> property to an instance. This enables your 
    customizations of the generated code to be independent of instance
    properties used internally by Entity Servcies.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

let $raw := fn:doc('/es-gs/raw/1234.xml')
let $instance := es:init-instance(
  es:init-source($raw, 'Person'), 
  'Person')
return ($raw,$instance)

(: Return output similar to the following, assuming the document with
 : URI "/es-gs/raw/1234.xml" contains raw source data for extracting
 : instances for the "Person" entity type.
 : (<person>
 :    <pid>1234</pid>
 :    <given>George</given>
 :    <family>Washington</family>
 :  </person>,
 :  {"$type":"Person"})
 :)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="add-attachments" lib="es" category="Entity Services"
    subcategory="Helper Functions" bucket="XQuery Library Modules"
    class="xquery">
  <apidoc:summary>
    A utility function used by generated code to add one or more 
    nodes to an instance as attachments.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="instance" type="map:map">
      <span class="xquery">A <code>json:object</code></span>
      <span class="javascript">An object</span> containing the 
      instance to which this function should add attachments.
    </apidoc:param>
    <apidoc:param name="attachments" type="xs:string">
      The attachments to add to the instance. These should be XML
      element nodes or JSON object nodes.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    The input <code>instance</code> should be an instance node of the
    form produced by <span class="xquery"><code>es:init-instance</code>.</span>
    <span class="javascript"><code>es.initInstance</code>.</span> 
    You will not usually 
    call this function outside of code generated by Entity Services. The 
    generated code uses this function to add the original raw source to
    an instance as an attachment.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";

let $raw := fn:doc('/es-gs/raw/2345.json')
let $instance := es:init-instance(es:init-source($raw, 'Person'), 'Person')
return ($raw, es:add-attachments($instance, $raw))

(: Returns the original raw input and an instance skeleton to which
 : the raw input node and some addition user-defined data has been
 : added.
 :
 : ( {"pid":2345, "given":"Martha", "family":"Washington"},
 :   {"$type":"Person", 
 :    "$attachments": [
 :      {"pid":2345, "given":"Martha", "family":"Washington"},
 :      "<my>extra data</my>"
 :    ]
 :   } )
 :)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="init-translation-source" lib="es" 
    subcategory="Helper Functions" category="Entity Services" 
    bucket="XQuery Library Modules" class="xquery">
  <apidoc:summary>
    A utility function used in a generated version translator module 
    to initialize the context for converting instances from one
    version to another.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="source" type="item()*">
      Zero or more envelope documents or canonical instances to
      be converted.
    </apidoc:param>
    <apidoc:param name="entity-type-name" type="xs:string">
      The name of the entity type represented by the input <code>source</code>
      nodes.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>item()*</apidoc:return>
  <apidoc:usage>
    You will not usually call this function outside of a version translator
    module generated by Entity Services. The generated code uses this
    function to normalize the source data. This function returns 
    normalized references to source nodes of the specified entity type.
    These nodes are expected to contain canonical data of that type.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="copy-attachments" lib="es" 
    subcategory="Helper Functions" category="Entity Services" 
    bucket="XQuery Library Modules" class="xquery">
  <apidoc:summary>
    A utility function used in a generated version translator module 
    to copy attachment data from a source instance to a destination instance.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="destination" type="map:map">
      <span class="xquery">A <code>json:object</code></span>
      <span class="javascript">An object</span> to which attachments 
      will be copied.
    </apidoc:param>
    <apidoc:param name="source" type="xs:string">
      Zero or more instance envelopes or canonical instances from which
      to copy attachments to <code>destination</code>.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    You will not usually call this function outside of a version translator
    module generated by Entity Services. The generated code uses this
    function to copy attachments from one instance version to another.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="serialize-attachments" lib="es" 
    subcategory="Helper Functions" category="Entity Services" 
    bucket="XQuery Library Modules" class="xquery">
  <apidoc:summary>
    A utility function used to serialize the attachments on an instance
    into either JSON or XML envelopes.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="instance" type="map:map">
      The instance whose attachments are to be serialized.
    </apidoc:param>
    <apidoc:param name="format" type="xs:string">
      The format in which to serialize the attachments. Must be one of
      "json" or "xml".
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    You will not usually call this function outside of code generated by
    Entity services. The generated code uses this function to serialize
    attachments when constructing envelope documents. 
   <p>
    If the data format specified in the <code>format</code> does not 
    match the format of an attachment, then that attachment is serialized 
    as a string. For example, if an attachment is an XML element and the
    requested format is JSON, then the attachment is serialized as the
    string representation of the XML.
   </p>
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2371583'>Creating and Managing Models</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
import module namespace person = 
  "http://example.org/example-person/Person-0.0.1"
  at "/es-gs/person-0.0.1-conv.xqy";

let $source := fn:doc('/es-gs/raw/1234.xml')
let $instance := person:extract-instance-Person($source)
let $envelope-format := "xml"
let $attachments := es:serialize-attachments($instance, "xml")

return ($instance, $attachments)

(: Returns the following output. Notice that xml attachment stored
 : in the instance as a string has been reconstitued as an XML element
 : node in the generated attachments.
 :
 : ( {"$type":"Person", 
 :    "$attachments":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<person>\n  <pid>1234</pid>\n  <given>George</given>\n  <family>Washington</family>\n</person>", 
 :    "id":"1234", 
 :    "firstName":"George", 
 :    "lastName":"Washington", 
 :    "fullName":"George Washington"},
 :
 :   <es:attachments xmlns:es="http://marklogic.com/entity-services">
 :     <person><pid>1234</pid><given>George</given><family>Washington</family></person>
 :   </es:attachments> )
 :)
  ]]></pre></apidoc:example>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
  at "/MarkLogic/entity-services/entity-services.xqy";
import module namespace person = 
  "http://example.org/example-person/Person-0.0.1"
  at "/es-gs/person-0.0.1-conv.xqy";

let $source := fn:doc('/es-gs/raw/1234.xml')
let $instance := person:extract-instance-Person($source)
let $envelope-format := "json"
let $attachments := es:serialize-attachments($instance, "xml")

return ($instance, $attachments)

(: Returns the following output. Notice that XML attachment stored
 : in the instance is returned as a string in the attachments when
 : you request JSON serialization.
 :
 : ( {"$type":"Person", 
 :    "$attachments":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<person>\n  <pid>1234</pid>\n  <given>George</given>\n  <family>Washington</family>\n</person>", 
  :   "id":"1234", 
  :   "firstName":"George", 
  :   "lastName":"Washington", 
  :   "fullName":"George Washington"},
  :
  :  {"attachments":[
  :    "<person><pid>1234</pid><given>George</given><family>Washington</family></person>"
  :  ]} )
 :)
  ]]></pre></apidoc:example>
</apidoc:function>

<apidoc:function name="with-namespace" lib="es" 
    subcategory="Helper Functions" category="Entity Services" 
    bucket="XQuery Library Modules" class="xquery">
  <apidoc:summary>
    A utility function used to decorate an XML instance with namespace
    information during extraction.
  </apidoc:summary>
  <apidoc:params>
    <apidoc:param name="instance" type="map:map">
      The instance to be annotated with namespace information.
    </apidoc:param>
    <apidoc:param name="namespace" type="xs:string">
      The namespace URI to be added to the instance.
    </apidoc:param>
    <apidoc:param name="namespace-prefix" type="xs:string">
      The namespace prefix to be bound to namespace URI.
    </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:usage>
    You will not usually call this function outside of code generated by
    Entity services. The generated code uses this function to decorate an
    instance with namespace URI and prefix information derived from the model.
    The generated code only invokes this function for entity types that
    declare a namespace and namespace prefix.
  </apidoc:usage>
  <apidoc:see-also-list>
    <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/entity-services/models.xml%2399057'>Defining a Namespace URI for an Entity Type</a> in the <em>Entity Services Developer's Guide</em>.
    </apidoc:see-also>
  </apidoc:see-also-list>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml";
import module namespace es = "http://marklogic.com/entity-services"
    at "/MarkLogic/entity-services/entity-services.xqy";

let $raw := fn:doc('/es-gs/raw/1234.xml')
let $instance := es:init-instance(es:init-source($raw, 'Person'), 'Person')
return es:with-namespace($instance, 'http://marklogic.com/entity-services/getting-started','esgs')

(: Returns an initialized instance similar to the following:
 : { "$type":"Person", 
 :   "$namespace":"http://marklogic.com/entity-services/getting-started", 
 :   "$namespacePrefix":"esgs"
 : }
 :)
  ]]></pre></apidoc:example>
</apidoc:function>
</apidoc:module>
