<apidoc:module name="jsearch" category="JavaScript Search (jsearch)" 
  lib="jsearch" bucket="JavaScript Library Modules"
  xmlns:apidoc="http://marklogic.com/xdmp/apidoc"
  xmlns="http://www.w3.org/1999/xhtml" class="javascript">
  <apidoc:summary category="JavaScript Search (jsearch)" 
     bucket="JavaScript Library Modules">
    <p>The jsearch library module is a JavaScript interface for
      searching documents and browsing and analyzing lexicons. The
      functionality overlaps that of the <code>cts:*</code> built-in functions,
      but is designed to feel more natural to a JavaScript developer, both
      in its interface design and by using JavaScript objects and JSON
      data for input and output. For more details, see 
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2346466'>Creating JavaScript Search Applications</a> in the <em>Search Developer's Guide</em>.
    </p><p>To use this module in your Server-Side JavaScript code, include a
       <code>require</code> statement similar to following line in your code:
    </p><code><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");</pre></code>
    <p>You usually being using this library through one of the methods
     on the <code>jsearch</code> class. For more details, see the
     <a href="/js/jsearch">jsearch</a> category.
	</p><p>The jsearch JavaScript module is installed as the following file:</p>
    <ul>
      <li><code><em>install_dir</em>/Modules/MarkLogic/jsearch.sjs</code></li>
    </ul>
    <p>where <code><em>install_dir</em></code> is the directory in which 
       MarkLogic Server is installed.</p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" 
     bucket="JavaScript Library Modules" subcategory="jsearch">
   <p>
     This class contains the top level entry points into the JSearch API,
     plus helper functions for constructing some of the more complex
     inputs expected by the interfaces.
   </p><p>
     To use this module in your Server-Side JavaScript code, include a
     <code>require</code> statement similar to following line in your code:
   </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
   </pre>
   <p>
     Use the following methods to begin building a query on documents,
     index or lexicon values, or value co-occurrences:
   </p>
   <ul>
     <li><a href="/jsearch.documents">jsearch.documents</a></li>
     <li><a href="/jsearch.values">jsearch.values</a></li>
     <li><a href="/jsearch.tuples">jsearch.tuples</a></li>
     <li><a href="/jsearch.words">jsearch.words</a></li>
   </ul>
   <p>
    If you're working primarily with documents in one or more collections,
    you can use <code>jsearch.collections</code> to create a 
    <code>jsearch</code> object implicitly scoped to those collecitons.
   <p></p>
    You can use <code>jsearch.documentSelect</code> to leverage JSearch
    features such as snippeting and content extraction to an arbitrary
    set of documents.
   <p></p>
    The remaining <code>jsearch</code> methods are helper functions for
    constructing non-trivial inputs to other methods, such as lexicon
    references and heat maps.
   </p><p>
    The following classes are also part of the JSearch API. You usually
    end up working with these interfaces by starting with a call to a
    <code>jsearch</code> method. For example, if you invoke
    <code>jsearch.documents</code>, you end up working with the 
    <code>DocumentsSearch</code> interface.
   </p>
   <ul>
     <li><a href="/js/DocumentsSearch">DocumentsSearch</a></li>
     <li><a href="/js/WordsSearch">WordsSearch</a></li>
     <li><a href="/js/ValuesSearch">ValuesSearch</a></li>
     <li><a href="/js/TuplesSearch">TuplesSearch</a></li>
     <li><a href="/js/FacetsSearch">FacetsSearch</a></li>
     <li><a href="/js/FacetDefinition">FacetDefinition</a></li>
   </ul>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="DocumentsSearch"
     bucket="JavaScript Library Modules">
   <p>
     Use these functions to search document content and document properties.
   </p><p>
     To use this module in your Server-Side JavaScript code, include a
     <code>require</code> statement similar to following line in your code:
   </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
   </pre>
   <p>
     The usage model for these methods is as follows:
     Create a document search builder using <code>jsearch.documents</code>,
     then chain calls to methods such as <code>where</code> and
     <code>orderBy</code> on the resulting object. Finally, execute 
     the query by calling the <code>result</code> method. 
   </p><p>
     <strong>The order in which you call the methods of this class is 
     significant.</strong> You should preserve the order shown in the 
     template below. For details, see 
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
   </p><p>
     Use the methods of this class in the following way, where everything
     except the call to <code>documents</code> and <code>result</code>
     being optional. 
    </p><code><pre xml:space="preserve">
jsearch.documents()                         // creates a DocumentsSearch object
  .where(queries)
  .orderBy(jsonPropNamesOrIndexReferences)
  .filter()
  .slice(startPos, endPosPlusOne)
  .map(configOrFuncRef) | .reduce(configOrFuncRef)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      For details, see 
      <a href="/jsearch.documents">jsearch.documents</a>, 
      <a href="/js/DocumentsSearch">DocumentsSearch</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>.
    </p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="FacetsSearch"
     bucket="JavaScript Library Modules">
    <p>
      Use these functions to generate facets from values in a lexicon or
      range index. You can generate facets in combination with a document
      search and from an arbitrary set of documents in the database.
   </p><p>
     To use this module in your Server-Side JavaScript code, include a
     <code>require</code> statement similar to following line in your code:
   </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
   </pre>
   <p>
     <strong>The order in which you chain together the methods of this class
     matters.</strong> You should preserve the ordering shown in the template 
     below. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
    </p><p>
      The intended usage is as follows, with everything
      except the calls to <code>facets</code> and <code>result</code>
      being optional.
    </p><code><pre xml:space="preserve">
jsearch.facets(facetDefinitions, srcDocuments)    // creates a FacetsSearch obj
  .where(queries)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      Use <code>jsearch.facet</code> and the <code>FacetDefinition</code>
      methods to create the input facet definitions.
    </p><p>
      For details, see 
      <a href="/jsearch.facets">jsearch.facets</a>,
      <a href="/js/FacetsSearch">FacetsSearch</a>, 
      <a href="/js/FacetsDefinition">FacetsDefinition</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>.
    </p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="FacetDefinition"
     bucket="JavaScript Library Modules">
   <p>
     Use these functions to build a facet definition for use with
     <code>jsearch.facets</code> and <code>FacetsSearch</code>.
   </p><p>
     To use this module in your Server-Side JavaScript code, include a
     <code>require</code> statement similar to following line in your code:
   </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
   </pre>
   <p>
     <strong>The order in which you call the methods of this class is 
     significant.</strong> You should preserve the order shown in the 
     template below. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
   </p><p>
     The intended usage is as follows, with everything
     except the call to <code>documents</code> and <code>result</code>
     being optional. 
   </p><code><pre xml:space="preserve">
jsearch.facet()                          // creates a FacetDefinition object
  .where(queries)
  .othersWhere(queries)
  .thisWhere(queries)
  .groupInto(bucketDefinition)
  .orderBy(jsonPropNameOrIndexReference)
  .slice(startPos, endPosPlusOne)
  .map(configOrFuncRef) | .reduce(configOrFuncRef)
  .withOptions(optionsConfig)
    </pre></code>
   <p>
     The <code>where</code>, <code>orderBy</code>, <code>slice</code>,
     <code>map</code>, <code>reduce</code>, and <code>withOptions</code>
     methods behave as for a values query.
   </p><p>
     For details, see 
     <a href="/jsearch.facets">jsearch.facets</a>,
     <a href="/js/FacetsSearch">FacetsSearch</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>.
   </p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="TuplesSearch"
     bucket="JavaScript Library Modules">
    <p>
      Use these functions to find n-way value co-occurrences across lexicons 
      and range indexes and to compute aggregates from co-occurrences.
      Create a tuples query builder using <code>jsearch.tuples</code>,
      then build up the query by chaining calls to methods such as
      <code>where</code> and <code>orderBy</code>. Finally, execute the 
      query by calling <code>result</code>. 
    </p><p>
      To use this module in your Server-Side JavaScript code, include a
      <code>require</code> statement similar to following line in your code:
    </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
    </pre>
    <p>
     <strong>The order in which you call the methods of this class is 
     significant.</strong> You should preserve the order shown in the 
     templates below. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
    </p><p>
      The intended usage for retrieving tuples is as follows, with everything
      except the call to <code>tuples</code> and <code>result</code>
      being optional.
    </p><p>
      Use the following form for finding co-occurrences in lexicons and
      range index:
    </p><code><pre xml:space="preserve">
jsearch.tuples(jsonPropNamesOrIndexRefs)       // creates a TuplesSearch object
  .where(queries)
  .orderBy(orderingConfig)
  .slice(startPos, endPosPlusOne)
  .map(funcRef) | .reduce(funcRef, optionalSeed)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      Use the following form for computing aggregates over lexicon and
      range index co-occurrences:
    </p><code><pre xml:space="preserve">
jsearch.tuples(jsonPropNamesOrWordlexiconRefs)
  .where(queries)
  .aggregate(builtinAggregateOrUDF)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      For details, see 
      <a href="/jsearch.tuples">jsearch.tuples</a>, 
      <a href="/js/TuplesSearch">TuplesSearch</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>.
    </p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="ValuesSearch"
     bucket="JavaScript Library Modules">
    <p>
      Use these functions to query and compute aggregates over values in
      lexicons and range indexes. Create a tuples query builder using 
      <code>jsearch.values</code>, then build up the query by chaining
      calls to methods such as <code>where</code> and <code>orderBy</code>.
      Finally, execute the query by calling the <code>result</code> method. 
    </p><p>
      To use this module in your Server-Side JavaScript code, include a
      <code>require</code> statement similar to following line in your code:
    </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
    </pre>
    <p>
     <strong>The order in which you call the methods of this class is 
     significant.</strong> You should preserve the order shown in the 
     templates below. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
    </p><p>
      Use the following form to query the values in an index or lexicon, with
      everything except the call to <code>values</code> and <code>result</code>
      being optional.
    </p><code><pre xml:space="preserve">
jsearch.values(jsonPropNamesOrIndexRefs)           // creates a ValuesSearch obj
  .where(queries)
  .match(pattern) | .groupInto(bucketDefinitions)
  .orderBy(orderingConfig)
  .slice(startPos, endPosPlusOne)
  .map(configOrFuncRef) | .reduce(funcRef, optionalSeed)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      Use the following form for computing aggregates over the values in
      a lexicon or range index. The calls to <code>where</code> and
      <code>withOptions</code> are optional.
    </p><code><pre xml:space="preserve">
jsearch.values(jsonPropNamesOrWordLexiconRefs)
  .where(queries)
  .aggregate(builtinAggregateOrUDF)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      For details, see 
      <a href="/jsearch.values">jsearch.values</a>, 
      <a href="/js/ValuesSearch">ValuesSearch</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>.
    </p>
  </apidoc:summary>

  <apidoc:summary category="JavaScript Search (jsearch)" subcategory="WordsSearch"
     bucket="JavaScript Library Modules">
    <p>
      Use these functions to query and compute aggregates over words in a
      word lexicons. Create a words query builder using 
      <code>jsearch.words</code>, then build up the query by chaining
      calls to methods such as <code>where</code> and <code>orderBy</code>. 
      Finally, execute the query by calling the <code>result</code> method. 
    </p><p>
      To use this module in your Server-Side JavaScript code, include a
      <code>require</code> statement similar to following line in your code:
    </p><pre xml:space="preserve">
const jsearch = require("/MarkLogic/jsearch");
    </pre>
    <p>
     <strong>The order in which you call the methods of this class is 
     significant.</strong> You should preserve the order shown in the 
     template below. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2335438'>Query Design Pattern</a> in the <em>Search Developer's Guide</em>.
    </p><p>
      Use the following form for querying the values in a lexicon or range 
      index. All the calls except <code>jsearch.words</code> and
      <code>result</code> are optional.
    </p><code><pre xml:space="preserve">
jsearch.words(jsonPropNamesOrWordLexiconRefs)
  .where(queries)
  .match(pattern)
  .orderBy(orderingConfig)
  .slice(startPos, endPosPlusOne)
  .map(funcRef) | .reduce(funcRef, optionalSeed)
  .withOptions(optionsConfig)
  .result()
    </pre></code>
    <p>
      For details, see
      <a href="/jsearch.words">jsearch.words</a>,
      <a href="/js/WordsSearch">WordsSearch</a>, and
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>.
    </p>
  </apidoc:summary>

  <apidoc:object name="jsearch" bucket="JavaScript Library Modules"
	    category="JavaScript Search (jsearch)">
     <apidoc:summary>Provides an entry point for searching
     different kinds of resources such as documents, index values,
     index tuples, and index words.</apidoc:summary>
  </apidoc:object>

  <apidoc:method name="documents" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a DocumentsSearch object to define and execute
   a search for documents.</apidoc:summary>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
     <p>
      See the methods of <code>DocumentSearch</code> for the means of
      defining search criteria (<code>DocumentSearch.where</code>) and
      otherwise customizing your query. Search results are not generated
      until you call <code>DocumentsSearch.result</code>.
     </p><p>
      If you do not include a call ot <code>where</code> in your
      call chain, your query matches all documents in the database.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/DocumentsSearch">DocumentsSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find all documents where the "author" JSON property value is "Mark Twain"
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({author: 'Mark Twain'}))
  .result()

/* Result: A search result that includes search metadata and matched 
    documents, similar to the following:

{ "results": [
    { "index": 0,
      "uri": "/books/twain3.json",
      "score": 16384,
      "confidence": 0.43934014439583,
      "fitness": 0.69645345211029,
      "document": {
        "title": "Adventures of Huckleberry Finn",
        "author": "Mark Twain",
        "edition": {
          "format": "paperback",
          "price": 8
        },
        "synopsis": "The adventures of Huck, a boy ..."
      }
    },
    { "index": 1,
      "uri": "/books/twain1.json",
      "score": 16384,
      "confidence": 0.43934014439583,
      "fitness": 0.69645345211029,
      "document": {
        "title": "Adventures of Tom Sawyer",
        "author": "Mark Twain",
        "edition": {
          "format": "paperback",
          "price": 9
        },
        "synopsis": "Tales of mischief and adventure ..."
      }
    }
  ],
  "estimate": 2
}
*/
  ]]></pre></apidoc:example>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find all documents where the "synopsis" JSON property contains
// the word "california". Include snippets in the results.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({synopsis: {$word: 'california'}}))
  .map({snippet: true})
  .result()

/* Result: A search result summary that includes search metadata and snippets
    of matched content, similar to the following:

{"results":[
  {"score":28672, 
   "fitness":0.681636929512024, 
   "uri":"/books/steinbeck1.json", 
   "path":"fn:doc(\"/books/steinbeck1.json\")", 
   "confidence":0.529645204544067, 
   "index":0, 
   "matches":[{
     "path":"fn:doc(\"/books/steinbeck1.json\")/text(\"synopsis\")", 
     "matchText":[
       "...from their homestead and forced to the promised land of ", 
       {"highlight":"California"}, "."
     ]
   }]
  }, 
  { ... }, ...
  ],
  "estimate":3
}
*/
  ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="values" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a ValuesSearch object to define and execute
   a search for a list of indexed values.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="index" type="cts.reference">
		    A cts.reference object for a range index or other
		    value lexicon (such as those for uris or collections).
		    As a shortcut, you can pass the name of a JSON property
		    with a range index as a string.  You can also pass an
		    array of cts.reference objects or strings for a union
		    of values lists.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Use the methods of <code>ValuesSearch</code> to further refine
     your query, including scoping the values to those occurring in
     documents that match a documents search, defining a sort order,
     or computing an aggregate over the values.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/ValuesSearch">ValuesSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
  <apidoc:example><pre xml:space="preserve"><![CDATA[
// Query the values of the "title" JSON property in all documents
// in the directory "/books".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('title')
  .where(cts.directoryQuery('/books/'))
  .result()

/* Result: A list of values from the "title" element range index that satisfy
    the query, similar to the following:

["Adventures of Huckleberry Finn", 
 "Adventures of Tom Sawyer", 
 "Collected Works", 
 "East of Eden", 
 "Of Mice and Men", 
 "The Grapes of Wrath"]
*/
  ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="tuples" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a TuplesSearch object to define and execute
   a search for a list of rows where the values in each row
   co-occur in indexes for a document.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="index" type="cts.reference">
		    An array of cts.reference objects for range indexes or
		    other value lexicons (such as those for uris or collections).
		    As a shortcut, you can pass the name of a JSON property
		    with a range index as a string.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Use the methods of <code>TuplesSearch</code> to tailor your
     query. For example, scope your query to the values in documents
     matching a documents query, define a sort order, or compute an
     aggregate over the co-occurrences.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/TuplesSearch">TuplesSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find co-occurrences of the "author" and "format" JSON properties
// in documents in "/books/" directory.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format'])
  .where(cts.directoryQuery('/books/'))
  .orderBy('item')
  .result()

/* Result: Co-occurence values similar to the following:

[["John Steinbeck", "audiobook"], ["John Steinbeck", "hardback"],
 ["John Steinbeck", "paperback"], ["Mark Twain", "hardback"], 
 ["Mark Twain", "paperback"], ["Robert Frost", "paperback"]]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="words" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a WordsSearch object to define and execute
   a search for a list of indexed words.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="index" type="LexiconDefinition">A JSON property
       (as a string) or a LexiconDefinition produced by one of the jsearch 
       lexion helper functions; see the Usage Notes for details. You can 
       specify a single property name, a single <code>LexiconDefinition</code>,
       or an array of <code>LexiconDefinition</code>'s.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:usage>
     You can search over one or more lexicons defined on JSON properties,
     XML elements, XML attributes, database fields, or database word
     lexicons. You can use a simple string to identify a JSON property, or
     build a LexiconDefinition using the following helper functions:
     <code>jsearch.databaseLexicon</code>, <code>jsearch.elementLexicon</code>,
     <code>jsearch.elementAttributeLexicon</code>, 
     <code>jsearch.fieldLexicon</code>,
     <code>jsearch.jsonPropertyLexicon</code>.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/WordsSearch">WordsSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words in the JSON property named "title".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(jsearch.jsonPropertyLexicon('title'))
  .match('c*')
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="facets" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a FacetsSearch object to define and execute
     a report listing value facets and, optionally, a page of documents.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="facets" type="FacetDefinition">One or an array
       of objects specifying the facets listed in the report.
	   </apidoc:param>
       <apidoc:param name="document" type="DocumentsSearch">An optional
       object specifying a page of documents to retrieve as part of the report.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetsSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Define the facets using <code>FacetDefinition</code>. 
    </p><p>
     Use the methods of <code>FacetsSearch</code> to further refine your
     facets, such as defining a set of documents to return along with
     the facets.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/FacetsSearch">FacetsSearch</a>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/FacetDefinition">FacetDefinition</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets on the "author" and "format" JSON properties of
// documents where the "price" property value is less than 15.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author'),
    jsearch.facet('MediaFormat', 'format')])
  .where(jsearch.byExample({price: {$lt: 15}}))
  .result()

/* Result: A facets summary similar to the following:

{"facets":{
  "Author": {
    "Mark Twain": 2, 
    "John Steinbeck": 1
  }, 
  "MediaFormat": {
    "paperback": 3
}}}
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="facet" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a FacetDefinition object to define the value
     enumeration as part of a facet search.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="name" type="xs.string">The name of the facet.
	   </apidoc:param>
       <apidoc:param name="index" type="cts.reference">
         A <code>cts.jsonPropertyReference</code>,
         <code>cts.elementReference</code>, <code>cts.fieldReference</code>,
         or other reference to the range index or other values lexicon with 
         the values for the facet. You can use a string for a JSON property 
         name as a shortcut for a <code>cts.jsonPropertyReference</code>.
         You can pass multiple references or multiple property-name strings 
         (but not both) for a union of values with the same datatype from 
         multiple range indexes. 
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
    <p>
     Use facet definitions as input to <code>jsearch.facets</code>. Use
     the methods of <code>FacetDefinition</code> to refine your facet.
    </p><p>
     A facet definition can have the following form. Only the 
     <code>facet</code> is required.
    </p><code><pre>
facet(facetName, propertyNameOrIndexRef)
  .othersWhere(queries)
  .thisWhere(queries)
  .groupInto(bucketDefinitions)
  .orderBy(orderingConfig)
  .slice(paginationConfig)
  .map(configOrFuncRef) | .reduce(configOrFuncRef)
  .withOptions(optionsConfig)
    </pre></code>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/FacetDefinition">FacetDefinition</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Construct a facet labeled "Author" on the "author" JSON property
jsearch.facet('Author', 'author')
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Construct a facet labeled "Author" on the "author" JSON property, but
// do not include frequency data in the results.
jsearch.facet('Author', 'author').map({frequency: 'none'})
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Construct a facet labeled "Price" on the "price" JSON property.
// Group the facet values in value range buckets of (X < 10),
// (10 <= X < 20), and (x >= 20)
jsearch.facet('Price','price')
  .groupInto([
    jsearch.bucketName('under $10'), 10,
    jsearch.bucketName('$10 to $19.99'), 20,
    jsearch.bucketName('over $20'), 1000
  ])
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="byExample" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Constructs a cts.query working by example.</apidoc:summary>
   <apidoc:params>
     <apidoc:param name="qbe" type="objectOrNode">
       A JavaScript object, JSON node, or XML node that expresses
       query criteria using Query By Example (QBE) syntax. 
     </apidoc:param>
   </apidoc:params>
   <apidoc:return>cts.query</apidoc:return>
   <apidoc:usage>
     Use this method to construct a cts.query using syntax that closely 
     resemble the content you want to match. The syntax is based on Query 
     By Example (QBE), but contains some differences. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2388933'>Differences Between byExample and QBE</a> in the <em>Search Developer's Guide</em>.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2399182'>Using byExample to Create a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/qbe.xml%2346466'>Searching Using Query By Example</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Matches documents where the "author" JSON property has the value "Mark Twain"
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where( jsearch.byExample({author: 'Mark Twain'}) )
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match all the following conditions:
// - The "title" JSON property has the value "adventures of tom sawyer"
// - The "author" JSON property contains the term "mark" within 2 terms of
//   the term "twain"
// - The "format" JSON property within "edition" property has the value 
//   "paperback" or the value "hardback"
// - The "price" JSON property value is less than 10.00 and greater or
//   or equal to 8.00
jsearch.byExample({
  "title": {
    "$value": "adventures of tom sawyer",
    "$exact": false
  },
  "$near": [
    { "author": { "$word": "mark" } },
    { "author": { "$word": "twain" } }
  ], "$distance": 2,
  "edition": {
    "$or" : [
      { "format": "paperback" },
      { "format": "hardback" }
    ]
  },
  "$and": [
    {"price": { "$lt": 10.00 }},
    {"price": { "$ge": 8.00 }}
  ]
})
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="collections" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Creates a jsearch object for searching within the scope
     of the union of one or more collections.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="uris" type="xs.string">One or an array
       of collection URIs. When you specify multiple URIs, a document is
       included if it is in at least one of the collections.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>jsearch</apidoc:return>
   <apidoc:usage>
     When you use the <code>jsearch</code> object created by this method,
     it effectively appends a <code>cts.collectionQuery</code> to any
     <code>where</code> clause with which it used. To apply a collection
     constraint to a specify sub-query or to use boolean composition of
     collection queries (e.g. collection1 AND collection2), use an
     explicity <code>cts.collectionQuery</code> instead of (or in addition to)
     this method.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
       <a href="/js/DocumentsSearch">DocumentsSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match documents in the "Classics" collection with author "Mark Twain"
const classics = require('/MarkLogic/jsearch.sjs').collections('Classics');
classics.documents()
  .where( classics.byExample({author: 'Mark Twain'}) )
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find words in the "title" word lexicon that occur in documents
// in the "poetry" or "literature" collections.
const favorites = require('/MarkLogic/jsearch.sjs')
                  .collections(['poetry', 'literature']);
favorites.words('title').result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="documentSelect" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Applies document selection logic to the documents 
    returned by <code>cts.search</code>, <code>fn.collection</code>, 
    <code>fn.doc</code>, or another document iterator or to an array 
    of documents or one document.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="results" type="Document*">An iterator
       or array for documents or a document.
	   </apidoc:param>
       <apidoc:param name="configuration" type="object">The options for
       configuring document selection.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>iterator</apidoc:return>
   <apidoc:usage>
     <p>
      Use this method to generate snippets, sparse document projects, and/or
      a set of similar documents from an arbitrary set of documents, such as
      the result of calling cts.search or fn.doc. To perform these same
      operations on a normal JSearch document search, use 
      <code>jsearch.documents</code>.
     </p><p>
     The configuration options are the same as those for
     <code>DocumentSearch.map</code> with the following differences:
     <blockquote><dl>
       <dt><code>snippets</code></dt>
       <dd>The <code>query</code> property of the snippets configuration
       is required to produce snippets.
       </dd>
       <dt><code>start</code></dt>
       <dd>Specifies the zero-based index of the first document
       for identifying the result documents.
       </dd>
       <dt><code>searchOptions</code></dt>
       <dd>Specifies the options used for cts.search() when the result
       list is the iterator returned by cts.search() or
       fn.subsequence(cts.search()). The options are necessary only when
       they include "relevance-trace"
       </dd>
     </dl></blockquote>
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2371243'>Including Snippets of Matching Content in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2319052'>Extracting Portions of Each Matched Document</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate snippets for results returned by cts.search.
const jsearch = require('/MarkLogic/jsearch.sjs');
const myQuery = 
    cts.andQuery([
      cts.directoryQuery('/books/'), 
      cts.jsonPropertyWordQuery('synopsis', 'california')])
jsearch.documentSelect(
  cts.search(myQuery),
  {snippet: {query: myQuery}})
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="makeBuckets" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Returns a list of bounds for grouping
   by subdividing an interval either with a fixed step size or
   a fixed number of division buckets
   within the min and max boundary values as input
   for the <code>ValuesSearch.groupInto</code>
   or <code>FacetDefinition.groupInto</code> method.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="configuration" type="object">The options for
       generating the buckets.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>BucketDefinition</apidoc:return>
   <apidoc:usage>
     The configuration options specify the following parameters:
     <blockquote><dl>
       <dt><code>min</code></dt>
       <dd>The smallest bound, which provides the ceiling for the first bucket. Required.
       </dd>
       <dt><code>max</code></dt>
       <dd>The largest bound, which provides the floor for the last bucket. Required.
       </dd>
       <dt><code>step</code></dt>
       <dd>The size of the buckets between the min and max; to make all buckets
       equal, the difference between the min and max should be divisible by an
       integer to yield the step. Exclusive with respect to divs, one of which is required.
       </dd>
       <dt><code>divs</code></dt>
       <dd>The number of buckets between the min and max. Exclusive with respect to step,
       one of which is required.
       </dd>
       <dt><code>named</code></dt>
       <dd>A boolean specifying whether to assign names to buckets. Optional.
       </dd>
     </dl></blockquote>
     <p>Empty buckets are thrown away by default. The cost of throwing away
     hundreds of empty buckets is smaller than the cost of looking up a minimum
     or maximum in a range index, so it can yields better performance to overestimate
     the min and max instead of determining them exactly.</p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/ValuesSearch">ValuesSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Define a set of buckets over dates, where each bucket covers one month
jsearch.makeBuckets({
  min: xs.date('2015-01-01'), 
  max: xs.date('2015-12-31'), 
  step: xs.yearMonthDuration('P1M')
})
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="makeHeatmap" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Returns a list of bounds for grouping geospatial points
   as a heatmap by subdividing a geospatial box with latitude and longitude
   divisions as input for the <code>ValuesSearch.groupInto</code>
   or <code>FacetDefinition.groupInto</code> method.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="configuration" type="object">The options for
       generating the geospatial heatmap.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>GeospatialBucketDefinition</apidoc:return>
   <apidoc:usage>
     The configuration options specify the following required parameters:
     <blockquote><dl>
       <dt><code>north</code></dt>
       <dt><code>east</code></dt>
       <dt><code>south</code></dt>
       <dt><code>west</code></dt>
       <dd>The latitude and longitude bounds for the box.
       </dd>
       <dt><code>lonDivs</code></dt>
       <dd>The number of longitude buckets between east and west.
       </dd>
       <dt><code>latDivs</code></dt>
       <dd>The number of latitude buckets between south and north.
       </dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/ValuesSearch">ValuesSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Define a heat map that roughly corresponds to the continental United
// states, divided into a set of 20 boxes (5 latitude divisions and
// 4 longitude divisions).
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('incidents')
  .groupInto(makeHeatMap({
    north: 49.0,
    east: -67.0,
    south: 24.0,
    west: -125.0,
    lonDivs: 4,
    latDivs: 5
  }))
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="bucketName" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Names a bucket below the smallest bound, between two bounds, or
   above the largest bound as input for the <code>ValuesSearch.groupInto</code>
   or <code>FacetDefinition.groupInto</code> method.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="name" type="xs.string">The name for the bucket. Omit
       to use the default name for the bucket.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>BucketNameDefinition</apidoc:return>
   <apidoc:usage>If at least one bucket for grouped values is named,
     buckets without an explicit name will be assigned a default name.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/ValuesSearch">ValuesSearch</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Explicitly specify bucket names for a facets query
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
  jsearch.facet('Price','price')
    .groupInto([
      jsearch.bucketName('under $10'), 10,
      jsearch.bucketName('$10 to $19.99'), 20,
      jsearch.bucketName('over $20'), 1000
    ]))
  .where(cts.directoryQuery('/books/'))
  .result();

/* Results:

{"facets": {
  "price": {
    "under $10": {
      "value": {
        "minimum": 8,
        "maximum": 9,
        "upperBound": 10
      },
      "frequency": 2
    },
    "$10 to $19.99": {
      "value": {
        "minimum": 10,
        "maximum": 18,
        "lowerBound": 10,
        "upperBound": 20
      },
      "frequency": 4
    },
    "over $20": {
      "value": {
        "minimum": 20,
        "maximum": 30,
        "lowerBound": 20,
        "upperBound": 1000
      },
      "frequency": 2
    }
  }
} }
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate bucket names from the value ranges for a values query
jsearch.values('price')
  .where(cts.directoryQuery('/books/'))
  .groupInto([
    jsearch.bucketName(), 10,
    jsearch.bucketName(), 20,
    jsearch.bucketName()
    ])
  .result();

/* Result: The "name" property of each facet bucket, generated from the bucket
    boundaries.

[ {
    "minimum": 8,
    "maximum": 9,
    "upperBound": 10,
    "name": "x < 10"
  }, {
    "minimum": 10,
    "maximum": 19,
    "lowerBound": 10,
    "upperBound": 20,
    "name": "10 <= x < 20"
  }, {
    "minimum": 20,
    "maximum": 30,
    "lowerBound": 20,
    "name": "20 <= x"
} ]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="databaseLexicon" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies the lexicon for all words in the database
       as input for the <code>jsearch.words</code> method.
   </apidoc:summary>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:usage>
    <p>
     The database lexicon must be enabled for the database. Note that 
     this lexicon can be huge for a large database and thus is typically 
     only enabled for a small database.
    </p><p>
     When using a database-wide lexicon that does not use the default
     collation (http://marklogic.com/collation), use the 
     <code>withOptions</code> method to pass the collation details to
     the underlying cts query. See the examples, below.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2389575'>Constructing Lexicon and Range Index References</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="/js/WordsSearch">WordsSearch</a>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="#jsearch.words">jsearch.words</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Retrieve words in all documents from the database-wide word lexicon.
// You must configure a database-wide word lexicon to use this form.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(jsearch.databaseLexicon())
  .match('c*')
  .withOptions({words: 'collation=http://marklogic.com/collation/en'})
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="elementLexicon" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies the word lexicon for an element
       as input for the <code>jsearch.words</code> method. The word lexicon
       must be enabled for the element.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="names" type="xs.QName">The element name. Can be
       a string for an element with no namespace. Can be multiple QNames or
       strings (but not both) for the union of multiple element lexicons.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2389575'>Constructing Lexicon and Range Index References</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="#jsearch.words">jsearch.words</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words in an element word lexicon
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(
  jsearch.elementLexicon(
    fn.QName('http://my/namespace/uri','title')))
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words in multiple element word lexicon
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(
  jsearch.elementLexicon([
    fn.QName('http://my/namespace/uri','title'),
    fn.Qname('', 'synopsis')]))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="elementAttributeLexicon" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies the word lexicon for an attribute of an element
       as input for the <code>jsearch.words</code> method. The word lexicon
       must be enabled for the attribute.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="elementNames" type="xs.QName">The element name. Can be
       a string for an element with no namespace. Can be multiple QNames or
       strings (but not both) for the union of the attribute lexicons
       for multiple elements.
	   </apidoc:param>
       <apidoc:param name="attributeNames" type="xs.QName">The attribute name. Can be
       a string for an attribute with no namespace. Can be multiple QNames or
       strings (but not both) for the union of multiple attribute lexicons
       for the element or elements.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2389575'>Constructing Lexicon and Range Index References</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="#jsearch.words">jsearch.words</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words occuring in @attr1 of elem1 and @attr2 of elem2
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(
  jsearch.elementAttributeLexicon(
    [fn.QName('http://my/namespace/uri','elem1'),
     fn.QName('http://my/namespace/uri','elem2')],
    ['attr1', 'attr2']))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="fieldLexicon" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies the word lexicon for a field
       as input for the <code>jsearch.words</code> method. The word lexicon
       must be enabled for the field.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="names" type="xs.string">The field name. Can be
       multiple strings for the union of multiple field lexicons.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2389575'>Constructing Lexicon and Range Index References</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="#jsearch.words">jsearch.words</a>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words in the field named "myField"
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(jsearch.fieldLexicon('myField'))
  .match('c*')
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="jsonPropertyLexicon" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies the word lexicon for a JSON property
       as input for the <code>jsearch.words</code> method. The word lexicon
       must be enabled for the JSON property.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="names" type="xs.string">The property name. Can be
       multiple strings for the union of multiple JSON property lexicons.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:usage>
     To enable a word lexicon on a JSON property, use the element word
     lexicon interfaces in the Admin Interface or the Admin API.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2389575'>Constructing Lexicon and Range Index References</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330231'>Querying Lexicons and Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Match words in the JSON property named "title".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(jsearch.jsonPropertyLexicon('title'))
  .match('c*')
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="udf" object="jsearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="jsearch">
   <apidoc:summary>Identifies a UDF (User Defined Function)
       to the <code>ValuesSearch.aggregate</code> function for aggregating
       values from a single index or
       to the <code>TuplesSearch.aggregate</code> function for aggregating
       co-occuring values from multiple indexes.  The native plugin 
       implementing the UDF must be installed on all hosts.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="plugin" type="xs.string">The name of the plugin
       providing the UDF. Required.
	   </apidoc:param>
       <apidoc:param name="aggregate" type="xs.string">The name of the plugin
       function implementing the UDF. Required.
	   </apidoc:param>
       <apidoc:param name="argument">An optional additional argument passed
       with the values on the calls to the UDF.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>LexiconDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
       <a href="#ValuesSearch.aggregate">ValuesSearch.aggregate</a>
     </apidoc:see-also>
     <apidoc:see-also>
       <a href="#TuplesSearch.aggregate">TuplesSearch.aggregate</a>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378204'>Computing Aggregates Over Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Compute an aggregate using a UDF name "count", installed in
// in the modules database under native/sampleplugin
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .aggregate(jsearch.udf('native/sampleplugin', 'count'))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="DocumentsSearch"  
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)">
     <apidoc:summary>Defines and executes a search for documents
     (including snippets extracted from documents). All of the
     definitional methods are optional but can be called only
     in sequence.</apidoc:summary>
 </apidoc:object>

 <apidoc:method name="where" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies which documents to match based on the indexes
       over the documents.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="queries" type="cts.query">
	    One or an array of cts.query objects matching documents.
	    Some helper functions such as cts.parse() and jsearch.byExample()
	    return a cts.query object.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Apply this method to the output from <code>jsearch.documents</code>.
     You can optionally follow it with "clauses" such as <code>orderBy</code>
     <code>slice</code>, or <code>map</code>. Query results are not
     generated until you call <code>DocumentsSearch.result</code>.
    </p><p>
     You can construct the input queries using <code>cts.parse</code>,
     <code>jsearch.byExample</code>, a cts.query constructor such as
     <code>cts.jsonPropertyWordQuery</code> or
     <code>cts.elementValueQuery</code>, or any other function that
     returns a cts.query object.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2365491'>Creating a cts.query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// A documents query composed from a QBE, a string query, and a cts.query
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where([
    jsearch.byExample({author: 'Mark Twain'}),
    cts.parse('price LT 10',
              {price: cts.jsonPropertyReference('price')}),
    cts.directoryQuery('/books/')])
  .orderBy('title')
  .slice(0,3)
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="orderBy" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies the sort order for matched documents.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="sortKeys" type="cts.order">
        One or an array of ordering specifiers that can be a string,
        a cts.reference object, or a cts.order object. See the Usage Notes
        for details.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Each sorting specifier can be either a string, a cts.reference object,
     or a cts.order object. You pass a single specifier, or an array
     of specifiers. You can mix different types of specifiers.
    </p><p>
     A simple string implicitly specifies ascending order by index value,
     where the index is a string-typed 
     <a href="#cts.jsonPropertyReference">cts.jsonPropertyReference</a>.
     For example, 'name' implies the same ordering as the following:
    <code>cts.indexOrder(cts.jsonPropertyReference(name, ['type=string']))</code>.
     To specify more configuration details about the index type,
     such as a collation or a non-string type, use a
     <code>cts.reference</code> instead of a simple name. To specify ordering
     options such as descending order, use a <code>cts.order</code>
     constructor such as <a href="#cts.indexOrder">cts.indexOrder</a>.
    </p><p>
     A <code>cts.reference</code> object creates an index based cts.order
     object, as if you used <code>cts.indexOrder</code>. To create a
     <code>cts.reference</code>, use constructors such as
     <a href="#cts.jsonPropertyReference">cts.jsonPropertyReference</a>,
     <a href="#cts.elementReference">cts.elementReference</a>,
     <a href="#cts.pathReference">cts.pathReference</a>, or
     <a href="#cts.geospatialJsonPropertyReference">cts.geospatialJsonPropertyReference</a>.
     To specify additional
     ordering options, such as changing the order from ascending to descending,
     use a <code>cts.order</code> constructor such as
     <a href="#cts.indexOrder">cts.indexOrder</a>.
    </p><p>
     To use another ordering scheme or to control whether to return results 
     in ascending or descending order, use a <code>cts.order</code> 
     constructor such as
     <a href="#cts.documentOrder">cts.documentOrder</a>,
     <a href="#cts.confidenceOrder">cts.confidenceOrder</a>,
     <a href="#cts.indexOrder">cts.indexOrder</a>, or
     <a href="#cts.unordered">cts.unordered</a>.
     You must use this form to specify ordering options, such as changing
     the order from ascending to descending.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2343619'>Controlling the Ordering of Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Using a simple JSON property name as input
// Find documents where the "author" JSON property contains the word "twain",
// and order the results by the value of the "title" JSON property, ascending.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({'author': { '$word': 'twain' }}))
  .orderBy('title')
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Using a JSON property with sort order option.
// Find documents where the "author" JSON property contains the word "twain",
// and order the results by the value of the "title" JSON property, descending.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({'author': { '$word': 'twain' }}))
  .orderBy(
      cts.indexOrder(cts.jsonPropertyReference('title'), 'descending'))
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Using a cts.reference to an XML element as input
// Order results by the value of the XML element "someElem" in the
// namespace "/my/namespace", ascending.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  ...
  .orderby(cts.elementReference(fn.QName('/my/namespace','someElem'))
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Using a cts.order object as input
// Order results by descending order of relevance score
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  ...
  .orderBy(cts.scoreOrder('descending'))
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Using multiple sort keys
// Order result first by "price" values, and then by "title" values, ascending.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  ...
  .orderBy(['price', 'title'])
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Example: Mixing different kinds of ordering specifiers
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  ...
  .orderBy([
      'jsonPropName', 
      cts.elementReference(fn.QName('/my/namespace','someElem')), 
      cts.indexOrder(cts.fieldReference('someField'), 'descending'),
      cts.qualityOrder()
   ])
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="filter" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies filtering the documents by inspecting the contents
       of matched and ordered documents to populate the slice. The search is
       unfiltered by default.
   </apidoc:summary>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Perform a filtered search for documents where the "author" JSON
// property has the value "Mark Twain"
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({author: 'Mark Twain'})) 
  .filter()
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="slice" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies a subsequence of matched, sorted, and filtered
      documents to retrieve. If unspecified, the slice defaults to the first
      10 documents.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="start" type="integer">
		    The zero-based index of the first document to return.
	   </apidoc:param>
       <apidoc:param name="end" type="integer">
		    The zero-based index of the document after the last document
		    to return. If unspecified, the end defaults to specify a
		    subsequence of 10 documents.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2344980'>Returning a Result Subset</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find documents containing the word "california" in the "title"
// JSON property, and return the first 5 results.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(cts.parse('title:california'))
  .slice(0,5)
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Return 10 documents, beginning with the 20th result
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .slice(20,30)
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Suppress inclusion of matched documents (or snippets)
const jsearch = require('/MarkLogic/jsearch.sjs');

jsearch.documents()
  .where(cts.jsonPropertyValueQuery('author', 'Mark Twain'))
  .slice(0,0)
  .result()

/* Result: Search results that contain an estimate, but no search metadata 
   or matching documents. Output will be similar to the following:

{ results: null, estimate: 4 }
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="map" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies a function similar to 
     <code>Array.prototype.map()</code> to apply to each document within the 
     slice or the configuration for the built-in mapper.  Exclusive with 
     respect to the <code>documentSearch.reduce</code> clause.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="mapper" type="objectOrFuncRef">
       A configuration object for the built-in mapper, or a reference
       to a custom mapper function. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
     <p>You cannot use this function and <code>DocumentsSearch.reduce</code>
      in the same search. You should only call 
      <code>DocumentSearch.withOptions</code> or
      <code>DocumentSearch.result</code> on the result of this operation.
     </p><p>You can pass in either a configuration object for the built-in
      mapper or a function reference to a custom mapper. The built-in
      mapper configuration object can have the following properties:</p>
     <blockquote><dl>
       <dt><code>snippets</code></dt>
       <dd>Controls selection of matching text with 
         either a boolean value or a configuration object having the 
         <code>preferredMatches</code>, <code>maxMatches</code>,
         <code>perMatchTokens</code>, and <code>query</code> properties.
         For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2371243'>Including Snippets of Matching Content in Search Results</a> in the <em>Search Developer's Guide</em>
       </dd>
       <dt><code>extract</code></dt>
       <dd>Controls selection by XPath with a 
         configuration object having the <code>selected</code> property (an
         enumeration of <code>include</code>|<code>include-with-ancestors</code>
         |<code>exclude</code>|<code>all</code>) and the <code>paths</code> 
         property. For details, see
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2319052'>Extracting Portions of Each Matched Document</a> in the <em>Search Developer's Guide</em>
       </dd>
       <dt><code>namespaces</code></dt> 
       <dd>Specifies a configuration object with prefix keys and uri values 
         for resolving XPath expressions used in <code>extract</code>.
       </dd>
       <dt><code>returnSimilar</code></dt>
       <dd>A boolean value controlling whether to return documents similar 
         to each result document.
       </dd>
     </dl></blockquote>
     <p>A custom mapper should have the following signature:</p>
     <p><code>function (currentItem)</code></p>
     <p>Where <em>currentItem</em> is a search result descriptor object.
      See <a href="/DocumentsSearch.result">DocumentsSearch.result</a> for
      an example of what this object can look like. If the mapper function
      returns a value, the value is added to the <code>results</code> array
      or iterator.</p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2371243'>Including Snippets of Matching Content in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2319052'>Extracting Portions of Each Matched Document</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in mapper to return snippets instead of documents
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({synopsis: {$word: 'california'}}))
  .map({snippet: true})
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in mapper to return snippets, preferrably of
// matches in the "synopsis" property. Return at most 5 tokens around
// the match highlight.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(cts.wordQuery('california'))
  .map({snippet: {
    preferredMatches: ['synopsis'],
    perMatchTokens: 5
  }})
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in mapper to extract just the "title" and "author"
// JSON properties from matched documents.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({synopsis: {$word: 'California'}}))
  .map({extract: {paths: ['/title', '/author']}})
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in mapper to return both snippets and documents.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(jsearch.byExample({synopsis: {$word: 'California'}}))
  .map({snippet: true, extract: {selected: 'all'}})
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use a custom mapper to insert a new property in output document
// returned for each match.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(cts.jsonPropertyValueQuery('author','Mark Twain'))
  .map(function (value) {value.iWasHere = true; return value;})
  .result()

// This example produces output similar to the following, where
// the "iWasHere" property was added to each result by the 
// custom mapper. (Some search results were elided for brevity.)
//
// { "results": [
//   { "index": 0,
//     "uri": "/books/twain4.json",
//     "score": 14336,
//     "confidence": 0.43245348334312,
//     "fitness": 0.7490314245224,
//     "document": {
//       "title": "Adventures of Huckleberry Finn",
//       "author": "Mark Twain",
//       "edition": {
//         "format": "hardback",
//         "price": 18
//       },
//       "synopsis": "The adventures of Huck, a boy of 13, ..."
//     },
//     "iWasHere": true
//   }, ...
//   ],
//   "estimate": 4
// }
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="reduce" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.reduce()
       to apply to each document within the slice. See the Usage Notes
       for details.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="reducer" type="function">
		    The reducing function.
	   </apidoc:param>
       <apidoc:param name="seed" type="anyValue">
		    The initial reduced value passed to the reducing function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
     The reducer function is called once for each matched document.
     The value returned by the last call becomes the final reduced result.
     The reducer function should have the following signature:
     <p>
       <code>function (prev, current, index, state)</code>
     </p><p>Where the parameters contain the following:</p>
     <blockquote><dl>
       <dt><code>prev</code></dt>
       <dd>The output returned by the previous call, or the
         seed value on the first call.</dd>
       <dt><code>current</code></dt>
       <dd>The current document.</dd>
       <dt><code>index</code></dt>
       <dd>The number of the current document.</dd>
       <dt><code>state</code></dt>
       <dd>A state object with a boolean-valued <code>isLast</code>>
         property that indicated the last call. You can set it to
         true to prematurely halt the reduction.</dd>
     </dl></blockquote>
     <p>
      You cannot use this method in conjunction with
      <code>DocumentsSearch.map</code>.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use a custom reducer, with an initial seed value
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.documents()
  .where(cts.jsonPropertyValueQuery('author','Mark Twain'))
  .reduce(function (prev, match, index, state) {
    // do something
  }, {count: 0, value: 0, matches: []})
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="withOptions" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>
     Configure advanced document search options.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="option" type="object">
       A configuration object for enabling special features of the 
       document search. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>DocumentsSearch</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>search</code></dt>
       <dd>An array of string options to pass through to <code>cts.search</code>
         for fine-tuning the configuration from the other document search
         clauses.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for <code>cts.search</code>.</dd>
       <dt><code>forestNames</code></dt>
       <dd>An array of strings for restricting the search to documents 
         in the specified forests.</dd>
       <dt><code>returnEstimate</code></dt>
       <dd>Whether or not to include an estimate of the total number of 
         matching documents in the result set. True by default.</dd>
       <dt><code>returnQueryPlan</code></dt>
       <dd>Whether or not to return a query plan (feedback for fine-tuning
         the query definition in the <code>where</code> clause. 
         False by default.</dd>
       <dt><code>returnRelevanceTrace</code></dt>
       <dd>Whether or not to return a relevance scoring trace for each
         matching document. False by default.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2326946'>Using Options to Control a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use withOptions to include a query plan in the search results
jsearch.documents()
  .where(jsearch.byExample({author: 'Mark Twain'}))
  .withOptions({returnQueryPlan: true})
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="result" object="DocumentsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="DocumentsSearch">
   <apidoc:summary>Executes the document search definition and returns
       a result object with an estimate property
       for the total number of matched documents,
       a results property with an array holding the subsequence of documents
       in the slice, and other properties if specified by withOptions().
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="type" type="string">
       Optional. Specify whether to return the documents as a value (default)
       or a streaming iterator. When you return the documents as a value,
       the documents are an array in the returned results object, unless
       your query uses <code>DocumentsSearch.reduce</code>. Allowed
       values: <code>'value'</code>, <code>'iterator'</code>.   
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>object</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2330559'>Searching Documents</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
const results = jsearch.documents()
  .where(cts.wordQuery('california'))
  .slice(0,2)
  .result()
results

/* Result: Search metadata and document contents for the first 2 documents
    containing the word "california".

{ "results": [
    { "index": 0,
      "uri": "/books/steinbeck1.json",
      "score": 18432,
      "confidence": 0.4903561770916,
      "fitness": 0.71398365497589,
      "document": {
        "title": "The Grapes of Wrath",
        "author": "John Steinbeck",
        "edition": {
          "format": "paperback",
          "price": 10
        },
        "synopsis": "Chronicles the 1930s Dust Bowl migration of one 
           Oklahoma farm family, from their homestead and forced to the 
           promised land of California."
      }
    },
    { "index": 1,
      "uri": "/books/steinbeck2.json",
      "score": 18432,
      "confidence": 0.4903561770916,
      "fitness": 0.71398365497589,
      "document": {
        "title": "Of Mice and Men",
        "author": "John Steinbeck",
        "edition": {
          "format": "hardback",
          "price": 20
        },
        "synopsis": "A tale of an unlikely pair of drifters who move from 
          job to job as farm laborers in California, until it all goes 
          horribly awry."
      }
    }
  ],
  "estimate": 3
}
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
const results = jsearch.documents()
  .where(cts.wordQuery('california'))
  .slice(0,2)
  .result('iterator')
results

/* Result: Search metadata and document contents for the first 2 documents
    containing the word "california". The value of the "results"
    property is a streaming iterator over each result. 

{"results": anIterator, 
 "estimate":3}
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
const results = jsearch.documents()
  .where(cts.wordQuery('california'))
  .orderBy(cts.indexOrder(cts.jsonPropertyReference('price', ['type=float'])))
  .slice(0,5)
  .map({snippet: true})
  .result()

/* Result: Search metadata and snippets from the first 5 documents containing 
    the word "california", ordered by the values in the price JSON property.

{ "results": [
    { "score": 18432,
      "fitness": 0.72760027647018,
      "uri": "/books/steinbeck1.json",
      "path": "fn:doc(\"/books/steinbeck1.json\")",
      "confidence": 0.41591840982437,
      "index": 0,
      "matches": [ {
          "path": "fn:doc(\"/books/steinbeck1.json\")/text(\"synopsis\")",
          "matchText": [
            "...of one Oklahoma farm family, from their homestead and 
             forced to the promised land of ",
            { "highlight": "California" },
            "."
          ]
      } ]
    },
    { "score": 18432,
      "fitness": 0.72760027647018,
      "uri": "/books/steinbeck3.json",
      "path": "fn:doc(\"/books/steinbeck3.json\")",
      "confidence": 0.41591840982437,
      "index": 1,
      "matches": [ {
          "path": "fn:doc(\"/books/steinbeck3.json\")/text(\"synopsis\")",
          "matchText": [
            "Follows the intertwined destinies of two ",
            { "highlight": "California" },
            " families whose generations reenact the fall of Adam and 
             Eve and the rivalry of Cain..."
          ]
      } ]
    },
    { "score": 18432,
      "fitness": 0.72760027647018,
      "uri": "/books/steinbeck2.json",
      "path": "fn:doc(\"/books/steinbeck2.json\")",
      "confidence": 0.41591840982437,
      "index": 2,
      "matches": [ {
          "path": "fn:doc(\"/books/steinbeck2.json\")/text(\"synopsis\")",
          "matchText": [
            "...an unlikely pair of drifters who move from job to job 
             as farm laborers in ",
            { "highlight": "California" },
            ", until it all goes horribly awry."
          ]
      } ]
    }
  ],
  "estimate": 3
}
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="TuplesSearch"  
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
     <apidoc:summary>Defines and executes a search for co-occurring values
     from JSON property, XML element, database field, or other range indexes
     over documents or for aggregates over these co-occuring values.
     All of the definitional methods are optional but can be called only
     in sequence.</apidoc:summary>
 </apidoc:object>

 <apidoc:method name="where" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Specifies which documents have the co-occurring values.
       Omit the where() clause to retrieve co-occurring values from all
       documents in the specified indexes or lexicons.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="queries" type="cts.query">
	    One or an array of cts.query objects matching documents.
	    Some helper functions such as cts.parse() and jsearch.byExample()
	    return a cts.query object.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Apply this method to the output from <code>jsearch.tuples</code>.
     You can optionally follow it with "clauses" such as <code>orderBy</code>
     <code>slice</code>, or <code>map</code>. Results are not
     generated until you call <code>Tuples.result</code>.
    </p><p>
     You can construct the input queries using <code>cts.parse</code>,
     <code>jsearch.byExample</code>, a cts.query constructor such as
     <code>cts.jsonPropertyWordQuery</code> or
     <code>cts.elementValueQuery</code>, or any other function that
     returns a cts.query object.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2365491'>Creating a cts.query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find co-occurences for values in documents in the "/books/" directory.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format'])
  .where(cts.directoryQuery('/books/'))
  .orderBy('item')
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="aggregate" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Applies one or more aggregates to the tuples. Exclusive
       with respect to the orderBy(), slice(), map(), and reduce() clauses.
       The built-in aggregates for tuples support only two indexes. 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="name" type="stringOrUDF+">
        One or an array of built-in aggregate function names or
        aggregate user-defined function (UDF) reference. The allowed
        built-in aggregate names are "correlation", "covariance", and
        "covariancep". To construct UDF reference, use the 
        <code>jsearch.udf</code> helper function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
     You can only use the <code>TuplesSearch.where</code> and
     <code>TuplesSearch.withOptions</code> clauses with this method.
     You cannot use other query modifiers such as 
     <code>TuplesSearch.slice</code> or
     <code>TuplesSearch.orderBy</code>.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378204'>Computing Aggregates Over Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in "correlation" aggregate function.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format'])
  .aggregate('correlation')
  .result();
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Compute a user-defined aggregate over co-occurrence of values in
// the "author" and "format" range indexes. The UDF is a function
// named "count" in the UDF plugin installed in the modules database
// with the path "native/sampleplugin".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author', 'format'])
  .aggregate(jsearch.udf('native/sampleplugin', 'count'))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="orderBy" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Specifies the sort method for the tuples.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="sortKey" type="string">
	    Specifies whether to sort on the "item" (that is, the value
	    of each index) or on the "frequency" (that is, the number
	    of occurrences of the combination of values). When sorting
	    on item, the indexes constituting the tuple are sorted in
	    left-to-right order.
	   </apidoc:param>
       <apidoc:param name="direction" type="string">
	    Specifies whether to sort in "ascending" or "descending" order.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2343619'>Controlling the Ordering of Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author', 'format'])
  .orderBy('item','descending');
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="slice" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Specifies a subset of tuples to retrieve. If unspecified,
      the slice defaults to the first 10 tuples.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="start" type="integer">
		    The zero-based index of the first tuple to return.
	   </apidoc:param>
       <apidoc:param name="end" type="integer">
		    The zero-based index of the tuple after the last tuple
		    to return. If unspecified, the end defaults to specify a
		    subsequence of 10 tuples.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2344980'>Returning a Result Subset</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Return the first 5 co-occurrences.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format','price'])
  .slice(0,5)
  .result()
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Return 5 co-occurrences, beginning with the 20th result
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format','price'])
  .slice(20,25)
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="map" object="TuplesSearch"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.map()
     to apply to each tuple within the slice or the configuration for 
     the built-in mapper. 
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="mapper" type="objectOrFuncRef">
       A configuration object for the built-in mapper, or a reference
       to a custom mapper function. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
     <p>
       You can pass in either a configuration object for the built-in
       mapper or a function reference to a custom mapper. The built-in
       mapper configuration object can have the following properties:
     </p>
     <blockquote><dl>
       <dt><code>frequency</code></dt>
       <dd>One of the string values "fragment", "item", or "none" (default). 
         This setting controls  whether to report the number of documents.
         That is, the fragments) containing the tuple, the number of occurrences
         for each tuple (the items), or to omit the frequency
         (which is the default for a tuples search).
       </dd>
       <dt><code>names</code></dt>
       <dd>Specify a name for each index or lexicon in the tuple and
         for the frequency (if enabled). If names are specified, the 
         built-in mapper returns an object for each tuple with the names 
         as properties. If the frequency is specified but not the name, 
         the built-in mapper returns an array for each tuple. Use the
         same order for the names as the order in which you specify the
         lexicons or indices in <code>jsearch.tuples</code>. If you
         request frequency data, supply the name for the frequency
         property last. See the example, below.
       </dd>
     </dl></blockquote>
     <p>An empty the configuration object causes the built-in mapper
       to return the tuple array node unchanged.
     </p><p>
       A custom mapper should have the following signature:
     </p><p>
       <code>function (currentItem)</code>
     </p><p>
      Where <em>currentItem</em> is the current tuple to act on, in the
      form of an array containing an item representing a value from each
      index over which you generate co-occurrences. For example, if you
      specify 3 index in your call to <code>jsearch.tuples</code> then
      <em>currentItem</em> is an array of length 3. If the mapper function
      returns a value, the value is added to the <code>results</code> array
      or iterator.
     </p><p>You cannot use this method in conjunction with
      <code>TuplesSearch.reduce</code>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Configure the built-in mapper to return frequency, and specify
// names for each value in the tuple
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format','price'])
  .slice(0,2)
  .map({frequency: 'item', names: ['Author','Format','Price','Freq']})
  .result()

/* Result: If the default output would be:
    [["John Steinbeck", "audiobook", 16], ["John Steinbeck", "hardback", 20]]
    Then the output from the built-in mapper as configured is the following:

[{"Author":"John Steinbeck", 
  "Format":"audiobook", 
  "Price":16, 
  "Freq":1
 },{
  "Author":"John Steinbeck", 
  "Format":"hardback", 
  "Price":20, 
  "Freq":1
}]
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Supply a custom mapper. This one simply recasts the tuple into an
// object, similar to the behavior of the built-in mapper with names.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['author','format','price'])
  .map(function (tuple) {
    return { Author: tuple[0], Format: tuple[1], Price: tuple[2]};
  })
  .result()

/* Result:

[{"Author":"John Steinbeck", 
  "Format":"audiobook", 
  "Price":16
 }, {
  "Author":"John Steinbeck", 
  "Format":"hardback", 
  "Price":20
}]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="reduce" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.reduce()
       to apply to each tuple within the slice.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="reducer" type="function">
		    The reducing function.
	   </apidoc:param>
       <apidoc:param name="seed" type="anyValue">
		    The initial reduction passed to the reducing function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
     The reducer function should have the following signature:
     <p>
       <code>function (prev, current, index, state)</code>
     </p><p>Where the parameters have the contents:</p>
     <blockquote><dl>
       <dt><code>prev</code></dt>
       <dd>The reduced tuples returned by the previous call, or the
         seed value on the first call.</dd>
       <dt><code>current</code></dt>
       <dd>The current tuple.</dd>
       <dt><code>index</code></dt>
       <dd>The number of the current tuple.</dd>
       <dt><code>state</code></dt>
       <dd>A state object with a boolean-valued <code>isLast</code>>
         property that indicated the last call. You can set it to
         true to prematurely halt the reduction.</dd>
     </dl></blockquote>
     <p>
      The return from the last call becomes the final reduced result.
     </p><p>
      You cannot use this method in conjunction with
      <code>TuplesSearch.map</code>.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// A custom reducer that computes the average price of each format.
// The reduction is initially seeded with an empty object for the
// accumulator. 
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples(['format','price'])
  .reduce(function (accum, tuple, index, state) {
    if (!accum.hasOwnProperty(tuple[0])) {
      accum[tuple[0]] = {sum: 0, count: 0};
    }
    accum[tuple[0]].sum += tuple[1]
    accum[tuple[0]].count++;
    if (state.isLast) {
      const result = {};
      for (let k in accum) {
        if (accum.hasOwnProperty(k)) {
          result[k] = accum[k].sum / accum[k].count;
        }
      }
      return result;
    } else {
      return accum;
    }
  }, {})
  .result()

/* Result: Assuming the values in the 'format' index are "audiobook",
    "hardback", and "paperback", the output is similar to the following:

{"audiobook":16, "hardback":19, "paperback":14.25}
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="withOptions" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>
     Configure advanced options for a tuples query.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="option" type="object">
       A configuration object for enabling special features of the 
       tuples query. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>TuplesSearch</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>tuples</code></dt>
       <dd>An array of string options to pass through to 
         <code>cts.valueTuples</code> for fine-tuning the configuration 
         from the other tuples search clauses.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for the search.</dd>
       <dt><code>forestNames</code></dt>
       <dd>an array of strings for restricting the query to tuples of documents 
         in the specified forests.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2326946'>Using Options to Control a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples([
    cts.jsonPropertyReference('format'), 
    cts.jsonPropertyReference('price')])
  .withOptions({tuples: ['proximity=5']})
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="result" object="TuplesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="TuplesSearch">
   <apidoc:summary>Executes the tuples search definition and returns results.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="type" type="string">
	    Specifies 'value' (the default) to return the tuples
	    as a value (an array unless reducing) or
	    'iterator' to return a streaming iterator over the tuples.
     </apidoc:param>
   </apidoc:params>
   <apidoc:return>object</apidoc:return>
   <apidoc:usage>
     This function can return an array or an object, depending on how
     the results are generated (the default results, by a mapper, or
     by a reducer).
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2324166'>Finding Value Co-Occurrences in Lexicons and Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.tuples([
    cts.jsonPropertyReference('city'), 
    cts.jsonPropertyReference('event')])
  .where(cts.wordQuery('hazard'))
  .orderBy('frequency', 'descending')
  .slice(0, 100)
  .map({frequency: 'fragment'})
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="ValuesSearch"  
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
     <apidoc:summary>Defines and executes a search for a list
     of indexed values or for aggregates over a list of indexed values
     for a JSON property, XML element, database field, or other value
     lexicon.
     All of the definitional methods are optional but can be called only
     in sequence.</apidoc:summary>
 </apidoc:object>

 <apidoc:method name="where" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Specifies which documents have values
       in the index. Omit the where() clause to retrieve
       all values in the index.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="queries" type="cts.query">
	    One or an array of cts.query objects matching documents.
	    Some helper functions such as cts.parse() and jsearch.byExample()
	    return a cts.query object.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Apply this method to the output from <code>jsearch.values</code>.
     You can optionally follow it with "clauses" such as <code>orderBy</code>
     <code>slice</code>, or <code>map</code>. Results are not
     generated until you call <code>ValuesSearch.result</code>.
    </p><p>
     You can construct the input queries using <code>cts.parse</code>,
     <code>jsearch.byExample</code>, a cts.query constructor such as
     <code>cts.jsonPropertyWordQuery</code> or
     <code>cts.elementValueQuery</code>, or any other function that
     returns a cts.query object.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2365491'>Creating a cts.query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find values of the author JSON property that occur in documents
// in the /books/ directory.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values(['author'])
  .where(cts.directoryQuery('/books/'))
  .result()

// Result: ["John Steinbeck", "Mark Twain", "Robert Frost"]
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="match" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Limits the values to those that
       match the pattern. Exclusive with respect to the groupInto()
       and aggregate() clauses.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="pattern" type="xs.anyAtomicType">
	    Typically a string with a wildcard pattern (not a regex)
	    for matching the values from the index over the documents
	    selected by the <code>where</code> clause.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find values of the author JSON property that begin with "m" and 
// that occur in documents in the /books/ directory.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values(['author'])
  .where(cts.directoryQuery('/books/'))
  .match("m*")
  .result()

// Result: ["Mark Twain"]
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="groupInto" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Groups the values into buckets between bound values,
       which must appear in increasing order. 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="bounds" type="bucketDefinition">
        Defines the boundary values separating the buckets. A bucket
        definition can be an array of boundary values or an array of
        (bucketNames, boundaryValue) pairs. For geospatial buckets,
        a boundary value can be an object with <code>lat</code> and
        <code>lon</code> properties. Helper functions are available for
        creating bucket definitions; for details, see the Usage Notes.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
    <p>Create buckets using the <code>jsearch.makeBucket</code> or
     <code>jsearch.makeHeatMap</code> helper functions.
    </p><p>
      Each bucket includes the previous boundary and excludes the 
      following boundary. To assign names to the buckets, alternate
      calls to <code>jsearch.bucketName</code> with the bound values.
      Empty buckets are thrown away by default, so it can be
      efficient to estimate bounds instead of determining precisely
      the smallest and largest bound. You can use 
      <code>jsearch.makeHeatMap</code> to group geospatial values 
      into a heatmap. 
    </p><p>
      You cannot use this method with <code>ValuesSearch.match</code>
      or <code>ValuesSearch.aggregate</code>.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .where(cts.directoryQuery('/books/'))
  .groupInto([10,20])
  .result();

/* Result: A set of 3 unnamed buckets, similar to the following:
[{"minimum":8, "maximum":9, "upperBound":10}, 
  {"minimum":10, "maximum":18, "lowerBound":10, "upperBound":20}, 
  {"minimum":20, "maximum":30, "lowerBound":20}]
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .where(cts.directoryQuery('/books/'))
  .groupInto([
    jsearch.bucketName(), 10,
    jsearch.bucketName(), 20,
    jsearch.bucketName()
    ])
  .reduce({frequency: 'item'})
  .result();

/* Result: Three buckets with the default name. The bucket name is returned 
    in a "name" property. If you request frequency data, an object is returned
    instead of an array, and the object has a property corresponding to
    each bucket name. See the next example for this style of output.
    
[ { "minimum": 8,
    "maximum": 9,
    "upperBound": 10,
    "name": "under $10"
  },
  { "minimum": 10,
    "maximum": 18,
    "lowerBound": 10,
    "upperBound": 20,
    "name": "$10 to $19.99"
  },
  { "minimum": 20,
    "maximum": 30,
    "lowerBound": 20,
    "upperBound": 1000,
    "name": "over $20"
  }
]
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .where(cts.directoryQuery('/books/'))
  .groupInto([
    jsearch.bucketName('under $10'), 10,
    jsearch.bucketName('$10 to $19.99'), 20,
    jsearch.bucketName('over $20'), 1000
    ])
  .reduce({frequency: 'item'})
  .result();

/* Result: A set of three buckets with custom names, similar to the following.
    The result is an object rather than an array because of the inclusion
    of frequency data.

{ "under $10": {
    "value": {
      "minimum": 8,
      "maximum": 9,
      "upperBound": 10
    },
    "frequency": 2
  },
  "$10 to $19.99": {
    "value": {
      "minimum": 10,
      "maximum": 18,
      "lowerBound": 10,
      "upperBound": 20
    },
    "frequency": 4
  },
  "over $20": {
    "value": {
      "minimum": 20,
      "maximum": 30,
      "lowerBound": 20,
      "upperBound": 1000
    },
    "frequency": 3
  }
}
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="aggregate" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Applies one or more aggregates to the values
       in the index. Exclusive with respect to the match(),
       groupInto(), orderBy(), slice(), map(), and reduce() clauses.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="name" type="stringOrUDF+">
        One or an array of built-in aggregate function names or
        aggregate user-defined function (UDF) reference. The allowed
        built-in aggregate names are "avg", "count", "max", "min", 
        "stddev", "stddevp", "sum", "variance", or "variancep". To
	    construct UDF reference, use the <code>jsearch.udf</code>
        helper function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
     You can only use the <code>ValuesSearch.where</code> and
     <code>ValuesSearch.withOptions</code> clauses with this method.
     You cannot use other query modifiers such as 
     <code>ValuesSearch.slice</code> or <code>ValuesSearch.orderBy</code>.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378204'>Computing Aggregates Over Range Indexes</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Compute aggregates using built-in aggregate functions
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .aggregate(['min','max','avg'])
  .result();

// Result: {"min":8, "max":30, "avg":16.125}
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Compute aggregates using a UDF
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .aggregate(jsearch.udf('native/sampleplugin', 'count'))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="orderBy" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Specifies the sort order for values.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="sortKey" type="string">
	    Specifies whether to sort on the "item" (that is, the value)
	    or on the "frequency" (that is, the number of occurrences
	    of the value).
	   </apidoc:param>
       <apidoc:param name="direction" type="string">
	    Specifies whether to sort in "ascending" or "descending" order.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2343619'>Controlling the Ordering of Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('title')
  .orderBy('frequency', 'descending')
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="slice" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Specifies a subsequence of values to retrieve. If 
     unspecified, the slice defaults to the first 10 values.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="start" type="integer">
		    The zero-based index of the first value to return.
	   </apidoc:param>
       <apidoc:param name="end" type="integer">
		    The zero-based index of the value after the last value
		    to return. If unspecified, the end defaults to specify a
		    subsequence of 10 values (<code>start + 10</code>).
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2344980'>Returning a Result Subset</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Return the first 3 values of the 'title' JSON property.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('title')
  .slice(0,3)
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="map" object="ValuesSearch"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Specify a function similar to Array.prototype.map()
       to apply to each value within the slice, or 
       configure the built-in mapper. 
       Exclusive with respect to the reduce() clause.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="mapper" type="objectOrFuncRef">
       A configuration object for the built-in mapper, or a reference
       to a custom mapper function. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
     <p>
       You can pass in either a configuration object for the built-in
       mapper or a function reference to a custom mapper. The built-in
       mapper or your custom mapper is applied to each value in the
       current slice of values from a lexicon or range index.
     </p><p>
       The built-in
       mapper configuration object can have the following properties:
     </p>
     <blockquote><dl>
       <dt><code>frequency</code></dt>
       <dd>One of the string values "fragment", "item", or "none" (default). 
         This setting controls  whether to report the number of documents
         (that is, the fragments) containing the values, the number of 
         occurrences of each value (that is, the items), or to omit the 
         frequency. The default is "none".
       </dd>
       <dt><code>names</code></dt>
       <dd>Specify a name for the values and for the frequency (if enabled). 
         If <code>names</code> is specified, the built-in mapper returns an 
         object for each value with the names as properties. If the frequency            is specified but not the name, the built-in mapper returns an array 
         for each value. The frequency name should appear after the value
         name. For example: <code>{names: [valName, freqName]}</code>.
         See the example, below.
       </dd>
     </dl></blockquote>
     <p>An empty configuration object causes the built-in mapper
       to return the values array unchanged.
     </p><p>
       A custom mapper should have the following signature:
     </p><p>
       <code>function (currentItem)</code>
     </p><p>
      Where <em>currentItem</em> is the current value to act on.
      If the function returns a value, the value is added to the results
      array or iterator.
     </p><p>You cannot use this method in conjunction with
      <code>ValuesSearch.reduce</code>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Built-in mapper configure to return frequency with the values
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('author')
  .map({frequency: 'item'})
  .result();

// Result: [["John Steinbeck", 3], ["Mark Twain", 4], ["Robert Frost", 1]]
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Built-in mapper configured with frequency and names
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('author')
  .map({frequency: 'item', names: ['Author', 'Count']})
  .result();

/* Result:
[{"Author":"John Steinbeck", "Count":3}, 
 {"Author":"Mark Twain", "Count":4}, 
 {"Author":"Robert Frost", "Count":1}]
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use a custom mapper
const jsearch = require('/MarkLogic/jsearch.sjs');
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('author')
  .map(function (value) {
     return String(value).toLowerCase() 
   })
  .result();

// Result: ["john steinbeck", "mark twain", "robert frost"]
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="reduce" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.reduce()
       to apply to each value within the slice or a configuration object
       for the built-in reducer. See the Usage Notes for details.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="reducer" type="objectOrFuncRef">
		 The reducer function or a configuration for the built-in mapper.
	   </apidoc:param>
       <apidoc:param name="seed" type="anyValue">
	     The initial reduction passed to the reducing function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
     <p>You can pass in either a configuration object for the built-in
      reducer or a function reference to a custom reducer. The built-in
      reducer configuration object can have the following properties:</p>
     <blockquote><dl>
       <dt><code>frequency</code></dt>
       <dd>One of the string values "fragment", "item", or "none" (default).
         This setting controls whether or not to include the number of
         occurrences of each value. Fragment frequency is the number
         of fragments (documents) containing each value. Item frequency
         is the number occurrences of each value. Defaults to none.</dd>
     </dl></blockquote>
     <p>
      When returning frequencies, the built-in reducer returns an 
      object with the serialized value (or bucket name when using 
      <code>groupInto</code>) as the key and the frequency as the value.
     </p><p>
     The reducer function should have the following signature:
     </p><p>
       <code>function (prev, current, index, state)</code>
     </p><p>Where the parameters have the following contents:</p>
     <blockquote><dl>
       <dt><code>prev</code></dt>
       <dd>The value returned by the previous call, or the
         seed value on the first call.</dd>
       <dt><code>current</code></dt>
       <dd>The current value.</dd>
       <dt><code>index</code></dt>
       <dd>The number of the current value.</dd>
       <dt><code>state</code></dt>
       <dd>A state object with a boolean-valued <code>isLast</code>>
         property that indicated the last call. You can set it to
         true to prematurely halt the reduction.</dd>
     </dl></blockquote>
     <p>
      The return from the last call becomes the final reduced result.
     </p><p>
      You cannot use this method in conjunction with
      <code>ValuesSearch.map</code>.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Using the built-in reducer to return frequency data
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('author')
  .reduce({frequency: 'item'})
  .result();

// Result: {"John Steinbeck":3, "Mark Twain":4, "Robert Frost":1}
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Using a custom reducer. (In practice, you would use the aggregate
// method with the built-in "avg" aggregate function to do this calculation.)
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .where(cts.directoryQuery('/books/'))
  .reduce(function (accum, value, index, state) {
     const freq = cts.frequency(value);
     accum.count += freq;
     accum.sum += value * freq;
     return state.isLast ? (accum.sum / accum.count) : accum;
   }, {count: 0, sum: 0})
  .result();

// Result: The computed value: 16.125
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="withOptions" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>
     Configure advanced options for a values query.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="option" type="object">
		    The configuration object for enabling special features
		    of the values search.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>ValuesSearch</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>values</code></dt>
       <dd>An array of string options to pass through to 
         <code>cts.values</code>, <code>cts.valueMatch</code>,
         <code>cts.valueRanges</code>, or <code>cts.geospatialBoxes</code>
         for fine-tuning the configuration from the other values search 
         clauses.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for the search.</dd>
       <dt><code>forestNames</code></dt>
       <dd>An array of strings for restricting the query to the values of 
         documents in the specified forests.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2326946'>Using Options to Control a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values('price')
  .withOptions({qualityWeight: 2.0})
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="result" object="ValuesSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="ValuesSearch">
   <apidoc:summary>Executes the values search definition and returns
       an array or object depending on whether the results are 
       generated by default, with a mapper, or with a reducer.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="type" type="string">
		    Specifies 'value' (the default) to return a value
		    (an array unless reducing) or
		    'iterator' to return a streaming iterator over the values.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>object</apidoc:return>
   <apidoc:usage>
     This function can return an array or an object, depending on how
     the results are generated (the default results, by a mapper, or
     by a reducer).
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2378939'>Querying the Values in a Lexicon or Index</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.values(cts.jsonPropertyReference('event'))
  .where(cts.wordQuery('hazard'))
  .orderBy('frequency', 'descending')
  .slice(0, 100)
  .map({frequency: 'fragment'})
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="WordsSearch"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
     <apidoc:summary>Defines and executes a search for a list
     of indexed words for a JSON property, XML element, XML attribute,
     database field, or database word lexicon.
     All of the definitional methods are optional but can be called only
     in sequence.</apidoc:summary>
 </apidoc:object>

 <apidoc:method name="where" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>
     Limit the words returned by a word lexicon query to those in 
     documents selected by a query.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="queries" type="cts.query">
	    One or an array of cts.query objects matching documents.
	    Some helper functions such as cts.parse() and jsearch.byExample()
	    return a cts.query object.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:usage>
    <p>
     Apply this method only to the output from <code>jsearch.words</code>.
    </p><p>
     You can construct the input queries using <code>cts.parse</code>,
     <code>jsearch.byExample</code>, a cts.query constructor such as
     <code>cts.jsonPropertyWordQuery</code> or
     <code>cts.elementValueQuery</code>, or any other function that
     returns a cts.query object.
    </p><p>
     Omit the <code>where</code> clause to retrieve words from all documents.
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2365491'>Creating a cts.query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find all words in the database that are in documents where
// "format" JSON property has the value "hardback".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(jsearch.databaseLexicon())
  .where(jsearch.byExample({'format': 'hardback'}))
  .result()

/* Result: The first 10 matching words. Use slice to control the number 
   of results.
["13", 
 "a", 
 "A", 
 "account", 
 "adventure", 
 "adventures", 
 "Adventures", 
 "all", 
 "along", 
 "America"]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="match" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>
     Limits the words returned by a word lexicon query to those that 
     match a wildcard pattern.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="pattern" type="xs.anyAtomicType">
	    A string with a wildcard pattern (not a regex)
	    for matching the words in the lexicon from the documents
	    selected by the <code>where</code> clause.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find all words in the word lexicon for the JSON property "title"
// that being with "e".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words('title')
  .match('e*')
  .result()

// Result: ["East", "Eden"]
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="orderBy" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>Specifies the sort order for the words.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="direction" type="string">
	    Specifies whether to sort in "ascending" or "descending" order.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2343619'>Controlling the Ordering of Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find all words in the JSON property named "title". Return
// the results in descending order.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words('title')
  .orderBy('descending')
  .result()

/* Result: The last 10 words in the lexicon

["Wrath", "Works", "Tom", "The", 
  "Southern", "Sites", "Secret", 
  "Sawyer", "Sacred", "Of"]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="slice" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>
      Specify a positional subset of words to retrieve. If unspecified,
      the slice defaults to the first 10 words.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="start" type="integer">
	    The zero-based index of the first word to return.
	 </apidoc:param>
     <apidoc:param name="end" type="integer">
	    The zero-based index of the word after the last word
	    to return. If unspecified, the end defaults to specify a
	    subsequence of 10 words.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2344980'>Returning a Result Subset</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words('title')
  .slice(0,3)
  .result()
/* Result: Return the first 3 words in the lexicon. For example:
["Adventures", "and", "Collected"]
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="map" object="WordsSearch"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.map()
       to apply to each word within the slice.
       Exclusive with respect to the reduce() clause.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="mapper" type="objectOrFuncRef">
       A configuration object for the built-in mapper, or a reference
       to a custom mapper function. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:usage>
     <p>
       Your custom mapper function is invoked on each word in the current
       slice. Your custom mapper should have the following signature:
     </p><p>
       <code>function (currentItem)</code>
     </p><p>
      Where <em>currentItem</em> is the current word to act on.
      If the function returns a value, the value is added to the results
      array or iterator.
     </p><p>You cannot use this method in conjunction with
      <code>WordsSearch.reduce</code>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Returns true if the input is on my black list
function isInBlackList(word) {...};

const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words('title')
  .slice(0,3)
  .map(function (word) {
    return isInBlackList(word) ? undefined : word
  })
  .result()

// Result: An array of words in the 'title' word lexicon that are not blacklisted
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="reduce" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>Specifies a function similar to Array.prototype.reduce()
       to apply to each word within the slice. 
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="reducer" type="function">
		    The reducing function.
	   </apidoc:param>
       <apidoc:param name="seed" type="anyValue">
		    The initial reduction passed to the reducing function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:usage>
     <p>
      Your custom reducer function should have the following signature:
     </p><p>
       <code>function (prev, current, index, state)</code>
     </p><p>Where the parameters have the following contents:</p>
     <blockquote><dl>
       <dt><code>prev</code></dt>
       <dd>The value returned by the previous call, or the
         seed value on the first call.</dd>
       <dt><code>current</code></dt>
       <dd>The current word.</dd>
       <dt><code>index</code></dt>
       <dd>The number of the current word.</dd>
       <dt><code>state</code></dt>
       <dd>A state object with a boolean-valued <code>isLast</code>>
         property that indicated the last call. You can set it to
         true to prematurely halt the reduction.</dd>
     </dl></blockquote>
     <p>
      The return from the last call becomes the final reduced result.
     </p><p>
     </p><p>
      You cannot use this method in conjunction with
      <code>WordsSearch.map</code>.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2345340'>Using a Custom Reducer</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
  </apidoc:method>

  <apidoc:method name="withOptions" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>
     Configure advanced options for a words query.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="option" type="object">
		    The configuration object for enabling special features
		    of the words search.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>WordsSearch</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>words</code></dt>
       <dd>An array of string options to pass through to 
         <code>cts.words</code>, <code>cts.wordMatch</code>,
         or one of the other word lexicon functions for fine-tuning 
         the configuration from the other words search clauses.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for the search.</dd>
       <dt><code>forestNames</code></dt>
       <dd>An array of strings for restricting the query to the words in 
         documents in the specified forests.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words('title')
  .withOptions({qualityWeight: 2.0})
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="result" object="WordsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="WordsSearch">
   <apidoc:summary>Executes the words search definition and returns
       an array or object depending on whether the results are 
       generated by default, with a mapper, or with a reducer.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="type" type="string">
	   Specifies 'value' (the default) to return the words
	   as a value (an array unless reducing) or
	   'iterator' to return a streaming iterator over the words.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>object</apidoc:return>
   <apidoc:usage>
     This function can return an array or an object, depending on how
     the results are generated (the default results, by a mapper, or
     by a reducer).
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2362152'>Querying Values in a Word Lexicon</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Find the first 10 words that occur in the "title" property of
// documents containing the word "adventure".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.words(srch.jsonPropertyLexicon('title'))
  .where(cts.wordQuery('adventure'))
  .slice(0, 10)
  .result();

// Result: An array of the matched words.
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="FacetsSearch"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)">
     <apidoc:summary>Defines and executes one or more value
     searches with an optional page of document results.
     (including snippets extracted from documents). All of the
     definitional methods are optional but can be called only
     in sequence.</apidoc:summary>
 </apidoc:object>

 <apidoc:method name="where" object="FacetsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetsSearch">
   <apidoc:summary>Specify one or an array of cts.query's used to 
     qualify the facet values and the document result set (if requested).
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="queries" type="cts.query">
	    One or an array of cts.query objects.
	    Some helper functions such as cts.parse() and jsearch.byExample()
	    return a cts.query object.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetsSearch</apidoc:return>
   <apidoc:usage>
    If your facet operation also includes a documents query, then
    the <code>where</code> clause of that query qualify only the documents. 
    By contrast, this <code>where</code> can be used to qualify both the
    facet values and any returned documents.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2365491'>Creating a cts.query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets for the author and format JSON properties. Include
// only those values that occur in documents where the price JSON 
// property values is less than 15.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author'),
    jsearch.facet('MediaFormat', 'format')])
  .where(jsearch.byExample({price: {$lt: 15}}))
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="withOptions" object="FacetsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetsSearch">
   <apidoc:summary>
     Configure advanced options for facet generation.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="option" type="object">
	   The configuration object for enabling special features
	   of the facets search. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetsSearch</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>maxThreads</code></dt>
       <dd>The maximum number of threads to use for concurrent facet
         processing. Default value: 8.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for the search.</dd>
       <dt><code>forestNames</code></dt>
       <dd>An array of strings for restricting the query to 
         documents in the specified forests.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2326946'>Using Options to Control a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use 12 threads for concurrent facet generation.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author'),
    jsearch.facet('MediaFormat', 'format')])
  .where(jsearch.byExample({price: {$lt: 15}}))
  .withOptions({maxThreads: 12})
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="result" object="FacetsSearch" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetsSearch">
   <apidoc:summary>Executes the facets search definition and returns
       the results.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="type" type="string">
	    Specifies 'value' (the default) to return the results for each facet
	    (and documents, if specified) as a value (an array unless reducing) or
	    'iterator' to return a streaming iterator over each set of results.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>object</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
    jsearch.facet( cts.jsonPropertyReference('city')  ).slice(0, 10),
    jsearch.facet( cts.jsonPropertyReference('event') ).slice(0, 15),
    jsearch.documents().slice(0, 25)
    )
  .where(cts.wordQuery('hazard'))
  .result();
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:object name="FacetDefinition"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
     <apidoc:summary>Defines a search for a list of indexed values
     as part of a facets report. The facet definition resembles
     a ValuesSearch definition with a few key differences.
     </apidoc:summary>
 </apidoc:object>

 <apidoc:method name="othersWhere" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>
     Specify a query to apply to facets other than this one. If a
     documents query is included, this query also applies to the documents
     result set.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="queries" type="cts.query">
	   One or an array of cts.query objects.
	   Some helper functions such as cts.parse() and jsearch.byExample()
	   return a cts.query object.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2388888'>Multi-Facet Interactions Using othersWhere</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets from documents where the price JSON property value
// is less than 20. For facets other than "format", only return facet
// values for documents where the format value is "paperback".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author'),
    jsearch.facet('MediaFormat','format')
      .othersWhere(jsearch.byExample({format: 'paperback'}))],
    jsearch.documents()
      .where(jsearch.byExample({author: 'Mark Twain'})))
  .where(jsearch.byExample({price: {$lt: 20}}))
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="thisWhere" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>
     Specify a query to apply only to this facet.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="queries" type="cts.query">
       One or an array of cts.query objects.
     </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets from all values of the "author" JSON property, but only
// generate facets from the "format" JSON property from documents where
// the "format" JSON property value is "paperback".
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author'),
    jsearch.facet('MediaFormat','format')
      .thisWhere(jsearch.byExample({format: 'paperback'}))])
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

 <apidoc:method name="groupInto" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>Groups facet values into buckets between bound values
       as in a <code>ValuesSearch</code> definition.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="bounds" type="bucketDefinition">
        Defines the boundary values separating the buckets. A bucket
        definition can be an array of boundary values or an array of
        (bucketNames, boundaryValue) pairs. For geospatial buckets,
        a boundary value can be an object with <code>lat</code> and
        <code>lon</code> properties. Helper functions are available for
        creating bucket definitions; for details, see the Usage Notes.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
    <p>You can create buckets using the <code>jsearch.makeBucket</code>
     or <code>jsearch.makeHeatMap</code> helper functions.
    </p><p>
      Each bucket includes the previous boundary and excludes the 
      following boundary. To assign names to the buckets, alternate
      calls to <code>jsearch.bucketName</code> with the bound values.
      Empty buckets are thrown away by default, so it can be
      efficient to estimate bounds instead of determining precisely
      the smallest and largest bound. You can use 
      <code>jsearch.makeHeatMap</code> to group geospatial values 
      into a heatmap. 
    </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2376195'>Grouping Values and Facets Into Buckets</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Group facet values into buckets using the generated default bucket names.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
  jsearch.facet('price')
    .groupInto([
      jsearch.bucketName(), 10,
      jsearch.bucketName(), 20,
      jsearch.bucketName()])
  ).result()

/* The result is similar to the following:

{"facets": {
  "price": {
    "x < 10": {
      "value": {
        "minimum": 8,
        "maximum": 9,
        "upperBound": 10
      },
      "frequency": 2
    },
    "10 <= x < 20": {
      "value": {
        "minimum": 10,
        "maximum": 18,
        "lowerBound": 10,
        "upperBound": 20
      },
      "frequency": 4
    },
    "20 <= x": {
      "value": {
        "minimum": 20,
        "maximum": 30,
        "lowerBound": 20
      },
      "frequency": 2
    }
  }
} }
*/
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Group facet values into buckets with custom names.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
  jsearch.facet('Price','price')
    .groupInto([
      jsearch.bucketName('under $10'), 10,
      jsearch.bucketName('$10 to $19.99'), 20,
      jsearch.bucketName('over $20')
    ]))
  .where(cts.directoryQuery('/books/'))
  .result();

/* The result is similar to the following:

{"facets": {
  "Price": {
    "under $10": {
      "value": {
        "minimum": 8,
        "maximum": 9,
        "upperBound": 10
      },
      "frequency": 2
    },
    "$10 to $19.99": {
      "value": {
        "minimum": 10,
        "maximum": 18,
        "lowerBound": 10,
        "upperBound": 20
      },
      "frequency": 4
    },
    "over $20": {
      "value": {
        "minimum": 20,
        "maximum": 30,
        "lowerBound": 20
      },
      "frequency": 2
    }
  }
} }
*/
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="orderBy" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>Specifies the sort order for facet values,
       as in a ValuesSearch definition.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="sortKey" type="string">
       Specifies whether to sort on the "item" or "frequency".
     </apidoc:param>
     <apidoc:param name="direction" type="string">
	   Specifies whether to sort in "ascending" or "descending" order.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
     When you add an <code>orderBy</code> clause to a facet definition,
     the default output from <code>jsearch.facets</code> for that facet
     becomes an array of arrays instead of a JSON object. Each array item
     is of the form <code>[itemValue, frequency]</code> and the array
     items are ordered according to the <code>orderBy</code> configuration.
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2396455'>Sorting Facet Values with OrderBy</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets on the "author" property and order them by frequency.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets([
    jsearch.facet('Author', 'author').orderBy('frequency')])
  .where(jsearch.byExample({price: {$lt: 50}}))
  .result()

// Produces results of the following form:
//
// {"facets":{
//   "Author":[
//     ["Mark Twain", 4], 
//     ["John Steinbeck", 3], 
//     ["Robert Frost", 1]
//   ]
// }}
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="slice" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>Specifies a subsequence of values to retrieve
       as in a ValuesSearch definition.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="start" type="integer">
		    The zero-based index of the first value to return.
	   </apidoc:param>
       <apidoc:param name="end" type="integer">
		    The zero-based index of the value after the last value
		    to return.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2344980'>Returning a Result Subset</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Generate facets on the "author" JSON property, ordered by frequency.
// Return only the first 3 facets.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
    jsearch.facet('Author', 'author')
       .orderBy('frequency')
       .slice(0, 3)
  .where(jsearch.byExample({price: {$lt: 20}}))
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="map" object="FacetDefinition"
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>Specifies a function similar to Array.prototype.map()
       to apply to each value within the slice or the configuration for 
       the built-in mapper, as in a ValuesSearch definition.
   </apidoc:summary>
   <apidoc:params>
     <apidoc:param name="mapper" type="objectOrFuncRef">
       A configuration object for the built-in mapper, or a reference
       to a custom mapper function. See the Usage Notes for details.
	 </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
     <p>
       You can pass in either a configuration object for the built-in
       mapper or a function reference to a custom mapper. The built-in
       mapper or your custom mapper is applied to each value in the
       current slice of values from a lexicon or range index.
     </p><p>
       The built-in mapper configuration object can have the following 
       properties:
     </p>
     <blockquote><dl>
       <dt><code>frequency</code></dt>
       <dd>One of the string values "fragment", "item", or "none" (default). 
         This setting controls  whether to report the number of documents
         (that is, the fragments) containing the values, the number of 
         occurrences of each value (that is, the items), or to omit the 
         frequency. The default is "none".
       </dd>
       <dt><code>names</code></dt>
       <dd>Specify a name for the values and for the frequency (if enabled). 
         If <code>names</code> is specified, the built-in mapper returns an 
         object for each value with the names as properties. If the frequency            is specified but not the name, the built-in mapper returns an array 
         for each value. The frequency name should appear after the value
         name. For example: <code>{names: [valName, freqName]}</code>.
         See the example, below.
       </dd>
     </dl></blockquote>
     <p>An empty configuration object causes the built-in mapper
       to return the values array unchanged.
     </p><p>
       A custom mapper should have the following signature:
     </p><p>
       <code>function (currentItem)</code>
     </p><p>
      Where <em>currentItem</em> is the current index value to act on.
      For example, a string if generating facets on a string-typed lexicon
      or index. If the function returns a value, the value is added to
      the results array or iterator.
     </p><p>You cannot use this method in conjunction with
      <code>FacetDefinition.reduce</code>.
     </p>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use the built-in mapper to suppress the inclusion of counts 
// in returned facet data.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
    jsearch.facet('Author', 'author').map({frequency: 'none'}))
  .where(cts.directoryQuery('/books/'))
  .result()

// Produces results similar to the following:
// {"facets": {
//   "Author": [
//     "John Steinbeck", 
//     "Mark Twain", 
//     "Robert Frost"
//   ]
// }}
   ]]></pre></apidoc:example>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
// Use a custom mapper over a string-typed index to convert the
// generated facet values to lower case.
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
    jsearch.facet('Author', 'author')
           .map(function (currentItem) {
                  return fn.lowerCase(currentItem)
                }
            ))
  .where(cts.directoryQuery('/books/'))
  .result()

// Produces results similar to the following:
// {"facets": {
//   "Author": [
//     "john steinbeck", 
//     "mark twain", 
//     "robert frost"
//   ]
// }}
   ]]></pre></apidoc:example>
  </apidoc:method>

  <apidoc:method name="reduce" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>Specifies a function similar to Array.prototype.reduce()
       to apply to each value within the slice or a configuration object
       for the built-in reducer, as in a ValuesSearch definition.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="reducer" type="function">
		    The reducing function.
	   </apidoc:param>
       <apidoc:param name="seed" type="anyValue">
		    The initial reduction passed to the reducing function.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
     <p>You can pass in either a configuration object for the built-in
      reducer or a function reference to a custom reducer. The built-in
      reducer configuration object can have the following properties:</p>
     <blockquote><dl>
       <dt><code>frequency</code></dt>
       <dd>One of the string values "fragment", "item", or "none" (default).
         This setting controls whether or not to include the number of
         occurrences of each value. Fragment frequency is the number
         of fragments (documents) containing each value. Item frequency
         is the number occurrences of each value. Defaults to none.</dd>
     </dl></blockquote>
     <p>
      When returning frequencies, the built-in reducer returns an 
      object with the serialized value (or bucket name when using 
      <code>groupInto</code>) as the key and the frequency as the value.
     </p><p>
     The reducer function should have the following signature:
     </p><p>
       <code>function (prev, current, index, state)</code>
     </p><p>Where the parameters have the following contents:</p>
     <blockquote><dl>
       <dt><code>prev</code></dt>
       <dd>The value returned by the previous call, or the
         seed value on the first call.</dd>
       <dt><code>current</code></dt>
       <dd>The current value.</dd>
       <dt><code>index</code></dt>
       <dd>The number of the current value.</dd>
       <dt><code>state</code></dt>
       <dd>A state object with a boolean-valued <code>isLast</code>>
         property that indicated the last call. You can set it to
         true to prematurely halt the reduction.</dd>
     </dl></blockquote>
     <p>
      The return from the last call becomes the final reduced result.
     </p><p>
      You cannot use this method in conjunction with
      <code>FacetDefinition.map</code>.
     </p> 
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2349222'>Transforming Results with Map and Reduce</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
  </apidoc:method>

  <apidoc:method name="withOptions" object="FacetDefinition" 
	  bucket="JavaScript Library Modules"
	  category="JavaScript Search (jsearch)" subcategory="FacetDefinition">
   <apidoc:summary>
     Configure advanced options for facet generation.
   </apidoc:summary>
   <apidoc:params>
       <apidoc:param name="option" type="object">
		    The configuration object for enabling special features
		    of the values search.
	   </apidoc:param>
   </apidoc:params>
   <apidoc:return>FacetDefinition</apidoc:return>
   <apidoc:usage>
     You can specify the following properties in the configuration object:
     <blockquote><dl>
       <dt><code>values</code></dt>
       <dd>An array of string options to pass through to 
         <code>cts.values</code>, <code>cts.valueMatch</code>,
         <code>cts.valueRanges</code>, or <code>cts.geospatialBoxes</code>
         for fine-tuning the configuration from the other values search 
         clauses.</dd>
       <dt><code>qualityWeight</code></dt>
       <dd>A number specifying the weight for the search.</dd>
       <dt><code>forestNames</code></dt>
       <dd>An array of strings for restricting the query to the values of 
         documents in the specified forests.</dd>
     </dl></blockquote>
   </apidoc:usage>
   <apidoc:see-also-list>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2326946'>Using Options to Control a Query</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
     <apidoc:see-also>
 <a href='#display.xqy?fname=http://pubs/6.0doc/xml/search-dev-guide/javascript.xml%2342548'>Including Facets in Search Results</a> in the <em>Search Developer's Guide</em>
     </apidoc:see-also>
   </apidoc:see-also-list>
   <apidoc:example><pre xml:space="preserve"><![CDATA[
const jsearch = require('/MarkLogic/jsearch.sjs');
jsearch.facets(
    jsearch.facet('Author', 'author')
       .slice(0, 3)
       .withOptions({qualityWeight: 1.0})
  .where(jsearch.byExample({price: {$lt: 20}}))
  .result()
   ]]></pre></apidoc:example>
  </apidoc:method>
</apidoc:module>
