<apidoc:module name="semantics" category="Semantics" 
	xmlns:apidoc="http://marklogic.com/xdmp/apidoc" 
	xmlns="http://www.w3.org/1999/xhtml" lib="sem">
<apidoc:summary category="Semantics" subcategory="Semantic Functions">
<p>The semantic functions include functions that are built into MarkLogic 
Server as well as functions that are implemented in an XQuery library.
</p>
<span class="xquery">
 <p>To use the semantics XQuery library module as part of your own XQuery 
 module, include the following line in your XQuery prolog:
 </p>
 <pre xml:space="preserve"><![CDATA[
import module namespace sem = "http://marklogic.com/semantics"
       at "/MarkLogic/semantics.xqy";]]></pre>
 <p>The library namespace prefix <code>sem</code> is predefined in
 the server.</p>
</span>
<span class="javascript">
  <p>To use semantics library module functions in your JavaScript code, 
   include a <code>require</code> statement similar to the following in 
   your code:</p>
  <p><code>var sem = require("/MarkLogic/semantics.xqy");</code></p>
</span>
</apidoc:summary>
<apidoc:function name="rdf-parse" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function returns parsed <code>sem:triple</code> objects 
		from a text format or XML.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="in" type="item()">
		  The source to parse. This must either be a string or a 
		  node.
	  </apidoc:param>
	  <apidoc:param name="options" type="xs:string*" optional="true">
		  Parsing options. Only one each of the base, graph, 
		  override-graph, and format (ntriple, nquad, turtle, rdfxml, 
		  rdfjson, triplexml) options is allowed. Valid options 
		  include:
	<blockquote>
        <dl>
          <dt>
             <pre>base=URI</pre>
          </dt>
        <dd>
        A base URI to use during parsing.
		</dd>
          <dt>
             <pre>graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to quads with no explicit graph 
		specified in the data. Cannot be used with
		override-graph=URI (or an exception is thrown).
		</dd>
          <dt>
             <pre>override-graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to every quad, whether 
		specified in the data or not.  Cannot be used with
		graph=URI (or an exception is thrown).
        </dd>
          <dt>
             <pre>ntriple</pre>
          </dt>
        <dd>		
        Specify N-Triples format for input.
        </dd>
          <dt>
             <pre>nquad</pre>
          </dt>
        <dd>		
		Specify N-Quads format for input (default if the $in 
		paramater is a string). 
		</dd>
          <dt>
             <pre>turtle</pre>
          </dt>
        <dd>	
        Specify Turtle format for input. 
		</dd>
          <dt>
             <pre>rdfxml</pre>
          </dt>
        <dd>	
		Specify RDF/XML format for input (default if the $in 
		parameter is an element).
	    </dd>
		<dt>
             <pre>n3</pre>
          </dt>
        <dd>		
        Specify N3 format for input.
        </dd>
		<dt>
             <pre>trig</pre>
          </dt>
        <dd>		
        Specify TriG format for input.
        </dd>
          <dt>
             <pre>rdfjson</pre>
          </dt>
        <dd>	
        Specify RDF/JSON format for input. 
        </dd>
          <dt>
             <pre>triplexml</pre>
          </dt>
        <dd>	
		Specify <code>sem:triple</code> XML format for input, either a 
		single <code>sem:triple</code> element or multiple elements 
		under a root element.  If you use the <code>triplexml</code>
		option, you cannot specify a graph.
        </dd>
          <dt>
             <pre>repair</pre>
          </dt>
        <dd>			
		Specify to repair if possible, or discard individual 
		triples that do not parse correctly. Otherwise any 
		malformed input results in an exception.
        </dd>
       </dl>	
    </blockquote>     	
	</apidoc:param>
  </apidoc:params>
  <apidoc:return>sem:triple*</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
declare namespace rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#";
declare namespace dc = "http://purl.org/dc/elements/1.1/";
declare namespace v="http://www.w3.org/2006/vcard/";

sem:rdf-parse(
<rdf:Description rdf:about="urn:isbn:006251587X">
  <dc:title>Weaving the Web</dc:title>
  <dc:creator rdf:resource="http://www.w3.org/People/Berners-Lee/card#i"/>
</rdf:Description>,
"rdfxml")	  
 
 => 
sem:triple(
  sem:iri("urn:isbn:006251587X"), 
  sem:iri("http://purl.org/dc/elements/1.1/title"), 
  "Weaving the Web")
	
sem:triple(
  sem:iri("urn:isbn:006251587X"), 
  sem:iri("http://purl.org/dc/elements/1.1/creator"), 
  sem:iri("http://www.w3.org/People/Berners-Lee/card#i"))
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");

sem.rdfParse(fn.head(xdmp.unquote(
'<rdf:Description rdf:about="urn:isbn:006251587X" \n\
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" \n\
        xmlns:dc="http://purl.org/dc/elements/1.1/" \n\
        xmlns:v="http://www.w3.org/2006/vcard/">\n\
  <dc:title>Weaving the Web</dc:title>\n\
  <dc:creator rdf:resource="http://www.w3.org/People/Berners-Lee/card#i"/>\n\
</rdf:Description>')).root,
"rdfxml");	  
 
 => 
sem:triple(
  sem:iri("urn:isbn:006251587X"), 
  sem:iri("http://purl.org/dc/elements/1.1/title"), 
  "Weaving the Web")
	
sem:triple(
  sem:iri("urn:isbn:006251587X"), 
  sem:iri("http://purl.org/dc/elements/1.1/creator"), 
  sem:iri("http://www.w3.org/People/Berners-Lee/card#i"))
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
      
let $turtle-document := '
    @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
    @prefix dc: <http://purl.org/dc/elements/1.1/> .
    @prefix ex: <http://example.org/people/1.0/> .
  <http://www.w3.org/TR/rdf-syntax-grammar>
    dc:title "RDF/XML Syntax Specification (Revised)" ;
    ex:editor [
      ex:fullname "Dave Beckett";
      ex:homePage <http://purl.org/net/dajobe/>
    ] .'
return sem:rdf-parse($turtle-document, ("turtle", "repair") )

=>  
sem:triple(
  sem:iri("http://www.w3.org/TR/rdf-syntax-grammar"), 
  sem:iri("http://purl.org/dc/elements/1.1/title"), 
  "RDF/XML Syntax Specification (Revised)")
	
sem:triple(
  sem:iri("http://www.w3.org/TR/rdf-syntax-grammar"), 
  sem:iri("http://example.org/people/1.0/editor"),
  sem:blank("http://marklogic.com/semantics/blank/15118066541381804840"))
	
sem:triple(
  sem:blank("http://marklogic.com/semantics/blank/15118066541381804840"),
  sem:iri("http://example.org/people/1.0/fullname"), 
  "Dave Beckett")

sem:triple(
  sem:blank("http://marklogic.com/semantics/blank/15118066541381804840"),
  sem:iri("http://example.org/people/1.0/homePage"),
  sem:iri("http://purl.org/net/dajobe/"))
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
      
var turtleDocument = '\n\
    @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\
    @prefix dc: <http://purl.org/dc/elements/1.1/> .\n\
    @prefix ex: <http://example.org/people/1.0/> .\n\
  <http://www.w3.org/TR/rdf-syntax-grammar>\n\
    dc:title "RDF/XML Syntax Specification (Revised)" ;\n\
    ex:editor [\n\
      ex:fullname "Dave Beckett";\n\
      ex:homePage <http://purl.org/net/dajobe/>\n\
    ] .'
sem.rdfParse(turtleDocument, ["turtle", "repair"] );

=>  
sem.triple(
  sem.iri("http://www.w3.org/TR/rdf-syntax-grammar"), 
  sem.iri("http://purl.org/dc/elements/1.1/title"), 
  "RDF/XML Syntax Specification (Revised)")
	
sem.triple(
  sem.iri("http://www.w3.org/TR/rdf-syntax-grammar"), 
  sem.iri("http://example.org/people/1.0/editor"),
  sem.blank("http://marklogic.com/semantics/blank/15118066541381804840"))
	
sem.triple(
  sem.blank("http://marklogic.com/semantics/blank/15118066541381804840"),
  sem.iri("http://example.org/people/1.0/fullname"), 
  "Dave Beckett")

sem.triple(
  sem.blank("http://marklogic.com/semantics/blank/15118066541381804840"),
  sem.iri("http://example.org/people/1.0/homePage"),
  sem.iri("http://purl.org/net/dajobe/"))
    ]]></pre>
  </apidoc:example>

</apidoc:function>
<apidoc:function name="rdf-serialize" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function returns a string or json or XML serialization 
		of the provided triples.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="triples" type="sem:triple*">
		  The triples to serialize.
	  </apidoc:param>
	  <apidoc:param name="options" type="xs:string*" optional="true">
		  Parsing options. Only one of the format options is allowed. 
		  Valid option values include:
	<blockquote>
        <dl>
           <dt>
             <pre>ntriple</pre>
          </dt>
        <dd>
		Specify N-Triples format for output as an xs:string.
		</dd>
		    <dt>
             <pre>nquad</pre>
          </dt>
        <dd>
        Specify N-Quads format for output as an xs:string (default).
		</dd>
		    <dt>
             <pre>turtle</pre>
          </dt>
        <dd>
        Specify Turtle format for output as an xs:string.
		</dd>
		    <dt>
             <pre>rdfxml</pre>
          </dt>
        <dd>
        Specify RDF/XML format for output as an element.
        </dd>
		    <dt>
             <pre>rdfjson</pre>
          </dt>
        <dd>
		Specify JSON format for output as a json:object. Note: To 
		serialize a JSON string, manually call 
		<code>xdmp:to-json</code> on this object.
		</dd>    
		    <dt>
             <pre>n3</pre>
          </dt>
        <dd>		
        Specify N3 format for output as an xs:string.
        </dd>
		<dt>
             <pre>trig</pre>
          </dt>
        <dd>		
        Specify TriG format for output as an xs:string.
        </dd>
          <dt>
             <pre>triplexml</pre>
          </dt>
        <dd>
                Specify <code>sem:triple</code> XML format for output, either a 
		single <code>sem:triple</code> element or multiple elements 
		under a root element.  If you use the <code>triplexml</code>
		option, you cannot specify a graph.
		</dd>
	</dl>	
</blockquote>	
   	</apidoc:param>
  </apidoc:params>
  <apidoc:return>item()</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";

sem:rdf-serialize(
  (sem:triple(
     sem:iri("http://example.com/ns/directory#m"),
     sem:iri("http://example.com/ns/person#firstName"), "Michelle")))

=> 
    <http://example.com/ns/directory#m> 
	<http://example.com/ns/person#firstName> "Michelle" .
    ]]></pre>
  </apidoc:example>

    <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");

sem.rdfSerialize(
  (sem.triple(
     sem.iri("http://example.com/ns/directory#m"),
     sem.iri("http://example.com/ns/person#firstName"), "Michelle")));

=> 
    <http://example.com/ns/directory#m> 
	<http://example.com/ns/person#firstName> "Michelle" .
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
      
sem:rdf-serialize(
    sem:triple(sem:iri("http://example.com/ns/directory#m"),
	sem:iri("http://example.com/ns/person#firstName"),
	"Michelle"), "rdfxml")

=>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <rdf:Description rdf:about="http://example.com/ns/directory#m">
      <firstName rdf:datatype="http://www.w3.org/2001/XMLSchema#string" 
        xmlns="http://example.com/ns/person#">Michelle
      </firstName>
    </rdf:Description>
</rdf:RDF>
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");

sem.rdfSerialize(
    sem.triple(sem.iri("http://example.com/ns/directory#m"),
	sem.iri("http://example.com/ns/person#firstName"),
	"Michelle")), "rdfxml");

=>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <rdf:Description rdf:about="http://example.com/ns/directory#m">
      <firstName rdf:datatype="http://www.w3.org/2001/XMLSchema#string" 
        xmlns="http://example.com/ns/person#">Michelle
      </firstName>
    </rdf:Description>
</rdf:RDF>
    ]]></pre>
  </apidoc:example>

</apidoc:function>

<apidoc:function name="rdf-get" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function returns sem:triples from a specified location.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="location" type="xs:string">
		  The location of the document.
	  </apidoc:param>
	  <apidoc:param name="options" type="xs:string*" optional="true">
		  Parsing options.  Valid options include:
	<blockquote>
        <dl>
          <dt>
             <pre>base=URI</pre>
          </dt>
        <dd>
        A base URI to use during parsing.
		</dd>
          <dt>
             <pre>graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to quads with no 
		explicit graph specified in the data.  Cannot be used with
		override-graph=URI (or an exception is thrown).
		</dd>
          <dt>
             <pre>override-graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to every quad, whether 
		specified in the data or not.  Cannot be used with
		graph-URI (or an exception is thrown).
        </dd>
          <dt>
             <pre>ntriple</pre>
          </dt>
        <dd>		
        Specify N-Triples format for input.
        </dd>
          <dt>
             <pre>nquad</pre>
          </dt>
        <dd>		
        Specify N-Quads format for input (default). 
		</dd>
          <dt>
             <pre>turtle</pre>
          </dt>
        <dd>	
        Specify Turtle format for input. 
		</dd>
          <dt>
             <pre>rdfxml</pre>
          </dt>
        <dd>	
        Specify RDF/XML format for input.
	    </dd>
          <dt>
             <pre>rdfjson</pre>
          </dt>
        <dd>	
        Specify RDF/JSON format for input. 
        </dd>
          <dt>
             <pre>n3</pre>
          </dt>
        <dd>		
        Specify N3 format for input.
        </dd>
		<dt>
             <pre>trig</pre>
          </dt>
        <dd>		
        Specify TriG format for input.
        </dd>
          <dt>
             <pre>repair</pre>
          </dt>
        <dd>			
		Specify to repair if possible, or discard individual triples 
		that do not parse correctly. Otherwise any malformed input 
		results in an exception.
  </dd>
           <dt>
             <pre>triplexml</pre>
          </dt>
        <dd>
                Specify <code>sem:triple</code> XML format for input, either a 
		single <code>sem:triple</code> element or multiple elements 
		under a root element.  If you use the <code>triplexml</code>
		option, you cannot specify a graph.
		</dd>
      </dl>	
    </blockquote>     
	</apidoc:param>
	<apidoc:param name="http-opts" type="element()?" optional="true">
		An options node as described for the function 
		<a href="#xdmp:http-get"><code>xdmp:http-get</code></a>.
   </apidoc:param>
   </apidoc:params>
  <apidoc:return>sem:triple*</apidoc:return>
  <apidoc:privilege>
    <p><code>http://marklogic.com/xdmp/privileges/xdmp-document-get</code></p> 
  </apidoc:privilege>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
 
sem:rdf-get('C:/Data/Semantics/example.ttl', "turtle")
	
=> 
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#shipped"), xs:date("2013-05-20"))
    
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#quantity"), 4)
    
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#invoiced"), fn:false())
     
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#costPerItem"), 10.5)
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
 
sem.rdfGet('C:/Data/Semantics/example.ttl', "turtle");
	
=> 
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#shipped"), xs:date("2013-05-20"))
    
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#quantity"), 4)
    
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#invoiced"), fn:false())
     
    sem:triple(sem:iri("http://example.com/ns/data#item342"),
	sem:iri("http://example.com/ns/details#costPerItem"), 10.5)
    ]]></pre>
  </apidoc:example>

</apidoc:function>
 <apidoc:function name="rdf-insert" lib="sem" category="Semantics" subcategory="Semantic Functions">
	 <apidoc:summary>
		 This function inserts triples into a specified database as 
		 one or more <code>sem:triples</code> documents. It also 
		 creates graph metadata for the graph specified by the 
		 "graph" or "override-graph=URI" option. 
		 This is an update function that returns the document URIs of 
		 inserted documents.
	 </apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="triples" type="sem:triple*" class="xquery">
		  The triples to insert.
	  </apidoc:param>
	  <apidoc:param name="triples" 
		  type="sem.triple | Sequence | Array" class="javascript">
		  The triples to insert.  
	  </apidoc:param>
	  <apidoc:param name="options" type="xs:string*" optional="true">
		  Insertion options. Valid options values include:
	<blockquote>
        <dl>
          <dt>
             <pre>override-graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to every quad, whether 
		specified in the data or not.
		</dd>
		  <dt>
             <pre>directory=URI</pre>
          </dt>
        <dd>
        The database directory path.
		</dd>
		</dl>
	</blockquote>	
	</apidoc:param>
	<apidoc:param class="xquery" name="permissions" 
                type="element" optional="true">
	        Security permission elements corresponding to the permissions 
	        for the document.
         </apidoc:param>
         <apidoc:param class="javascript" name="permissions" type="Object[]"
                optional="true">
		Security permission objects corresponding to the permissions 
		for the document.    
	</apidoc:param>
	<apidoc:param name="collections" type="xs:string*" 
		optional="true">
		Additional collections to set on inserted documents. If you use 
		the collections argument when inserting triples, no graph 
		document will be created for these collections.
	</apidoc:param>
	<apidoc:param name="quality" type="xs:int?" 
		optional="true">
		The quality setting for inserted documents.
	</apidoc:param>
	<apidoc:param name="forest-ids" type="xs:unsignedLong*" 
		optional="true">
		The forest IDs to use for inserted documents.
	</apidoc:param>
  </apidoc:params>
  <apidoc:return>xs:string*</apidoc:return>
  <apidoc:usage>
	  Using additional collections with <code>sem:rdf-insert</code> in the 
	  context of SPARQL Update can result in undefined behavior.
  </apidoc:usage>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";

sem:rdf-insert(sem:triple(sem:iri("http://example.com/ns/directory#m"),
	sem:iri("http://example.com/ns/person#firstName"), "Michael"))
 
 =>
   /triplestore/74521a908ece2074.xml
 
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");

sem.rdfInsert(
  sem.triple(
        sem.iri("http://example.com/ns/directory#m"),
	sem.iri("http://example.com/ns/person#firstName"), "Michael"));
 
 =>
   /triplestore/74521a908ece2074.xml
 
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="rdf-load" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function inserts an RDF document from a specified location
		into the designated database. It also creates the graph 
		metadata for the graph specified by the "graph=URI" or 
		"override-graph=URI" option.
		This is an update function that returns the document URIs of 
		inserted documents.
</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="location" type="xs:string">
		  The location of the input file. If the file is not a 
		  recognized format, an exception is thrown.
	  </apidoc:param>
    <apidoc:param name="options" type="xs:string*" optional="true">
	    Parsing options: Only one base, or graph, or override-graph 
	    option along with one format option (ntriple, nquad, turtle, 
	    trig, n3, rdfxml, or rdfjson) is allowed. The graph and 
	    override-graph options cannot be used together. Valid options 
	    include:
	<blockquote>
        <dl>
          <dt>
             <pre>base=URI</pre>
          </dt>
        <dd>
        A base URI to use during parsing.
		</dd>
          <dt>
             <pre>graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to quads with no 
		explicit graph specified in the data. Cannot be used with
		override-graph=URI (or an exception is thrown).
		</dd>
          <dt>
             <pre>override-graph=URI</pre>
          </dt>
        <dd>
		The graph/context value to give to every quad, 
		whether specified in the data or not. Cannot be used with
		graph=URI (or an exception is thrown).
        </dd>
		  <dt>
             <pre>directory=URI</pre>
          </dt>
        <dd>
        The database directory path.
		</dd>
          <dt>
             <pre>ntriple</pre>
          </dt>
        <dd>		
        Specify N-Triples format for input.
        </dd>
          <dt>
             <pre>nquad</pre>
          </dt>
        <dd>		
        Specify N-Quads format for input (default). 
		</dd>
          <dt>
             <pre>turtle</pre>
          </dt>
        <dd>	
        Specify Turtle format for input. 
		</dd>
          <dt>
             <pre>rdfxml</pre>
          </dt>
        <dd>	
        Specify RDF/XML format for input.
	    </dd>
          <dt>
             <pre>rdfjson</pre>
          </dt>
        <dd>	
        Specify RDF/JSON format for input. 
        </dd>
		 <dt>
             <pre>triplexml</pre>
         </dt>
        <dd>	
		Specify <code>sem:triple</code> XML format for input, either a 
		single <code>sem:triple</code> element or multiple elements 
		under a root element.  If you use the <code>triplexml</code>
		option, you cannot specify a graph.
        </dd>
          <dt>
             <pre>n3</pre>
          </dt>
        <dd>		
        Specify N3 format for input.
        </dd>
		<dt>
             <pre>trig</pre>
          </dt>
        <dd>		
        Specify TriG format for input.
        </dd>
          <dt>
             <pre>repair</pre>
          </dt>
        <dd>			
		Specify to repair if possible, or discard individual triples 
		that do not parse correctly. Otherwise any malformed input 
		results in an exception.
        </dd>
      </dl>	
    </blockquote>  
	</apidoc:param>
	<apidoc:param name="http-opts" type="element()?" optional="true">
		An options node as described for the function 
		<a href="#xdmp:http-get"><code>xdmp:http-get</code></a>.
	</apidoc:param>
	<apidoc:param name="permissions" type="item()*" 
		optional="true">
		Permissions to apply to the inserted documents.
                When run in an XQuery context, the permissions are a sequence of
	        XML elements (sec:permission). When importing this module into 
	        a Server-Side JavaScript context, the permissions are an array
	        of Objects.
	</apidoc:param>
	<apidoc:param name="collections" type="xs:string*" optional="true">
		Additional collections to set on inserted documents. If you use the 
		collections argument when inserting triples, no graph document 
		will be created for these collections.</apidoc:param>
	<apidoc:param name="quality" type="xs:int?" optional="true">
		The quality setting for inserted documents.
	</apidoc:param>
	<apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
		The forest-ids to use for inserted documents.
	</apidoc:param>
  </apidoc:params>
  <apidoc:return>xs:string*</apidoc:return>
  <apidoc:usage>Using additional collections with <code>sem:rdf-load</code> 
    in the context of SPARQL Update can result in undefined behavior.
  </apidoc:usage>
  <apidoc:privilege>
    <p><code>http://marklogic.com/xdmp/privileges/xdmp-document-get</code></p> 
  </apidoc:privilege>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
 
sem:rdf-load('C:/data/example.rdf', "rdfxml")
 
 => 
    /triplestore/fbd28af1471b39e9.xml
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");
 
sem.rdfLoad('C:/data/example.rdf', "rdfxml")
 
 => 
    /triplestore/fbd28af1471b39e9.xml
]]></pre></apidoc:example>

<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
	  
sem:rdf-load(
    'C:/data/books.ttl',
    ("turtle", "graph=http://marklogic.com/semantics/sb/books1/"),
    (),
    xdmp:permission("demo-reader", "read")
    )
	
=>
    /triplestore/fbd28af1471b39e9.xml
  (: permissions on graph for demo-reader now set to "read" :)
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");
	  
sem.rdfLoad(
    'C:/data/books.ttl',
    ["turtle", "graph=http://marklogic.com/semantics/sb/books1/"],
    null,
    xdmp.permission("demo-reader", "read")
    );
    
=>
    /triplestore/fbd28af1471b39e9.xml
// permissions on graph for demo-reader now set to "read" 
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="database-nodes" lib="sem" category="Semantics" subcategory="Semantic Functions">
  <apidoc:summary>
	  This function returns database nodes backing given triples. 
	  Any given cts:triple may be backed by zero, one, or multiple 
	  database nodes.
</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="triples" type="sem:triple*">
		  The triples to locate.
	  </apidoc:param>
	  <apidoc:param name="options" type="xs:string*" optional="true">
		  Matching options. Valid options include:
        <blockquote>
        <dl>
          <dt>
             <pre>=</pre>
          </dt>
	  <dd>Specify equality matching (following the rules of the 
		  $operator argument to cts:triples).</dd>
          <dt>
             <pre>sameTerm</pre>
          </dt>
	  <dd>Specify sameTerm matching (following the rules of the 
		  $operator argument to cts:triples) (if neither '=' nor 
		  'sameTerm' are specified, this option gets used by default).
	  </dd>
          <dt>
             <pre>all</pre>
          </dt>
	  <dd>Specify to return all triple-backing nodes, no matter where 
		  or in what format they occur in MarkLogic 7, only 
		  <code>sem:triple</code> elements are recognized as triples). 
		  If this option is not specified, only 
		  <code>sem:triple</code> elements found in documents that 
		  have the root element of sem:triples will be returned.</dd>
          <dt>
             <pre>quads</pre>
          </dt>
	  <dd>Specify to examine the graph component in the passed 
		  in <code>sem:triples</code> and use it to match.</dd>
        </dl>
    </blockquote>  
	</apidoc:param>
	<apidoc:param name="query" type="cts:query?" optional="true">
		A cts:query to limit the scope of nodes returned.
	</apidoc:param>
      
   </apidoc:params>
  <apidoc:return>node()*</apidoc:return>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
 
(: this program deletes data--use with care :)
sem:database-nodes($triple-list) ! xdmp:node-delete(.)
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");
 
// this program deletes data--use with care 

var triples = sem.sparql('<sparql query that selects triples to delete>');
for (var x in sem.databaseNodes(triples)) {
   xdmp.nodeDelete(x); };
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="graph" lib="sem" category="Semantics" subcategory="Semantic Functions">
	  <apidoc:summary>
		  This function returns all triples from a named graph 
		  in the database.
	  </apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="graphname" type="sem:iri">
		  The name of the graph to retrieve.
	  </apidoc:param>
  </apidoc:params>
  <apidoc:return>sem:triple*</apidoc:return>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
 
sem:graph(sem:iri("http://marklogic.com/semantics#default-graph"))
 
 => (: returns all triples from the default graph :)
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
 
sem.graph(sem.iri("http://marklogic.com/semantics#default-graph"));
 
=> 
returns all triples from the default graph 
]]></pre></apidoc:example>

<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
    sem:graph(sem:iri("bookgraph"))

 => (: returns all triples from a named graph as triples :)
 
    sem:triple(sem:iri("urn:isbn:006251587X"), 
	sem:iri("http://purl.org/dc/elements/1.1/title"),
	"Weaving the Web", sem:iri("bookgraph"))
 
    sem:triple(sem:iri("urn:isbn:9780080540160"),
    sem:iri("http://purl.org/dc/elements/1.1/title"),
	"Query XML,&#10;XQuery, XPath, and SQL/XML in context", 
	sem:iri("bookgraph"))
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
sem.graph(sem.iri("bookgraph"));

=> 
returns all triples from a named graph as triples 

    sem:triple(sem:iri("urn:isbn:006251587X"), 
	sem:iri("http://purl.org/dc/elements/1.1/title"),
	"Weaving the Web", sem:iri("bookgraph"))
 
    sem:triple(sem:iri("urn:isbn:9780080540160"),
    sem:iri("http://purl.org/dc/elements/1.1/title"),
	"Query XML,&#10;XQuery, XPath, and SQL/XML in context", 
	sem:iri("bookgraph"))
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="graph-insert" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function inserts triples into a named graph, 
		creating the graph if necessary. It also creates the graph 
		metadata for the graph specified by the "graphname" option. 
		This is an update function that returns document IDs.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="graphname" type="sem:iri">The name of 
		  the graph to insert triples into.</apidoc:param>
	  <apidoc:param name="triples" type="sem:triple*">The set of 
		  triples to insert.</apidoc:param>
	  <apidoc:param name="permissions" type="item()*" optional="true">
		  Permissions to apply to the inserted documents.	    
		  When run in an XQuery context, the permissions are a 
		  sequence of XML elements (sec:permission). When importing 
		  this module into a Server-Side JavaScript context, the 
		  permissions are an array of Objects.
	  </apidoc:param>
	  <apidoc:param name="collections" type="xs:string*" 
		  optional="true">Additional collections to set on inserted 
		  documents. If you use the collections argument when inserting 
	      triples, no graph document will be created for these collections.
		  When additional collections are set, inserted triples will 
		  exist in multiple collections.</apidoc:param>
	  <apidoc:param name="quality" type="xs:int?" 
		  optional="true">The quality setting to use for inserted 
		  documents.</apidoc:param>
	  <apidoc:param name="forest-ids" type="xs:unsignedLong*" 
		  optional="true">The forest-ids to use when inserting 
		  documents.</apidoc:param>
  </apidoc:params>
  <apidoc:return>xs:string*</apidoc:return>
  <apidoc:usage>
	  Using additional collections with <code>graph-insert</code> 
	  in the context of SPARQL Update can result in undefined behavior.
  </apidoc:usage>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
     
sem:graph-insert(sem:iri('bookgraph'), 
   sem:triple(sem:iri('urn:isbn:9780080540160'),
              sem:iri('http://purl.org/dc/elements/1.1/title'), 
              "Query XML,XQuery, XPath, and SQL/XML in context"))
			 
=>
    /triplestore/2c78915c5854b0f8.xml
    ]]></pre></apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");
     
sem.graphInsert(sem.iri('bookgraph'), 
   sem.triple(sem.iri('urn:isbn:9780080540160'),
              sem.iri('http://purl.org/dc/elements/1.1/title'), 
              "Query XML,XQuery, XPath, and SQL/XML in context"));
			 
=>
    /triplestore/2c78915c5854b0f8.xml
    ]]></pre></apidoc:example>

   <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
   at "/MarkLogic/semantics.xqy";

 let $string := '
    <urn:isbn:006251587X> <http://purl.org/dc/elements/1.1/creator>
    <http://www.w3.org/People/Berners-Lee/card#i> .
    <urn:isbn:006251587X> <http://purl.org/dc/elements/1.1/title> 
	"Weaving the Web" .
    <http://www.w3.org/People/Berners-Lee/card#i> 
    <http://www.w3.org/2006/vcard/title>"Director" .'

 let $triples := sem:rdf-parse($string, "ntriple")
 let $i := sem:graph-insert(sem:iri("bookgraph"), $triples, (), "smGraph")
 return(fn:collection("smGraph")//sem:triple);
			 
=> (: returns triples as nodes :)
 <sem:triple xmlns:sem="http://marklogic.com/semantics">
   <sem:subject>urn:isbn:006251587X</sem:subject>
   <sem:predicate>http://purl.org/dc/elements/1.1/creator</sem:predicate>
   <sem:object>http://www.w3.org/People/Berners-Lee/card#i</sem:object>
 </sem:triple>
 <sem:triple xmlns:sem="http://marklogic.com/semantics">
   <sem:subject>urn:isbn:006251587X</sem:subject>
   <sem:predicate>http://purl.org/dc/elements/1.1/title</sem:predicate>
   <sem:object datatype="http://www.w3.org/2001/XMLSchema#string">
    Weaving the Web</sem:object>
 </sem:triple>
 <sem:triple xmlns:sem="http://marklogic.com/semantics">
   <sem:subject>http://www.w3.org/People/Berners-Lee/card#i</sem:subject>
   <sem:predicate>http://www.w3.org/2006/vcard/title</sem:predicate>
   <sem:object datatype="http://www.w3.org/2001/XMLSchema#string">
   Director</sem:object>
 </sem:triple>
 <sem:triple xmlns:sem="http://marklogic.com/semantics">
   <sem:subject>urn:isbn:9780080540160</sem:subject>
   <sem:predicate>http://purl.org/dc/elements/1.1/title</sem:predicate>
   <sem:object datatype="http://www.w3.org/2001/XMLSchema#string">
   Query XML,XQuery, XPath, and SQL/XML in context</sem:object>
 </sem:triple>
    ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="graph-delete" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function deletes a named graph, and its graph 
	    document containing metadata, from the database. This is an update 
	    function that deletes documents with a root element of 
	    <code>sem:triples</code>.  All other documents are not affected.
    </apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="graphname" type="sem:iri">The name of the graph 
		  to delete.</apidoc:param>
  </apidoc:params>
  <apidoc:return>empty-sequence()</apidoc:return>
  <apidoc:usage>The default graph document is restored after you use 
  <code>graph-delete</code> to delete graphs.</apidoc:usage>
<apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
  
sem:graph-delete(sem:iri("bookgraph")) 
]]></pre></apidoc:example>

<apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
declareUpdate();
var sem = require("/MarkLogic/semantics.xqy");
sem.graphDelete(sem.iri("bookgraph")); 
]]></pre></apidoc:example>

</apidoc:function>

<apidoc:function name="query-results-serialize" lib="sem" 
                 category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function implements the W3C SPARQL Query Results 
	format. Any value sequence returned by <code>sem:sparql</code> can 
	be passed into this function. The result will be the W3C SPARQL 
	Results format, in either XML or JSON format.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="results" type="option">
		  The results of calling a SPARQL query.
	  </apidoc:param>
	<apidoc:param name="options" type="xs:string*" optional="true">
		One of 'xml' (default) or 'json'.
	</apidoc:param>
  </apidoc:params>
  <apidoc:return>query-results-serialize($results)</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
    
sem:query-results-serialize(sem:sparql('
    PREFIX foaf: <http://xmlns.com/foaf/0.1/>
    SELECT ?name WHERE { ?alum foaf:schoolHomepage <http://www.ucsb.edu/> .
                         ?alum foaf:knows ?person .
                         ?person foaf:name ?name }
'))

=>
  <sparql xmlns="http://www.w3.org/2005/sparql-results#">
    <head>
      <variable name="name">
      </variable>
    </head>
    <results>
      <result>
        <binding name="name">
           <literal datatype="http://www.w3.org/2001/XMLSchema#string">
            Karen Schouten
           </literal>
        </binding>
      </result>
      <result>
        <binding name="name">
           <literal datatype="http://www.w3.org/2001/XMLSchema#string">
           Nick Aster
           </literal>
        </binding>
      </result>
    </results>
  </sparql>
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
    
sem.queryResultsSerialize(sem.sparql( 
    'PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\
    SELECT ?name WHERE { ?alum foaf:schoolHomepage <http://www.ucsb.edu/> .\n\
                         ?alum foaf:knows ?person .\n\
                         ?person foaf:name ?name } ')); 

=>
  <sparql xmlns="http://www.w3.org/2005/sparql-results#">
    <head>
      <variable name="name">
      </variable>
    </head>
    <results>
      <result>
        <binding name="name">
           <literal datatype="http://www.w3.org/2001/XMLSchema#string">
            Karen Schouten
           </literal>
        </binding>
      </result>
      <result>
        <binding name="name">
           <literal datatype="http://www.w3.org/2001/XMLSchema#string">
           Nick Aster
           </literal>
        </binding>
      </result>
    </results>
  </sparql>
    ]]></pre>
  </apidoc:example>

</apidoc:function>

<apidoc:function name="curie-expand" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function expands a CURIE (Compact URI) 
		into a <code>sem:iri</code> object. This raises SEM-UNKNOWNPREFIX if no 
		mapping is available. For more information about the default 
		prefixes, see <a href="#sem:prefixes">sem:prefixes</a>. 
	</apidoc:summary>
  <apidoc:params>
    <apidoc:param name="curie" type="xs:string">A CURIE string.</apidoc:param>
    <apidoc:param name="mapping" type="map:map" optional="true">An 
	    optional set of prefix mappings. If not specified, a default 
	    set of prefixes is used.</apidoc:param>
  </apidoc:params>
  <apidoc:return>sem:iri</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
    
sem:curie-expand("foaf:person2")
	
(: expands and returns the sem:iri object :)
=>
    http://xmlns.com/foaf/0.1/person2
]]></pre></apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
    
sem.curieExpand("foaf:person2");
	
// expands and returns the sem.iri object 
=> 
    http://xmlns.com/foaf/0.1/person2
]]></pre></apidoc:example>

</apidoc:function>
<apidoc:function name="curie-shorten" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function shortens an IRI into a CURIE 
		(Compact URI) into a <code>sem:iri</code> object. Returns the IRI string 
		unchanged if no mapping is available.</apidoc:summary>
  <apidoc:params>
    <apidoc:param name="iri" type="sem:iri">An IRI.</apidoc:param>
    <apidoc:param name="mapping" type="map:map" optional="true">An optional 
	    set of prefix mappings. If not specified, a default set of 
	    prefixes is used.</apidoc:param>
  </apidoc:params>
  <apidoc:return>xs:string</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
      
sem:curie-shorten(sem:iri("http://xmlns.com/foaf/0.1/person2"))

  (: shortens and returns the CURIE (Compact URI) as a string :)
  =>
foaf:person2
    ]]></pre>
  </apidoc:example>

    <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
      
sem.curieShorten(sem.iri("http://xmlns.com/foaf/0.1/person2"));

// shortens and returns the CURIE (Compact URI) as a string 
=>
foaf:person2
    ]]></pre>
  </apidoc:example>

</apidoc:function>
<apidoc:function name="prefixes" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function returns a set of prefix mappings for 
		use with CURIE processing. Calling this function returns the 
		internal set of default prefixes. The default mappings include 
		prefixes that are widely used and agreed upon, including 
		"cc" (Creative Commons), "dc" (Dublin Core), 
		"dcterms" (Dublin Core Terms), "dbpedia" (dbpedia resources), 
		"dbpedia-owl" (dbpedia ontology), "geonames" (geonames 
		ontology), "foaf" (FOAF), "media" (MediaRSS), "owl" (OWL), "
		rdf" (RDF), "product" (productV2), "rdfs" (RDF Schema), 
		"skos" (SKOS), "vcard" (VCard vocab), "void" (Vocabulary 
		of Interlinked Datasets), "wikidata" (wikidata entities), 
		"xhtml" (XHTML), and "xs" (XML Schema).
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="prefixdef" type="xs:string?">A string specifying 
		  prefixes in RDFa @prefix format 
		  ("prefix: http://base1 prefix2: http://base2").
	  </apidoc:param>
	  <apidoc:param name="include-common" type="xs:boolean?" 
		  optional="true">Whether to include the default set of 
		  mappings. The default is true.
	  </apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
   at "/MarkLogic/semantics.xqy";

let $prefixes := sem:prefixes("ex: http://www.example.com/# 
               schema: http://schema.org/")
return sem:curie-expand("ex:prefLabel", $prefixes)
	
=>  (: returns an IRI :)
    <http://www.example.com/#prefLabel>
	]]></pre></apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");

var prefixes = sem.prefixes("ex: http://www.example.com/# \n\
	schema: http://schema.org/"); 
sem.curieExpand("ex:prefLabel", prefixes) 
	
(: returns an IRI :)
=>
    http://example.com/#prefLabel	
    ]]></pre></apidoc:example>

</apidoc:function>
<apidoc:function name="rdf-builder" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function returns a function that builds triples 
		from CURIE and blank node syntax. The resulting function takes 
		three string arguments, representing subject, predicate, 
		and object respectively, which returns a sem:triple object 
		using the graph and prefix mappings passed in to the call to 
		<code>sem:rdf-builder</code>. 
		Blank nodes specified with a leading underscore (_) will 
		be assigned blank node identifiers, and will maintain that 
		identity across multiple invocations; for example, 
		"_:person1" will refer to the same node as a later 
		invocation that also mentions "_:person1". In the 
		predicate position, the special value of "a" will be 
		interpreted as the same as "rdf:type".</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="prefixes" type="map:map?" optional="true">An 
		  optional set of prefix mappings.</apidoc:param>
	  <apidoc:param name="graph" type="sem:iri?" optional="true">The graph 
		  value in which to place triples. Defaults to 
		  "http://marklogic.com/semantics#default-graph".</apidoc:param>
  </apidoc:params>
  <apidoc:return>function(item(),item(),item()) as sem:triple</apidoc:return>
  <apidoc:usage>
	  If you pass in a string to <code>sem:rdf-builder</code>, it will be 
	  interpreted as a CURIE. If you want it to be interpreted as an IRI, 
	  then cast the string to an IRI using <code>sem:iri</code>.
  </apidoc:usage>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
      
let $fac := sem:rdf-builder()
let $triple := $fac("foaf:person1", "foaf:knows", "foaf:person2")
return <result>{$triple}</result> 
	
=>
<result>
  <sem:triple xmlns:sem="http://marklogic.com/semantics">
     <sem:subject>http://xmlns.com/foaf/0.1/person1</sem:subject>
     <sem:predicate>http://xmlns.com/foaf/0.1/knows</sem:predicate>
     <sem:object>http://xmlns.com/foaf/0.1/person2</sem:object>
  </sem:triple>
</result>
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
var prefixes = {"a": "http://marklogic.com/a"};
var fac = sem.rdfBuilder();
xdmp.apply(fac, "_:person1", "a", "foaf:Person");
	
=>
sem.triple(
  sem.blank("http://marklogic.com/semantics/blank/6198496751368939587"), 
  sem.iri("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), 
  sem.iri("http://xmlns.com/foaf/0.1/Person"))
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";

let $fac := sem:rdf-builder()
let $t1 := $fac("_:person1", "a", "foaf:Person") 
let $t2 := $fac("_:person2", "a", "foaf:Person") 
let $t3 := $fac("_:person1", "foaf:knows", "_:person2") 
return ($t1,$t2,$t3)
 
	
=>
sem:triple(
  sem:blank("http://marklogic.com/semantics/blank/3655782280846814211"),
  sem:iri("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
  sem:iri("http://xmlns.com/foaf/0.1/Person"))

sem:triple(
  sem:blank("http://marklogic.com/semantics/blank/1129346327653055324"),
  sem:iri("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
  sem:iri("http://xmlns.com/foaf/0.1/Person"))
 
sem:triple(
  sem:blank("http://marklogic.com/semantics/blank/3655782280846814211"),
  sem:iri("http://xmlns.com/foaf/0.1/knows"),
  sem:blank("http://marklogic.com/semantics/blank/1129346327653055324"))
    ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="describe" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>This function implements the Concise Bounded Description 
	(CBD) specification to describe one or more nodes in the graph. This 
	implementation does not provide any reified statements, and will return 
	a maximum of 9,999 triples. 
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="iris" type="sem:iri*">A set of IRIs representing 
		  graph nodes.
	  </apidoc:param>
  </apidoc:params>
  <apidoc:return>sem:triple*</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";
sem:describe(sem:iri("urn:isbn:9780080540160"))
	
=>
   	sem:triple(sem:iri("urn:isbn:9780080540160"),
	sem:iri("http://purl.org/dc/elements/1.1/title"),
	"Query XML,&#10;XQuery, XPath, and SQL/XML in context")
    ]]></pre>
  </apidoc:example>

  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");
sem.describe(sem.iri("urn:isbn:9780080540160"));
	
=>
   sem.triple(sem.iri("urn:isbn:9780080540160"),
	sem.iri("http://purl.org/dc/elements/1.1/title"),
	"Query XML,&#10;XQuery, XPath, and SQL/XML in context")
    ]]></pre>
  </apidoc:example>

</apidoc:function>

<apidoc:function name="transitive-closure" lib="sem" 
	category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>From a starting set of seeds, follow a given set 
		of predicates, to a given depth, and return all unique node 
		IRIs.</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="seeds" type="sem:iri*">
		  A set of seed IRIs.
	  </apidoc:param>
	  <apidoc:param name="predicates" type="sem:iri*">
		  A set of predicates to follow.
	  </apidoc:param>
	  <apidoc:param name="limit" type="xs:integer">
		  A limit of how many predicates to follow.
	  </apidoc:param>
  </apidoc:params>
  <apidoc:return>sem:iri*</apidoc:return>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
      at "/MarkLogic/semantics.xqy";

sem:transitive-closure(
    sem:iri("http://www.w3.org/People/Berners-Lee/card#i"),
    sem:iri("http://xmlns.com/foaf/0.1/knows"),
    9)
=>
http://www.w3.org/People/Berners-Lee/card#i
    ]]></pre>
  </apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[

var sem = require("/MarkLogic/semantics.xqy");
sem.transitiveClosure(
    sem.iri("http://www.w3.org/People/Berners-Lee/card#i"),
    sem.iri("http://xmlns.com/foaf/0.1/knows"),
    9);
=>
http://www.w3.org/People/Berners-Lee/card#i
    ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="sparql-values" lib="sem" category="Semantics" subcategory="Semantic Functions">
	<apidoc:summary>
		This function executes a SPARQL SELECT query using
		passed-in bindings participating as a starting point for 
		the query.
	</apidoc:summary>
  <apidoc:params>
	  <apidoc:param name="sparql" type="xs:string">
		  The SPARQL query to be executed. Must be a SELECT query 
		  form.
	  </apidoc:param>
	  <apidoc:param name="values" type="map:map*">
		  A map containing initial bindings for variables 
		  used in the query.  Unlike <code>sem:sparql</code>, a 
		  sequence of bindings is acceptable and will be processed 
		  as the equivalent of an outermost VALUES block in the query.
	  </apidoc:param>
    <apidoc:param name="options" type="xs:string*" optional="true">
      Query options. Valid options values include:
      <blockquote>
        <dl>
          <dt>
		    <b>"base=<em>IRI</em>"</b>
          </dt>
          <dd>
            The initial base IRI for the query.
          </dd>
          <dt>
            <b>"default-graph=<em>IRI</em>*"</b>
          </dt>
          <dd>
		  Add the named graph or graphs specified by the IRI to the default 
		  graph for the query.
          </dd>
          <dt>
            <b>"named-graph=<em>IRI</em>*"</b>
          </dt>
          <dd>
		  Add the named graph or graphs specified by the IRI to the list of 
		  named graphs available in the query.
          </dd>
          <dt>
		  <b>"optimize=<em>N</em>"</b>
          </dt>
          <dd>
		  Sets the optimization level to use. Levels of 0 (off), 
		  1, and 2 are recognized. Default is 1.	
          </dd>
         </dl>
      </blockquote>
    </apidoc:param>
	<apidoc:param name="store" type="item()*" optional="true">
		Options for "any", "document", "properties", "locks", "checked", and 
		"unchecked", which used to be part of the <code>sem:sparql-values</code> 
		signature, must be specified as part of 
		<a href="#sem:store"><code>sem:store</code></a>, not as part of 
		<code>sem:sparql-values</code>.  
		This parameter is designed to take <code>sem:store*</code>, but is 
		typed as an <code>item()*</code> for backward compatibility. The default 
		for <code>sem:store</code> is the current database's triple index, restricted by the options and the <code>cts:query</code> argument (for instance, "triples in documents matching this query"). 
		<p>
		The locking option specified in <code>sem:store</code> will be used 
		by <code>sem:sparql-values</code>. Locking is ignored in a query transaction. 
		</p>
		<p>
		If a <code>sem:store</code> value is not supplied, then the default 
		<code>sem:store</code> for the statement will be used. This is the 
		same as calling <code>sem:store()</code> with all arguments omitted, 
		which will access the current database's triple index, using 
		the default rulesets configured for that database. The default for 
		locking is <code>read-write</code>.
        </p>
	</apidoc:param>
  </apidoc:params>
  <apidoc:return>map:map*</apidoc:return>
  <apidoc:usage>
  <p> If $values is an empty sequence, nothing is returned. </p>
  <p> A variable can be in both bindings and the VALUES clause. </p>
  <p> The binding variable must occur in either the SELECT clause
      or the triple patterns, otherwise an "Undefined variable" 
	  exception is thrown. </p>
  <p>The <code>sem:sparql-values</code> function performs a join 
	  (SPARQL style, natural join) between the bindings returned 
	  from the SELECT expression and the bindings passed in as 
	  an argument, therefore the results reflect this join. </p>
   </apidoc:usage>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[
xquery version "1.0-ml"; 
 
import module namespace sem = "http://marklogic.com/semantics" 
    at "/MarkLogic/semantics.xqy";

let $bindings := (
    map:entry("s",
        sem:iri("http://example.net/foaf.rdf#Lenovo_T61")),
    map:entry("s",
        sem:iri("http://example.net/foaf.rdf#Nokia_N80"))
    )
return sem:sparql-values("select * where { ?s ?p ?o }", $bindings)
    ]]></pre>
  </apidoc:example>
   <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[
var sem = require("/MarkLogic/semantics.xqy");

var bindings = [
  {"s": sem.iri("http://example.net/foaf.rdf#Lenovo_T61")},
  {"s": sem.iri("http://example.net/foaf.rdf#Nokia_N80")}
  ];
sem.sparqlValues("select * where { ?s ?p ?o }", bindings);

    ]]></pre>
  </apidoc:example>
</apidoc:function>

<apidoc:function name="iri" lib="sem" category="Semantics" 
    subcategory="Semantic Functions">
	<apidoc:summary>This is a constructor function that takes a string
		and constructs an item of type <code class="xquery">sem:iri</code>
		<code class="javascript">sem.iri</code> from it.
	</apidoc:summary>
	<apidoc:params>
		<apidoc:param  name="string-iri" type="xs:string">
			The string with which to construct the 
			<code class="xquery">sem:iri</code><code class="javascript">sem.iri</code>.
		</apidoc:param>
	</apidoc:params>
  <apidoc:return class="xquery">sem:iri</apidoc:return>
  <apidoc:return class="javascript">sem.iri</apidoc:return>
   <apidoc:usage>
   <p>When using <span class="xquery"><code>sem:iri</code></span>
   <span class="javascript"><code>sem.iri</code></span> with 
   SPARQL or SPARQL Update, don't use <code>&lt;</code> and <code>&gt;</code> 
   around the iri string. For example, <span class="xquery">
   <code>sem:iri("my iri")</code></span><span class="javascript">
   <code>sem.iri("my iri")</code></span>.</p>
   </apidoc:usage>
  <apidoc:example class="xquery"><pre xml:space="preserve"><![CDATA[

xquery version "1.0-ml"; 
 
sem:iri("/my/iri")
 
    ]]></pre>
  </apidoc:example>
  <apidoc:example class="javascript"><pre xml:space="preserve"><![CDATA[

var sem = require("/MarkLogic/semantics.xqy");

sem.iri("/my/iri")
    ]]></pre>
  </apidoc:example>
</apidoc:function>

</apidoc:module>
