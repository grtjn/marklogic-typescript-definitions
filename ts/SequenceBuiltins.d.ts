// Type definitions for SequenceBuiltins
// Definitions: 

/**
These built-in functions are XQuery functions defined to operate on
sequences. They are defined in
XQuery 1.0
and XPath 2.0 Functions and Operators.
**/

interface fnFunctions {

    /** Computes the effective boolean value of the sequence $arg. See Section 2.4.3 Effective Boolean Value[XP]. NOTE: NEW 1.0 SEMANTICS NOT IMPLEMENTED: STILL USES MAY 2003 SEMANTICS. If $arg is the empty sequence, fn:boolean returns false. If $arg is a sequence whose first item is a node, fn:boolean returns true. If $arg is a singleton value of type xs:boolean or a derived from xs:boolean, fn:boolean returns $arg. If $arg is a singleton value of type xs:string or a type derived from xs:string or xs:untypedAtomic, fn:boolean returns false if the operand value has zero length; otherwise it returns true. If $arg is a singleton value of any numeric type or a type derived from a numeric type, fn:boolean returns false if the operand value is NaN or is numerically equal to zero; otherwise it returns true. In all other cases, fn:boolean raises a type error [err:FORG0006] when run in XQuery strict mode (1.0). The static semantics of this function are described in Section 7.2.4 The fn:boolean function[FS]. Note: The result of this function is not necessarily the same as " $arg cast as xs:boolean ". For example, fn:boolean("false") returns the value "true" whereas "false" cast as xs:boolean returns false. **/
  boolean(arg: Object, collation?: string): Object;

    /** Returns a sequence of positive integers giving the positions within the sequence $seqParam of items that are equal to $srchParam. The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required. The items in the sequence $seqParam are compared with $srchParam under the rules for the eq operator. Values that cannot be compared, i.e. the eq operator is not defined for their types, are considered to be distinct. If an item compares equal, then the position of that item in the sequence $srchParam is included in the result. If the value of $seqParam is the empty sequence, or if no item in $seqParam matches $srchParam, then the empty sequence is returned. The first item in a sequence is at position 1, not position 0. The result sequence is in ascending numeric order. **/
  indexOf(seqParam: Object, srchParam: Object, collationLiteral?: string): number;

    /** If the value of $arg is the empty sequence, the function returns true; otherwise, the function returns false. **/
  empty(arg: string): Object;

    /** If the value of $arg is not the empty sequence, the function returns true; otherwise, the function returns false. **/
  exists(arg: string): Object;

    /** Returns the sequence that results from removing from $arg all but one of a set of values that are eq to one other. Values that cannot be compared, i.e. the eq operator is not defined for their types, are considered to be distinct. Values of type xs:untypedAtomic are compared as if they were of type xs:string. The order in which the sequence of values is returned is implementation dependent. The static type of the result is a sequence of prime types as defined in Section 7.2.7 The fn:distinct-values function[FS]. The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required. If $arg is the empty sequence, the empty sequence is returned. For xs:float and xs:double values, positive zero is equal to negative zero and, although NaN does not equal itself, if $arg contains multiple NaN values a single NaN is returned. If xs:dateTime, xs:date or xs:time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Note that xs:dateTime, xs:date or xs:time values can compare equal even if their timezones are different. Which value of a set of values that compare equal is returned is implementation dependent. **/
  distinctValues(arg: Object, collation?: string): Object;

    /** Returns a new sequence constructed from the value of $target with the value of $inserts inserted at the position specified by the value of $position. (The value of $target is not affected by the sequence construction.) If $target is the empty sequence, $inserts is returned. If $inserts is the empty sequence, $target is returned. The value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $inserts, followed by the remaining elements of $target, in that sequence. If $position is less than one (1), the first position, the effective value of $position is one (1). If $position is greater than the number of items in $target, then the effective value of $position is equal to the number of items in $target plus 1. For detailed semantics see, Section 7.2.15 The fn:insert-before function[FS]. **/
  insertBefore(target: string, position: number, inserts: string): string;

    /** Returns a new sequence constructed from the value of $target with the item at the position specified by the value of $position removed. If $position is less than 1 or greater than the number of items in $target, $target is returned. Otherwise, the value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $target whose index is greater than $position. If $target is the empty sequence, the empty sequence is returned. For detailed type semantics, see Section 7.2.11 The fn:remove function[FS]. **/
  remove(target: string, position: number): string;

    /** Reverses the order of items in a sequence. If $arg is the empty sequence, the empty sequence is returned. For detailed type semantics, see Section 7.2.12 The fn:reverse function[FS]. **/
  reverse(target: string): string;

    /** Returns the contiguous sequence of items in the value of $sourceSeq beginning at the position indicated by the value of $startingLoc and continuing for the number of items indicated by the value of $length. In the two-argument case, returns: $sourceSeq[fn:round($startingLoc) le $p] In the three-argument case, returns: $sourceSeq[fn:round($startingLoc) le $p and $p lt fn:round($startingLoc) + fn:round($length)] Notes: If $sourceSeq is the empty sequence, the empty sequence is returned. If $startingLoc is zero or negative, the subsequence includes items from the beginning of the $sourceSeq. If $length is not specified, the subsequence includes items to the end of $sourceSeq. If $length is greater than the number of items in the value of $sourceSeq following $startingLoc, the subsequence includes items to the end of $sourceSeq. The first item of a sequence is located at position 1, not position 0. For detailed type semantics, see Section 7.2.13 The fn:subsequence functionFS. The reason the function accepts arguments of type xs:double is that many computations on untyped data return an xs:double result; and the reason for the rounding rules is to compensate for any imprecision in these floating-point computations. **/
  subsequence(sourceSeq: Object, startingLoc: number, length?: number): string;

    /** Returns the items of $sourceSeq in an implementation dependent order. Note: Query optimizers may be able to do a better job if the order of the output sequence is not specified. For example, when retrieving prices from a purchase order, if an index exists on prices, it may be more efficient to return the prices in index order rather than in document order. **/
  unordered(sourceSeq: string): string;

    /** Returns $arg if it contains zero or one items. Otherwise, raises an error [err:FORG0003]. For detailed type semantics, see Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]. **/
  zeroOrOne(arg: string): string;

    /** Returns $arg if it contains one or more items. Otherwise, raises an error [err:FORG0004]. For detailed type semantics, see Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]. **/
  oneOrMore(arg: string): string;

    /** Returns $arg if it contains exactly one item. Otherwise, raises an error [err:FORG0005]. For detailed type semantics, see Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]. **/
  exactlyOne(arg: string): string;

    /** This function assesses whether two sequences are deep-equal to each other. To be deep-equal, they must contain items that are pairwise deep-equal; and for two items to be deep-equal, they must either be atomic values that compare equal, or nodes of the same kind, with the same name, whose children are deep-equal. This is defined in more detail below. The $collation argument identifies a collation which is used at all levels of recursion when strings are compared (but not when names are compared), according to the rules in 7.3.1 Collations. If the two sequences are both empty, the function returns true. If the two sequences are of different lengths, the function returns false. If the two sequences are of the same length, the function returns true if and only if every item in the sequence $parameter1 is deep-equal to the item at the same position in the sequence $parameter2. The rules for deciding whether two items are deep-equal follow. Call the two items $i1 and $i2 respectively. If $i1 and $i2 are both atomic values, they are deep-equal if and only if ($i1 eq $i2) is true. Or if both values are NaN. If the eq operator is not defined for $i1 and $i2, the function returns false. If one of the pair $i1 or $i2 is an atomic value and the other is a node, the function returns false. If $i1 and $i2 are both nodes, they are compared as described below: If the two nodes are of different kinds, the result is false. If the two nodes are both document nodes then they are deep-equal if and only if the sequence $i1/(*|text()) is deep-equal to the sequence $i2/(*|text()). If the two nodes are both element nodes then they are deep-equal if and only if all of the following conditions are satisfied: the two nodes have the same name, that is (node-name($i1) eq node-name($i2)).the two nodes are both annotated as having simple content or both nodes are annotated as having complex content.the two nodes have the same number of attributes, and for every attribute $a1 in $i1/@* there exists an attribute $a2 in $i2/@* such that $a1 and $a2 are deep-equal. One of the following conditions holds: Both element nodes have a type annotation that is simple content, and the typed value of $i1 is deep-equal to the typed value of $i2. Both element nodes have a type annotation that is complex content with elementOnly content, and each child element of $i1 is deep-equal to the corresponding child element of $i2. Both element nodes have a type annotation that is complex content with mixed content, and the sequence $i1/(*|text()) is deep-equal to the sequence $i2/(*|text()). Both element nodes have a type annotation that is complex content with empty content. If the two nodes are both attribute nodes then they are deep-equal if and only if both the following conditions are satisfied: the two nodes have the same name, that is (node-name($i1) eq node-name($i2)).the typed value of $i1 is deep-equal to the typed value of $i2. If the two nodes are both processing instruction nodes or namespace bindings, then they are deep-equal if and only if both the following conditions are satisfied: the two nodes have the same name, that is (node-name($i1) eq node-name($i2)). the string value of $i1 is equal to the string value of $i2. If the two nodes are both text nodes or comment nodes, then they are deep-equal if and only if their string-values are equal. Notes: The two nodes are not required to have the same type annotation, and they are not required to have the same in-scope namespaces. They may also differ in their parent, their base URI, and the values returned by the is-id and is-idrefs accesors (see Section 5.5 is-id Accessor[DM] and Section 5.6 is-idrefs Accessor[DM]). The order of children is significant, but the order of attributes is insignificant. The following note applies to the Jan 2007 XQuery specification, but not to the May 2003 XQuery specification: The contents of comments and processing instructions are significant only if these nodes appear directly as items in the two sequences being compared. The content of a comment or processing instruction that appears as a descendant of an item in one of the sequences being compared does not affect the result. However, the presence of a comment or processing instruction, if it causes a text node to be split into two text nodes, may affect the result. The result of fn:deep-equal(1, current-dateTime()) is false; it does not raise an error. **/
  deepEqual(parameter1: string, parameter2: string, collation?: string): Object;

    /** Returns the number of items in the value of $arg. Returns 0 if $arg is the empty sequence. **/
  count(arg: string, maximum?: number): number;

    /** Returns the average of the values in the input sequence $arg, that is, the sum of the values divided by the number of values. If $arg is the empty sequence, the empty sequence is returned. If $arg contains values of type xs:untypedAtomic they are cast to xs:double. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. After these operations, $arg must contain items of a single type, which must be one of the four numeric types,xs:yearMonthDuration or xs:dayTimeDuration or one if its subtypes. If the above conditions are not met, then a type error is raised [err:FORG0006]. Otherwise, returns the average of the values computed as sum($arg) div count($arg). For detailed type semantics, see Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]. **/
  avg(arg: Object): Object;

    /** Selects an item from the input sequence $arg whose value is greater than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent. The following rules are applied to the input sequence: Values of type xs:untypedAtomic in $arg are cast to xs:double.For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence.This function returns an item from the converted sequence rather than the input sequence. If the converted sequence is empty, the empty sequence is returned. All items in $arg must be numeric or derived from a single base type for which the ge operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. If any of these conditions is not met, then a type error is raised [err:FORG0006]. If the converted sequence contains the value NaN, the value NaN is returned. If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used. If the type of the items in $arg is not xs:string and $collation is specified, the collation is ignored. The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. Otherwise, the result of the function is the result of the expression: if (every $v in $c satisfies $c[1] ge $v) then $c[1] else fn:max(fn:subsequence($c, 2)) evaluated with $collation as the default collation if specified, and with $c as the converted sequence. For detailed type semantics, see Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]. Notes: If the converted sequence contains exactly one value then that value is returned. The default type when the fn:max function is applied to xs:untypedAtomic values is xs:double. This differs from the default type for operators such as gt, and for sorting in XQuery and XSLT, which is xs:string. **/
  max(arg: Object, collation?: string): Object;

    /** Selects an item from the input sequence $arg whose value is less than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent. The following rules are applied to the input sequence: Values of type xs:untypedAtomic in $arg are cast to xs:double.For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence.This function returns an item from the converted sequence rather than the input sequence. If the converted sequence is empty, the empty sequence is returned. All items in $arg must be numeric or derived from a single base type for which the le operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. If any of these conditions is not met, then a type error is raised [err:FORG0006]. If the converted sequence contains the value NaN, the value NaN is returned. If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used. If the type of the items in $arg is not xs:string and $collation is specified, the collation is ignored. The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. Otherwise, the result of the function is the result of the expression: if (every $v in $c satisfies $c[1] le $v) then $c[1] else fn:min(fn:subsequence($c, 2)) evaluated with $collation as the default collation if specified, and with $c as the converted sequence. For detailed type semantics, see Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]. Notes: If the converted sequence contains exactly one value then that value is returned. The default type when the fn:min function is applied to xs:untypedAtomic values is xs:double. This differs from the default type for operators such as gt, and for sorting in XQuery and XSLT, which is xs:string. **/
  min(arg: Object, collation?: string): Object;

    /** Returns a value obtained by adding together the values in $arg. If $zero is not specified, then the value returned for an empty sequence is the xs:integer value 0. If $zero is specified, then the value returned for an empty sequence is $zero. Any values of type xs:untypedAtomic in $arg are cast to xs:double. The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence. If the converted sequence is empty, then the single-argument form of the function returns the xs:integer value 0; the two-argument form returns the value of the argument $zero. If the converted sequence contains the value NaN, NaN is returned. All items in $arg must be numeric or derived from a single base type. In addition, the type must support addition. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. The sum of a sequence of integers will therefore be an integer, while the sum of a numeric sequence that includes at least one xs:double will be an xs:double. If the above conditions are not met, a type error is raised [err:FORG0006]. Otherwise, the result of the function, using the second signature, is the result of the expression: if (fn:count($c) eq 0) then $zero else if (fn:count($c) eq 1) then $c[1] else $c[1] + fn:sum(subsequence($c, 2)) where $c is the converted sequence. The result of the function, using the first signature, is the result of the expression:fn:sum($arg, 0). For detailed type semantics, see Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]. Notes: The second argument allows an appropriate value to be defined to represent the sum of an empty sequence. For example, when summing a sequence of durations it would be appropriate to return a zero-length duration of the appropriate type. This argument is necessary because a system that does dynamic typing cannot distinguish "an empty sequence of integers", for example, from "an empty sequence of durations". If the converted sequence contains exactly one value then that value is returned. **/
  sum(arg: Object, zero?: Object): Object;

    /** Returns the sequence of element nodes that have an ID value matching the value of one or more of the IDREF values supplied in $arg. **/
  id(arg: string, node?: Node): Node;

    /** Returns the sequence of element or attribute nodes that have an IDREF value matching the value of one or more of the ID values supplied in $arg. **/
  idref(arg: string, node?: Node): Node;

    /** Returns the document(s) stored in the database at the specified URI(s). If you are only getting a single document (specifying a single URI), you can use cts.doc instead (so you do not need to iterate through the ValueIterator to get to the document). **/
  doc(uri?: Object): Node;

    /** If fn:doc($uri) returns a document node, this function returns true. If $uri is not a valid xs:anyURI, an error is raised [err:FODC0005]. Otherwise, this function returns false. If this function returns true, then calling fn:doc($uri) within the same execution scope must return a document node. **/
  docAvailable(uri: string): Object;

    /** Returns all of the documents that belong to the specified collection(s). **/
  collection(uri?: string): Node;

    /** Returns the document(s) stored in the database at the specified URI(s). The URI(s) are resolved according to the base-uri of the calling stylesheet or XQuery main module. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml. **/
  document(uris: Object, baseNode?: Node): Node;

    /** Reads a file stored in the database as either text or binary file and returns its contents as a string. **/
  unparsedText(href: string, encoding?: string): string;

    /** Returns true if a call to unparsed-text would succeed with identical arguments. **/
  unparsedTextAvailable(href: string, encoding?: string): Object;

}
declare var fn:fnFunctions
